AGDA_UNEXPECTED_FAIL

ret > ExitFailure 1
out > new sort meta _0 : {A : Set} →
out >                    "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [1]
out > coerce term      v  = A
out >        from type t1 = Set
out >        to type   t2 = _0
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _0
out >    sorts: Set₁  and  univSort _0
out > compareTerm Set =< _0 
out > compareTerm (not syntactically equal) Set =< _0 
out > { compareAtom
out > compareAtom Set =< _0 
out > compareAtom Set =< _0 
out > equalSort
out >   Set == _0
out >   Set == _0 {@0}
out > term _0 :DirEq Set
out > term _0 :DirEq Set
out > is _0 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _0
out >   _0 := Set  is a sort
out > solving _0 := λ {A} → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 1 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _1 : {A = A₁ : Set} (x : A₁) →
out >                    "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [2]
out > coerce term      v  = A
out >        from type t1 = Set
out >        to type   t2 = _1
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _1
out >    sorts: Set₁  and  univSort _1
out > compareTerm Set =< _1 
out > compareTerm (not syntactically equal) Set =< _1 
out > { compareAtom
out > compareAtom Set =< _1 
out > compareAtom Set =< _1 
out > equalSort
out >   Set == _1
out >   Set == _1 {@1} @0
out > term _1 :DirEq Set
out > term _1 :DirEq Set
out > is _1 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _1
out >   _1 := Set  is a sort
out > solving _1 := (λ {A} x → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 2 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _2 : {A : Set} (x : A) →
out >                    "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { compareType
out > compareType Set = _2
out >    sorts: Set₁  and  univSort _2
out > compareTerm Set = _2 
out > compareTerm (not syntactically equal) Set = _2 
out > { compareAtom
out > compareAtom Set = _2 
out > compareAtom Set = _2 
out > equalSort
out >   Set == _2
out >   Set == _2 {@2} @1
out > term _2 :DirEq Set
out > term _2 :DirEq Set
out > is _2 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _2
out >   _2 := Set  is a sort
out > solving _2 := λ {A} x → Set
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] Has bigger sort: Set
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > new sort meta _3 : {A = A₁ : Set} (x₁ : A₁) →
out >                    "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > new meta (ConcreteDef): [{_}, x] |-
out >   _4 : {A = A₁ : Set} (x₁ : A₁) → Set
out > { working on problems [3]
out > coerce term      v  = x
out >        from type t1 = A
out >        to type   t2 = _A_4
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType A =< _A_4
out >    sorts: Set  and  Set
out > compareTerm A =< _A_4 
out > compareTerm (not syntactically equal) A =< _A_4 
out > attempting shortcut _A_4 := A
out > term _A_4 :DirGeq A
out > term _A_4 :DirGeq A
out > is _4 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_4
out >   _A_4  :  Set := A
out > elimView of  A
out > v = Var 1 []
out > elimView (projections reduced) of  A
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_4 := (λ {A} x → A)
out > shortcut successful
out >   result: @1
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 3 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [4]
out > coerce term      v  = x
out >        from type t1 = A
out >        to type   t2 = A
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType A =< A
out >    sorts: Set  and  Set
out > compareTerm A =< A 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 4 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [5]
out > coerce term      v  = x ≡ x
out >        from type t1 = Set
out >        to type   t2 = _3
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _3
out >    sorts: Set₁  and  univSort _3
out > compareTerm Set =< _3 
out > compareTerm (not syntactically equal) Set =< _3 
out > { compareAtom
out > compareAtom Set =< _3 
out > compareAtom Set =< _3 
out > equalSort
out >   Set == _3
out >   Set == _3 {@1} @0
out > term _3 :DirEq Set
out > term _3 :DirEq Set
out > is _3 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _3
out >   _3 := Set  is a sort
out > solving _3 := λ {A} x → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 5 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > compareTerm A = A : Set
out > compareTerm x = x : A
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _5 : (A : Set) →
out >                    "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [6]
out > coerce term      v  = A
out >        from type t1 = Set
out >        to type   t2 = _5
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _5
out >    sorts: Set₁  and  univSort _5
out > compareTerm Set =< _5 
out > compareTerm (not syntactically equal) Set =< _5 
out > { compareAtom
out > compareAtom Set =< _5 
out > compareAtom Set =< _5 
out > equalSort
out >   Set == _5
out >   Set == _5 @0
out > term _5 :DirEq Set
out > term _5 :DirEq Set
out > is _5 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _5
out >   _5 := Set  is a sort
out > solving _5 := (λ A → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 6 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _6 : (A : Set) (B : A → Set) →
out >                    "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [7]
out > coerce term      v  = A
out >        from type t1 = Set
out >        to type   t2 = _6
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _6
out >    sorts: Set₁  and  univSort _6
out > compareTerm Set =< _6 
out > compareTerm (not syntactically equal) Set =< _6 
out > { compareAtom
out > compareAtom Set =< _6 
out > compareAtom Set =< _6 
out > equalSort
out >   Set == _6
out >   Set == _6 @1 @0
out > term _6 :DirEq Set
out > term _6 :DirEq Set
out > is _6 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _6
out >   _6 := Set  is a sort
out > solving _6 := λ A B → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 7 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _7 : (A₁ : Set) (B₁ : A₁ → Set) (fst : A₁) →
out >                    "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [8]
out > coerce term      v  = fst
out >        from type t1 = A
out >        to type   t2 = A
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType A =< A
out >    sorts: Set  and  Set
out > compareTerm A =< A 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 8 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [9]
out > coerce term      v  = B fst
out >        from type t1 = Set
out >        to type   t2 = _7
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _7
out >    sorts: Set₁  and  univSort _7
out > compareTerm Set =< _7 
out > compareTerm (not syntactically equal) Set =< _7 
out > { compareAtom
out > compareAtom Set =< _7 
out > compareAtom Set =< _7 
out > equalSort
out >   Set == _7
out >   Set == _7 @2 @1 @0
out > term _7 :DirEq Set
out > term _7 :DirEq Set
out > is _7 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _7
out >   _7 := Set  is a sort
out > solving _7 := λ A B fst → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 9 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _8 : {A : Set} →
out >                    "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [10]
out > coerce term      v  = A
out >        from type t1 = Set
out >        to type   t2 = _8
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _8
out >    sorts: Set₁  and  univSort _8
out > compareTerm Set =< _8 
out > compareTerm (not syntactically equal) Set =< _8 
out > { compareAtom
out > compareAtom Set =< _8 
out > compareAtom Set =< _8 
out > equalSort
out >   Set == _8
out >   Set == _8 {@0}
out > term _8 :DirEq Set
out > term _8 :DirEq Set
out > is _8 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _8
out >   _8 := Set  is a sort
out > solving _8 := λ {A} → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 10 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _9 : (A B : Set) →
out >                    "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { compareType
out > compareType Set = _9
out >    sorts: Set₁  and  univSort _9
out > compareTerm Set = _9 
out > compareTerm (not syntactically equal) Set = _9 
out > { compareAtom
out > compareAtom Set = _9 
out > compareAtom Set = _9 
out > equalSort
out >   Set == _9
out >   Set == _9 @1 @0
out > term _9 :DirEq Set
out > term _9 :DirEq Set
out > is _9 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _9
out >   _9 := Set  is a sort
out > solving _9 := λ A B → Set
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] Has bigger sort: Set
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > new sort meta _10 : (A₁ B₁ : Set) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [11]
out > coerce term      v  = A
out >        from type t1 = Set
out >        to type   t2 = _10
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _10
out >    sorts: Set₁  and  univSort _10
out > compareTerm Set =< _10 
out > compareTerm (not syntactically equal) Set =< _10 
out > { compareAtom
out > compareAtom Set =< _10 
out > compareAtom Set =< _10 
out > equalSort
out >   Set == _10
out >   Set == _10 @1 @0
out > term _10 :DirEq Set
out > term _10 :DirEq Set
out > is _10 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _10
out >   _10 := Set  is a sort
out > solving _10 := (λ A B → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 11 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _11 : (A₁ B₁ : Set) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [12]
out > coerce term      v  = A
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > reduced
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 12 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [13]
out > coerce term      v  = B
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > reduced
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 13 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [14]
out > coerce term      v  = Either A B
out >        from type t1 = Set
out >        to type   t2 = _11
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _11
out >    sorts: Set₁  and  univSort _11
out > compareTerm Set =< _11 
out > compareTerm (not syntactically equal) Set =< _11 
out > { compareAtom
out > compareAtom Set =< _11 
out > compareAtom Set =< _11 
out > equalSort
out >   Set == _11
out >   Set == _11 @1 @0
out > term _11 :DirEq Set
out > term _11 :DirEq Set
out > is _11 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _11
out >   _11 := Set  is a sort
out > solving _11 := λ A B → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 14 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > compareTerm A = A : Set
out > compareTerm B = B : Set
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > new sort meta _12 : (A₁ B₁ : Set) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [15]
out > coerce term      v  = B
out >        from type t1 = Set
out >        to type   t2 = _12
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _12
out >    sorts: Set₁  and  univSort _12
out > compareTerm Set =< _12 
out > compareTerm (not syntactically equal) Set =< _12 
out > { compareAtom
out > compareAtom Set =< _12 
out > compareAtom Set =< _12 
out > equalSort
out >   Set == _12
out >   Set == _12 @1 @0
out > term _12 :DirEq Set
out > term _12 :DirEq Set
out > is _12 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _12
out >   _12 := Set  is a sort
out > solving _12 := (λ A B → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 15 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _13 : (A₁ B₁ : Set) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [16]
out > coerce term      v  = A
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > reduced
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 16 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [17]
out > coerce term      v  = B
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > reduced
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 17 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [18]
out > coerce term      v  = Either A B
out >        from type t1 = Set
out >        to type   t2 = _13
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _13
out >    sorts: Set₁  and  univSort _13
out > compareTerm Set =< _13 
out > compareTerm (not syntactically equal) Set =< _13 
out > { compareAtom
out > compareAtom Set =< _13 
out > compareAtom Set =< _13 
out > equalSort
out >   Set == _13
out >   Set == _13 @1 @0
out > term _13 :DirEq Set
out > term _13 :DirEq Set
out > is _13 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _13
out >   _13 := Set  is a sort
out > solving _13 := λ A B → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 18 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > compareTerm A = A : Set
out > compareTerm B = B : Set
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _14 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { compareType
out > compareType Set = _14
out >    sorts: Set₁  and  univSort _14
out > compareTerm Set = _14 
out > compareTerm (not syntactically equal) Set = _14 
out > { compareAtom
out > compareAtom Set = _14 
out > compareAtom Set = _14 
out > equalSort
out >   Set == _14
out >   Set == _14
out > term _14 :DirEq Set
out > term _14 :DirEq Set
out > is _14 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _14
out >   _14 := Set  is a sort
out > solving _14 := Set
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] Has bigger sort: Set
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > new sort meta _15 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [19]
out > coerce term      v  = U
out >        from type t1 = Set
out >        to type   t2 = _15
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _15
out >    sorts: Set₁  and  univSort _15
out > compareTerm Set =< _15 
out > compareTerm (not syntactically equal) Set =< _15 
out > { compareAtom
out > compareAtom Set =< _15 
out > compareAtom Set =< _15 
out > equalSort
out >   Set == _15
out >   Set == _15
out > term _15 :DirEq Set
out > term _15 :DirEq Set
out > is _15 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _15
out >   _15 := Set  is a sort
out > solving _15 := Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 19 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > leqSort Set₁ =< Set
out > compareLevel Agda.Primitive.lsuc Agda.Primitive.lzero =<
out >              Agda.Primitive.lzero
out > compareLevelView lsuc lzero =< lzero
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _16 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [20]
out > coerce term      v  = U
out >        from type t1 = Set
out >        to type   t2 = _16
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _16
out >    sorts: Set₁  and  univSort _16
out > compareTerm Set =< _16 
out > compareTerm (not syntactically equal) Set =< _16 
out > { compareAtom
out > compareAtom Set =< _16 
out > compareAtom Set =< _16 
out > equalSort
out >   Set == _16
out >   Set == _16
out > term _16 :DirEq Set
out > term _16 :DirEq Set
out > is _16 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _16
out >   _16 := Set  is a sort
out > solving _16 := Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 20 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > { working on problems [21]
out > problem 21 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [22]
out > problem 22 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [23]
out > coerce term      v  = A
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 23 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _17 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [24]
out > coerce term      v  = Ctxt
out >        from type t1 = Set
out >        to type   t2 = _17
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _17
out >    sorts: Set₁  and  univSort _17
out > compareTerm Set =< _17 
out > compareTerm (not syntactically equal) Set =< _17 
out > { compareAtom
out > compareAtom Set =< _17 
out > compareAtom Set =< _17 
out > equalSort
out >   Set == _17
out >   Set == _17
out > term _17 :DirEq Set
out > term _17 :DirEq Set
out > is _17 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _17
out >   _17 := Set  is a sort
out > solving _17 := Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 24 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _18 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { compareType
out > compareType Set = _18
out >    sorts: Set₁  and  univSort _18
out > compareTerm Set = _18 
out > compareTerm (not syntactically equal) Set = _18 
out > { compareAtom
out > compareAtom Set = _18 
out > compareAtom Set = _18 
out > equalSort
out >   Set == _18
out >   Set == _18
out > term _18 :DirEq Set
out > term _18 :DirEq Set
out > is _18 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _18
out >   _18 := Set  is a sort
out > solving _18 := Set
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] Has bigger sort: Set
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > new sort meta _19 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [25]
out > coerce term      v  = Ctxt
out >        from type t1 = Set
out >        to type   t2 = _19
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _19
out >    sorts: Set₁  and  univSort _19
out > compareTerm Set =< _19 
out > compareTerm (not syntactically equal) Set =< _19 
out > { compareAtom
out > compareAtom Set =< _19 
out > compareAtom Set =< _19 
out > equalSort
out >   Set == _19
out >   Set == _19
out > term _19 :DirEq Set
out > term _19 :DirEq Set
out > is _19 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _19
out >   _19 := Set  is a sort
out > solving _19 := Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 25 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _20 : (G : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [26]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 26 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [27]
out > coerce term      v  = Env G
out >        from type t1 = Set
out >        to type   t2 = _20
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _20
out >    sorts: Set₁  and  univSort _20
out > compareTerm Set =< _20 
out > compareTerm (not syntactically equal) Set =< _20 
out > { compareAtom
out > compareAtom Set =< _20 
out > compareAtom Set =< _20 
out > equalSort
out >   Set == _20
out >   Set == _20 @0
out > term _20 :DirEq Set
out > term _20 :DirEq Set
out > is _20 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _20
out >   _20 := Set  is a sort
out > solving _20 := (λ G → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 27 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _21 : (G₁ : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [28]
out > coerce term      v  = U
out >        from type t1 = Set
out >        to type   t2 = _21
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _21
out >    sorts: Set₁  and  univSort _21
out > compareTerm Set =< _21 
out > compareTerm (not syntactically equal) Set =< _21 
out > { compareAtom
out > compareAtom Set =< _21 
out > compareAtom Set =< _21 
out > equalSort
out >   Set == _21
out >   Set == _21 @0
out > term _21 :DirEq Set
out > term _21 :DirEq Set
out > is _21 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _21
out >   _21 := Set  is a sort
out > solving _21 := λ G → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 28 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _22 : (G₁ : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [29]
out > coerce term      v  = Ctxt
out >        from type t1 = Set
out >        to type   t2 = _22
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _22
out >    sorts: Set₁  and  univSort _22
out > compareTerm Set =< _22 
out > compareTerm (not syntactically equal) Set =< _22 
out > { compareAtom
out > compareAtom Set =< _22 
out > compareAtom Set =< _22 
out > equalSort
out >   Set == _22
out >   Set == _22 @0
out > term _22 :DirEq Set
out > term _22 :DirEq Set
out > is _22 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _22
out >   _22 := Set  is a sort
out > solving _22 := λ G → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 29 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > { working on problems [30]
out > problem 30 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [31]
out > problem 31 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [32]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 32 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [33]
out > coerce term      v  = Env G
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 33 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [34]
out > problem 34 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [35]
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 35 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [36]
out > coerce term      v  = g
out >        from type t1 = (Env G)
out >        to type   t2 = (Env G)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Env G) =< (Env G)
out >    sorts: Set  and  Set
out > compareTerm (Env G) =< (Env G) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 36 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [37]
out > coerce term      v  = El (s g)
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 37 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [38]
out > coerce term      v  = Σ (Env G) (λ g → El (s g))
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 38 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _23 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [39]
out > coerce term      v  = Ctxt
out >        from type t1 = Set
out >        to type   t2 = _23
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _23
out >    sorts: Set₁  and  univSort _23
out > compareTerm Set =< _23 
out > compareTerm (not syntactically equal) Set =< _23 
out > { compareAtom
out > compareAtom Set =< _23 
out > compareAtom Set =< _23 
out > equalSort
out >   Set == _23
out >   Set == _23
out > term _23 :DirEq Set
out > term _23 :DirEq Set
out > is _23 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _23
out >   _23 := Set  is a sort
out > solving _23 := Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 39 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _24 : (G : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [40]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 40 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [41]
out > coerce term      v  = Env G
out >        from type t1 = Set
out >        to type   t2 = _24
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _24
out >    sorts: Set₁  and  univSort _24
out > compareTerm Set =< _24 
out > compareTerm (not syntactically equal) Set =< _24 
out > { compareAtom
out > compareAtom Set =< _24 
out > compareAtom Set =< _24 
out > equalSort
out >   Set == _24
out >   Set == _24 @0
out > term _24 :DirEq Set
out > term _24 :DirEq Set
out > is _24 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _24
out >   _24 := Set  is a sort
out > solving _24 := (λ G → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 41 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _25 : (G₁ : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [42]
out > coerce term      v  = U
out >        from type t1 = Set
out >        to type   t2 = _25
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _25
out >    sorts: Set₁  and  univSort _25
out > compareTerm Set =< _25 
out > compareTerm (not syntactically equal) Set =< _25 
out > { compareAtom
out > compareAtom Set =< _25 
out > compareAtom Set =< _25 
out > equalSort
out >   Set == _25
out >   Set == _25 @0
out > term _25 :DirEq Set
out > term _25 :DirEq Set
out > is _25 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _25
out >   _25 := Set  is a sort
out > solving _25 := λ G → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 42 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > { working on problems [43]
out > problem 43 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [44]
out > problem 44 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [G, s, t] |-
out >   _26 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (t₁ : Env (snoc G₁ s₁) → U) →
out >         Set
out > new sort meta _27 : (G₁ : Ctxt) (s₁ : Env G₁ → U)
out >                     (t₁ : Env (snoc G₁ s₁) → U) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > new meta (ConcreteDef): [G, s, t] |-
out >   _28 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (t₁ : Env (snoc G₁ s₁) → U) →
out >         _27 (G = G₁) (s = s₁) (t = t₁)
out > new sort meta _29 : (G₁ : Ctxt) (s₁ : Env G₁ → U)
out >                     (t₁ : Env (snoc G₁ s₁) → U) (g : _28 (G = G₁) (s = s₁) (t = t₁)) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > new meta (ConcreteDef): [G, s, t, g₁] |-
out >   _30 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (t₁ : Env (snoc G₁ s₁) → U)
out >         (g : _28 (G = G₁) (s = s₁) (t = t₁)) →
out >         _29 (G = G₁) (s = s₁) (t = t₁) (g = g)
out > { working on problems [45]
out > { compareType
out > compareType U =< _30 (G = G) (s = s) (t = t) (g = g₁)
out >    sorts: Set  and  _29 (G = G) (s = s) (t = t) (g = g₁)
out > compareTerm U =< _30 (G = G) (s = s) (t = t) (g = g₁) 
out > compareTerm (not syntactically equal)
out >   U =< _30 (G = G) (s = s) (t = t) (g = g₁)
out >   
out > attempting shortcut _30 (G = G) (s = s) (t = t) (g = g₁) := U
out > term _30 (G = G) (s = s) (t = t) (g = g₁) :DirGeq U
out > term _30 (G = G) (s = s) (t = t) (g = g₁) :DirGeq U
out > is _30 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _30
out >   _30  :  _29 (G = G) (s = s) (t = t) (g = g) := U
out > elimView of  U
out > v = Def CompileTimeInlining-minimized.U []
out > elimView (projections reduced) of  U
out > { coerceSize
out > leqSort Set =< _29 (G = G) (s = s) (t = t) (g = g)
out > }
out > solving _30 := λ G s t g → U
out > shortcut successful
out >   result: CompileTimeInlining-minimized.U
out > equalSort
out >   Set == _29 (G = G) (s = s) (t = t) (g = g₁)
out >   Set == _29 @3 @2 @1 @0
out > term _29 (G = G) (s = s) (t = t) (g = g₁) :DirEq Set
out > term _29 (G = G) (s = s) (t = t) (g = g₁) :DirEq Set
out > is _29 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _29
out >   _29 := Set  is a sort
out > solving _29 := λ G s t g → Set
out > }
out > problem 45 was solved!
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] Set =< Set
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [G, s, t, g₁] |-
out >   _31 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (t₁ : Env (snoc G₁ s₁) → U)
out >         (g₂ : _28 (G = G₁) (s = s₁) (t = t₁)) →
out >         Set
out > new meta (ConcreteDef): [G, s, t, g₁] |-
out >   _32 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (t₁ : Env (snoc G₁ s₁) → U)
out >         (g₂ : _28 (G = G₁) (s = s₁) (t = t₁)) →
out >         _A_31 (G = G₁) (s = s₁) (t = t₁) (g = g₂) → Set
out > { working on problems [46]
out > coerce term      v  = g₁
out >        from type t1 = _28
out >        to type   t2 = (Σ _A_31 _B_32)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType _28 =< (Σ _A_31 _B_32)
out >    sorts: _27  and  Set
out > compareTerm _28 =< (Σ _A_31 _B_32) 
out > compareTerm (not syntactically equal) _28 =< (Σ _A_31 _B_32) 
out > attempting shortcut _28 := (Σ _A_31 _B_32)
out > term _28 :DirLeq (Σ _A_31 _B_32)
out > term _28 :DirLeq (Σ _A_31 _B_32)
out > is _28 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _28
out >   _28  :  (_27 (G = G) (s = s) (t = t)) := (Σ
out >                                             (_A_33 (G = G) (s = s) (t = t))
out >                                             (λ v → _B_34 (G = G) (s = s) (t = t) v))
out > elimView of  (Σ (_A_33 (G = G) (s = s) (t = t))
out >               (λ v → _B_34 (G = G) (s = s) (t = t) v))
out > v = Def CompileTimeInlining-minimized.Σ [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 33) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 34) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])})]
out > elimView (projections reduced) of  (Σ
out >                                     (_A_33 (G = G) (s = s) (t = t))
out >                                     (λ v → _B_34 (G = G) (s = s) (t = t) v))
out > elimView of  (_A_33 (G = G) (s = s) (t = t))
out > v = MetaV (MetaId 33) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  (_A_33 (G = G) (s = s) (t = t))
out > elimView of  G
out > v = Var 2 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  s
out > v = Var 1 []
out > elimView (projections reduced) of  s
out > { coerceSize
out > { compareType
out > compareType (Env G → U) =< (Env G → U)
out >    sorts: Set  and  Set
out > compareTerm (Env G → U) =< (Env G → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  t
out > v = Var 0 []
out > elimView (projections reduced) of  t
out > { coerceSize
out > { compareType
out > compareType (Env (snoc G s) → U) =< (Env (snoc G s) → U)
out >    sorts: Set  and  Set
out > compareTerm (Env (snoc G s) → U) =< (Env (snoc G s) → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > elimView of  λ v → _B_34 (G = G) (s = s) (t = t) v
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 34) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])
out > elimView (projections reduced) of  λ v →
out >                                      _B_34 (G = G) (s = s) (t = t) v
out > elimView of  (_B_34 (G = G) (s = s) (t = t) v)
out > v = MetaV (MetaId 34) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  (_B_34 (G = G) (s = s) (t = t)
out >                                     v)
out > elimView of  G
out > v = Var 3 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  s
out > v = Var 2 []
out > elimView (projections reduced) of  s
out > { coerceSize
out > { compareType
out > compareType (Env G → U) =< (Env G → U)
out >    sorts: Set  and  Set
out > compareTerm (Env G → U) =< (Env G → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  t
out > v = Var 1 []
out > elimView (projections reduced) of  t
out > { coerceSize
out > { compareType
out > compareType (Env (snoc G s) → U) =< (Env (snoc G s) → U)
out >    sorts: Set  and  Set
out > compareTerm (Env (snoc G s) → U) =< (Env (snoc G s) → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  v
out > v = Var 0 []
out > elimView (projections reduced) of  v
out > { coerceSize
out > { compareType
out > compareType (_A_33 (G = G) (s = s) (t = t)) =<
out >             (_A_33 (G = G) (s = s) (t = t))
out >    sorts: Set  and  Set
out > compareTerm
out >   (_A_33 (G = G) (s = s) (t = t)) =< (_A_33 (G = G) (s = s) (t = t))
out >   
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > leqSort Set =< (_27 (G = G) (s = s) (t = t))
out > }
out > solving _28 := λ G s t →
out >                  Σ (_A_33 (G = G) (s = s) (t = t))
out >                  (λ v → _B_34 (G = G) (s = s) (t = t) v)
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Σ
out >             (_33 @3 @2 @1) (λ v -> _34 @4 @3 @2 @0)
out > equalSort
out >   _27 == Set
out >   _27 @3 @2 @1 == Set
out > term _27 :DirEq Set
out > term _27 :DirEq Set
out > is _27 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _27
out >   _27 := Set  is a sort
out > solving _27 := λ G s t → Set
out > }
out > }
out > problem 46 was solved!
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] Set =< Set
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [47]
out > coerce term      v  = fst g₁
out >        from type t1 = _A_33
out >        to type   t2 = Env G
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType _A_33 =< Env G
out >    sorts: Set  and  Set
out > compareTerm _A_33 =< Env G 
out > compareTerm (not syntactically equal) _A_33 =< Env G 
out > attempting shortcut _A_33 := Env G
out > term _A_33 :DirLeq Env G
out > term _A_33 :DirLeq Env G
out > is _33 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_33
out >   _A_33  :  Set := Env G
out > elimView of  Env G
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []})]
out > elimView (projections reduced) of  Env G
out > elimView of  G
out > v = Var 2 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_33 := λ G s t → Env G
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Env @3
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 47 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [48]
out > coerce term      v  = λ g → s (fst g)
out >        from type t1 = (g
out >                        : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >                       U
out >        to type   t2 = _A_26
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (g
out >              : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >             U =<
out >             _A_26
out >    sorts: Set  and  Set
out > compareTerm
out >   (g : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >   U =< _A_26
out >   
out > compareTerm (not syntactically equal)
out >   (g : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >   U =< _A_26
out >   
out > attempting shortcut
out >   _A_26 := (g : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >            U
out > term _A_26 :DirGeq (g
out >                     : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >                    U
out > term _A_26 :DirGeq (g
out >                     : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >                    U
out > is _26 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_26
out >   _A_26  :  Set := (g
out >                     : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >                    U
out > elimView of  (g
out >               : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >              U
out > v = Pi (Dom {domInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, domFinite = False, domName = Just (WithOrigin {woOrigin = Inserted, woThing = Ranged {rangeOf = CompileTimeInlining-minimized.agda:33,31-32, rangedThing = "g"}}), domTactic = Nothing, unDom = El {_getSort = Type (Max []), unEl = Def CompileTimeInlining-minimized.Σ [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []})]}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 34) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])})]}}) (Abs "g" El {_getSort = Type (Max []), unEl = Def CompileTimeInlining-minimized.U []})
out > elimView (projections reduced) of  (g
out >                                     : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >                                    U
out > elimView of  Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)
out > v = Def CompileTimeInlining-minimized.Σ [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []})]}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 34) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])})]
out > elimView (projections reduced) of  Σ (Env G)
out >                                    (λ v → _B_34 (G = G) (s = s) (t = t) v)
out > elimView of  Env G
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []})]
out > elimView (projections reduced) of  Env G
out > elimView of  G
out > v = Var 2 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > elimView of  λ v → _B_34 (G = G) (s = s) (t = t) v
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 34) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])
out > elimView (projections reduced) of  λ v →
out >                                      _B_34 (G = G) (s = s) (t = t) v
out > elimView of  _B_34 (G = G) (s = s) (t = t) v
out > v = MetaV (MetaId 34) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  _B_34 (G = G) (s = s) (t = t) v
out > elimView of  G
out > v = Var 3 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  s
out > v = Var 2 []
out > elimView (projections reduced) of  s
out > { coerceSize
out > { compareType
out > compareType Env G → U =< Env G → U
out >    sorts: Set  and  Set
out > compareTerm Env G → U =< Env G → U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  t
out > v = Var 1 []
out > elimView (projections reduced) of  t
out > { coerceSize
out > { compareType
out > compareType Env (snoc G s) → U =< Env (snoc G s) → U
out >    sorts: Set  and  Set
out > compareTerm Env (snoc G s) → U =< Env (snoc G s) → U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  v
out > v = Var 0 []
out > elimView (projections reduced) of  v
out > { coerceSize
out > { compareType
out > compareType Env G =< Env G
out >    sorts: Set  and  Set
out > compareTerm Env G =< Env G 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > elimView of  U
out > v = Def CompileTimeInlining-minimized.U []
out > elimView (projections reduced) of  U
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_26 := λ G s t →
out >                    (g : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) → U
out > shortcut successful
out >   result: (g : CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env @2) (λ v -> _34 @3 @2 @1 @0)) ->
out >             CompileTimeInlining-minimized.U
out > equalSort
out >   Set == Set
out >   piSort (_ : CompileTimeInlining-minimized.Σ
out >                 (_33 @2 @1 @0) (λ v -> _34 @3 @2 @1 @0)) (λ _ -> Set) ==
out >   Set
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 48 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [49]
out > coerce term      v  = t
out >        from type t1 = (Env (snoc G s) → U)
out >        to type   t2 = ((g
out >                         : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >                        U)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Env (snoc G s) → U) =<
out >             ((g : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) → U)
out >    sorts: Set  and  Set
out > compareTerm
out >   (Env (snoc G s) → U) =< ((g
out >                             : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >                            U)
out >   
out > compareTerm (not syntactically equal)
out >   (Env (snoc G s) → U) =< ((g
out >                             : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) →
out >                            U)
out >   
out > { compareAtom
out > compareAtom (Env (snoc G s) → U) =<
out >             ((g : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) → U) 
out > compareAtom (Env (snoc G s) → U) =<
out >             ((g : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) → U) 
out > { compare function types
out >   t1 = (Env (snoc G s) → U)
out >   t2 = ((g : Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v)) → U)
out > { working on problems [50]
out > { compareType
out > compareType Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v) =<
out >             Env (snoc G s)
out >    sorts: Set  and  Set
out > compareTerm
out >   Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v) =< Env (snoc G s)
out >   
out > compareTerm (not syntactically equal)
out >   Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v) =< Env (snoc G s)
out >   
out > { compareAtom
out > compareAtom Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v) =<
out >             Env (snoc G s) 
out > compareAtom Σ (Env G) (λ v → _B_34 (G = G) (s = s) (t = t) v) =<
out >             Σ (Env G) (λ g → El (s g)) 
out > compareElims
out >   a     = ((A : Set) (B : A → Set) → Set)
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env G, $ λ v → _B_34 (G = G) (s = s) (t = t) v]
out >   els02 = [$ Env G, $ λ g → El (s g)]
out > { compare Apply
out >   a    = ((A : Set) (B : A → Set) → Set)
out >   v    = Σ
out >   arg1 = Env G
out >   arg2 = Env G
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env @2
out >   arg2 = CompileTimeInlining-minimized.Env @2
out > { working on problems [51]
out > compareTerm Env G = Env G : Set
out > problem 51 was solved!
out > }
out > compareElims
out >   a     = ((B : Env G → Set) → Set)
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env G)
out >   els01 = [$ λ v → _B_34 (G = G) (s = s) (t = t) v]
out >   els02 = [$ λ g → El (s g)]
out > { compare Apply
out >   a    = ((B : Env G → Set) → Set)
out >   v    = Σ (Env G)
out >   arg1 = λ v → _B_34 (G = G) (s = s) (t = t) v
out >   arg2 = λ g → El (s g)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env @2 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env @2)
out >   arg1 = λ v -> _34 @3 @2 @1 @0
out >   arg2 = λ g -> CompileTimeInlining-minimized.El (@2 @0)
out > { working on problems [52]
out > compareTerm
out >   λ v → _B_34 (G = G) (s = s) (t = t) v =< λ g → El (s g)
out >   : Env G → Set
out > compareTerm (not syntactically equal)
out >   λ v → _B_34 (G = G) (s = s) (t = t) v =< λ g → El (s g)
out >   : Env G → Set
out > { compareTerm
out > compareTerm λ v → _B_34 (G = G) (s = s) (t = t) v =< λ g → El (s g)
out > : (Env G → Set)
out > compareTerm _B_34 (G = G) (s = s) (t = t) v =< El (s v) : Set
out > compareTerm (not syntactically equal)
out >   _B_34 (G = G) (s = s) (t = t) v =< El (s v)
out >   : Set
out > attempting shortcut _B_34 (G = G) (s = s) (t = t) v := El (s v)
out > term _B_34 (G = G) (s = s) (t = t) v :DirLeq El (s v)
out > term _B_34 (G = G) (s = s) (t = t) v :DirLeq El (s v)
out > is _34 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _B_34
out >   _B_34  :  Set := El (s x)
out > elimView of  El (s x)
out > v = Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})]
out > elimView (projections reduced) of  El (s x)
out > elimView of  s x
out > v = Var 2 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  s x
out > elimView of  x
out > v = Var 0 []
out > elimView (projections reduced) of  x
out > { coerceSize
out > { compareType
out > compareType Env G =< Env G
out >    sorts: Set  and  Set
out > compareTerm Env G =< Env G 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _B_34 := λ G s t z → El (s z)
out > shortcut successful
out >   result: CompileTimeInlining-minimized.El (@2 @0)
out > }
out > problem 52 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 50 was solved!
out > }
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 49 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [53]
out > coerce term      v  = (λ g → s (fst g)) ≡ t
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 53 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new sort meta _35 : (G₁ : Ctxt) (s₁ : Env G₁ → U)
out >                     (t₁ : Env (snoc G₁ s₁) → U) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [54]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 54 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [55]
out > coerce term      v  = Env G
out >        from type t1 = Set
out >        to type   t2 = _35
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _35
out >    sorts: Set₁  and  univSort _35
out > compareTerm Set =< _35 
out > compareTerm (not syntactically equal) Set =< _35 
out > { compareAtom
out > compareAtom Set =< _35 
out > compareAtom Set =< _35 
out > equalSort
out >   Set == _35
out >   Set == _35 @2 @1 @0
out > term _35 :DirEq Set
out > term _35 :DirEq Set
out > is _35 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _35
out >   _35 := Set  is a sort
out > solving _35 := (λ G s t → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 55 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new sort meta _36 : (G₁ : Ctxt) (s₁ : Env G₁ → U)
out >                     (t₁ : Env (snoc G₁ s₁) → U) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [56]
out > coerce term      v  = U
out >        from type t1 = Set
out >        to type   t2 = _36
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _36
out >    sorts: Set₁  and  univSort _36
out > compareTerm Set =< _36 
out > compareTerm (not syntactically equal) Set =< _36 
out > { compareAtom
out > compareAtom Set =< _36 
out > compareAtom Set =< _36 
out > equalSort
out >   Set == _36
out >   Set == _36 @2 @1 @0
out > term _36 :DirEq Set
out > term _36 :DirEq Set
out > is _36 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _36
out >   _36 := Set  is a sort
out > solving _36 := λ G s t → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 56 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [57]
out > coerce term      v  = Env G → U
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 57 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [58]
out > problem 58 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [G, s, t, u] |-
out >   _37 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (t₁ : Env (snoc G₁ s₁) → U)
out >         (u₁ : Env G₁ → U) →
out >         Set
out > new sort meta _38 : (G₁ : Ctxt) (s₁ : Env G₁ → U)
out >                     (t₁ : Env (snoc G₁ s₁) → U) (u₁ : Env G₁ → U) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > new meta (ConcreteDef): [G, s, t, u] |-
out >   _39 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (t₁ : Env (snoc G₁ s₁) → U)
out >         (u₁ : Env G₁ → U) →
out >         _38 (G = G₁) (s = s₁) (t = t₁) (u = u₁)
out > new sort meta _40 : (G₁ : Ctxt) (s₁ : Env G₁ → U)
out >                     (t₁ : Env (snoc G₁ s₁) → U) (u₁ : Env G₁ → U)
out >                     (g : _39 (G = G₁) (s = s₁) (t = t₁) (u = u₁)) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > new meta (ConcreteDef): [G, s, t, u, g₁] |-
out >   _41 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (t₁ : Env (snoc G₁ s₁) → U)
out >         (u₁ : Env G₁ → U) (g : _39 (G = G₁) (s = s₁) (t = t₁) (u = u₁)) →
out >         _40 (G = G₁) (s = s₁) (t = t₁) (u = u₁) (g = g)
out > { working on problems [59]
out > { compareType
out > compareType U =< _41 (G = G) (s = s) (t = t) (u = u) (g = g₁)
out >    sorts: Set  and  _40 (G = G) (s = s) (t = t) (u = u) (g = g₁)
out > compareTerm U =< _41 (G = G) (s = s) (t = t) (u = u) (g = g₁) 
out > compareTerm (not syntactically equal)
out >   U =< _41 (G = G) (s = s) (t = t) (u = u) (g = g₁)
out >   
out > attempting shortcut
out >   _41 (G = G) (s = s) (t = t) (u = u) (g = g₁) := U
out > term _41 (G = G) (s = s) (t = t) (u = u) (g = g₁) :DirGeq U
out > term _41 (G = G) (s = s) (t = t) (u = u) (g = g₁) :DirGeq U
out > is _41 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _41
out >   _41  :  _40 (G = G) (s = s) (t = t) (u = u) (g = g) := U
out > elimView of  U
out > v = Def CompileTimeInlining-minimized.U []
out > elimView (projections reduced) of  U
out > { coerceSize
out > leqSort Set =< _40 (G = G) (s = s) (t = t) (u = u) (g = g)
out > }
out > solving _41 := λ G s t u g → U
out > shortcut successful
out >   result: CompileTimeInlining-minimized.U
out > equalSort
out >   Set == _40 (G = G) (s = s) (t = t) (u = u) (g = g₁)
out >   Set == _40 @4 @3 @2 @1 @0
out > term _40 (G = G) (s = s) (t = t) (u = u) (g = g₁) :DirEq Set
out > term _40 (G = G) (s = s) (t = t) (u = u) (g = g₁) :DirEq Set
out > is _40 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _40
out >   _40 := Set  is a sort
out > solving _40 := λ G s t u g → Set
out > }
out > problem 59 was solved!
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] Set =< Set
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [G, s, t, u, g₁] |-
out >   _42 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (t₁ : Env (snoc G₁ s₁) → U)
out >         (u₁ : Env G₁ → U) (g₂ : _39 (G = G₁) (s = s₁) (t = t₁) (u = u₁)) →
out >         Set
out > new meta (ConcreteDef): [G, s, t, u, g₁] |-
out >   _43 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (t₁ : Env (snoc G₁ s₁) → U)
out >         (u₁ : Env G₁ → U) (g₂ : _39 (G = G₁) (s = s₁) (t = t₁) (u = u₁)) →
out >         _A_42 (G = G₁) (s = s₁) (t = t₁) (u = u₁) (g = g₂) → Set
out > { working on problems [60]
out > coerce term      v  = g₁
out >        from type t1 = _39
out >        to type   t2 = (Σ _A_42 _B_43)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType _39 =< (Σ _A_42 _B_43)
out >    sorts: _38  and  Set
out > compareTerm _39 =< (Σ _A_42 _B_43) 
out > compareTerm (not syntactically equal) _39 =< (Σ _A_42 _B_43) 
out > attempting shortcut _39 := (Σ _A_42 _B_43)
out > term _39 :DirLeq (Σ _A_42 _B_43)
out > term _39 :DirLeq (Σ _A_42 _B_43)
out > is _39 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _39
out >   _39  :  (_38 (G = G) (s = s) (t = t) (u = u)) := (Σ
out >                                                     (_A_44 (G = G) (s = s) (t = t) (u = u))
out >                                                     (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v))
out > elimView of  (Σ (_A_44 (G = G) (s = s) (t = t) (u = u))
out >               (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v))
out > v = Def CompileTimeInlining-minimized.Σ [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 44) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 45) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 4 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])})]
out > elimView (projections reduced) of  (Σ
out >                                     (_A_44 (G = G) (s = s) (t = t) (u = u))
out >                                     (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v))
out > elimView of  (_A_44 (G = G) (s = s) (t = t) (u = u))
out > v = MetaV (MetaId 44) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  (_A_44 (G = G) (s = s) (t = t)
out >                                     (u = u))
out > elimView of  G
out > v = Var 3 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  s
out > v = Var 2 []
out > elimView (projections reduced) of  s
out > { coerceSize
out > { compareType
out > compareType (Env G → U) =< (Env G → U)
out >    sorts: Set  and  Set
out > compareTerm (Env G → U) =< (Env G → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  t
out > v = Var 1 []
out > elimView (projections reduced) of  t
out > { coerceSize
out > { compareType
out > compareType (Env (snoc G s) → U) =< (Env (snoc G s) → U)
out >    sorts: Set  and  Set
out > compareTerm (Env (snoc G s) → U) =< (Env (snoc G s) → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  u
out > v = Var 0 []
out > elimView (projections reduced) of  u
out > { coerceSize
out > { compareType
out > compareType (Env G → U) =< (Env G → U)
out >    sorts: Set  and  Set
out > compareTerm (Env G → U) =< (Env G → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > elimView of  λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 45) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 4 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])
out > elimView (projections reduced) of  λ v →
out >                                      _B_45 (G = G) (s = s) (t = t) (u = u) v
out > elimView of  (_B_45 (G = G) (s = s) (t = t) (u = u) v)
out > v = MetaV (MetaId 45) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 4 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  (_B_45 (G = G) (s = s) (t = t)
out >                                     (u = u) v)
out > elimView of  G
out > v = Var 4 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  s
out > v = Var 3 []
out > elimView (projections reduced) of  s
out > { coerceSize
out > { compareType
out > compareType (Env G → U) =< (Env G → U)
out >    sorts: Set  and  Set
out > compareTerm (Env G → U) =< (Env G → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  t
out > v = Var 2 []
out > elimView (projections reduced) of  t
out > { coerceSize
out > { compareType
out > compareType (Env (snoc G s) → U) =< (Env (snoc G s) → U)
out >    sorts: Set  and  Set
out > compareTerm (Env (snoc G s) → U) =< (Env (snoc G s) → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  u
out > v = Var 1 []
out > elimView (projections reduced) of  u
out > { coerceSize
out > { compareType
out > compareType (Env G → U) =< (Env G → U)
out >    sorts: Set  and  Set
out > compareTerm (Env G → U) =< (Env G → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  v
out > v = Var 0 []
out > elimView (projections reduced) of  v
out > { coerceSize
out > { compareType
out > compareType (_A_44 (G = G) (s = s) (t = t) (u = u)) =<
out >             (_A_44 (G = G) (s = s) (t = t) (u = u))
out >    sorts: Set  and  Set
out > compareTerm
out >   (_A_44 (G = G) (s = s) (t = t) (u = u)) =< (_A_44 (G = G) (s = s)
out >                                               (t = t) (u = u))
out >   
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > leqSort Set =< (_38 (G = G) (s = s) (t = t) (u = u))
out > }
out > solving _39 := λ G s t u →
out >                  Σ (_A_44 (G = G) (s = s) (t = t) (u = u))
out >                  (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Σ
out >             (_44 @4 @3 @2 @1) (λ v -> _45 @5 @4 @3 @2 @0)
out > equalSort
out >   _38 == Set
out >   _38 @4 @3 @2 @1 == Set
out > term _38 :DirEq Set
out > term _38 :DirEq Set
out > is _38 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _38
out >   _38 := Set  is a sort
out > solving _38 := λ G s t u → Set
out > }
out > }
out > problem 60 was solved!
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] Set =< Set
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [61]
out > coerce term      v  = fst g₁
out >        from type t1 = _A_44
out >        to type   t2 = Env G
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType _A_44 =< Env G
out >    sorts: Set  and  Set
out > compareTerm _A_44 =< Env G 
out > compareTerm (not syntactically equal) _A_44 =< Env G 
out > attempting shortcut _A_44 := Env G
out > term _A_44 :DirLeq Env G
out > term _A_44 :DirLeq Env G
out > is _44 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_44
out >   _A_44  :  Set := Env G
out > elimView of  Env G
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []})]
out > elimView (projections reduced) of  Env G
out > elimView of  G
out > v = Var 3 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_44 := λ G s t u → Env G
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Env @4
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 61 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [62]
out > coerce term      v  = λ g → u (fst g)
out >        from type t1 = (g
out >                        : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >                       U
out >        to type   t2 = _A_37
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (g
out >              : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >             U =<
out >             _A_37
out >    sorts: Set  and  Set
out > compareTerm
out >   (g : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >   U =< _A_37
out >   
out > compareTerm (not syntactically equal)
out >   (g : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >   U =< _A_37
out >   
out > attempting shortcut
out >   _A_37 := (g
out >             : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >            U
out > term _A_37 :DirGeq (g
out >                     : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >                    U
out > term _A_37 :DirGeq (g
out >                     : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >                    U
out > is _37 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_37
out >   _A_37  :  Set := (g
out >                     : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >                    U
out > elimView of  (g
out >               : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >              U
out > v = Pi (Dom {domInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, domFinite = False, domName = Just (WithOrigin {woOrigin = Inserted, woThing = Ranged {rangeOf = CompileTimeInlining-minimized.agda:33,79-80, rangedThing = "g"}}), domTactic = Nothing, unDom = El {_getSort = Type (Max []), unEl = Def CompileTimeInlining-minimized.Σ [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []})]}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 45) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 4 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])})]}}) (Abs "g" El {_getSort = Type (Max []), unEl = Def CompileTimeInlining-minimized.U []})
out > elimView (projections reduced) of  (g
out >                                     : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >                                    U
out > elimView of  Σ (Env G)
out >              (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)
out > v = Def CompileTimeInlining-minimized.Σ [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []})]}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 45) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 4 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])})]
out > elimView (projections reduced) of  Σ (Env G)
out >                                    (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)
out > elimView of  Env G
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []})]
out > elimView (projections reduced) of  Env G
out > elimView of  G
out > v = Var 3 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > elimView of  λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 45) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 4 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])
out > elimView (projections reduced) of  λ v →
out >                                      _B_45 (G = G) (s = s) (t = t) (u = u) v
out > elimView of  _B_45 (G = G) (s = s) (t = t) (u = u) v
out > v = MetaV (MetaId 45) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 4 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 1 []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  _B_45 (G = G) (s = s) (t = t)
out >                                    (u = u) v
out > elimView of  G
out > v = Var 4 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  s
out > v = Var 3 []
out > elimView (projections reduced) of  s
out > { coerceSize
out > { compareType
out > compareType Env G → U =< Env G → U
out >    sorts: Set  and  Set
out > compareTerm Env G → U =< Env G → U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  t
out > v = Var 2 []
out > elimView (projections reduced) of  t
out > { coerceSize
out > { compareType
out > compareType Env (snoc G s) → U =< Env (snoc G s) → U
out >    sorts: Set  and  Set
out > compareTerm Env (snoc G s) → U =< Env (snoc G s) → U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  u
out > v = Var 1 []
out > elimView (projections reduced) of  u
out > { coerceSize
out > { compareType
out > compareType Env G → U =< Env G → U
out >    sorts: Set  and  Set
out > compareTerm Env G → U =< Env G → U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  v
out > v = Var 0 []
out > elimView (projections reduced) of  v
out > { coerceSize
out > { compareType
out > compareType Env G =< Env G
out >    sorts: Set  and  Set
out > compareTerm Env G =< Env G 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > elimView of  U
out > v = Def CompileTimeInlining-minimized.U []
out > elimView (projections reduced) of  U
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_37 := λ G s t u →
out >                    (g : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) → U
out > shortcut successful
out >   result: (g : CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env @3)
out >                  (λ v -> _45 @4 @3 @2 @1 @0)) ->
out >             CompileTimeInlining-minimized.U
out > equalSort
out >   Set == Set
out >   piSort (_ : CompileTimeInlining-minimized.Σ
out >                 (_44 @3 @2 @1 @0) (λ v -> _45 @4 @3 @2 @1 @0)) (λ _ -> Set) ==
out >   Set
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 62 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [63]
out > coerce term      v  = t
out >        from type t1 = (Env (snoc G s) → U)
out >        to type   t2 = ((g
out >                         : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >                        U)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Env (snoc G s) → U) =<
out >             ((g : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >              U)
out >    sorts: Set  and  Set
out > compareTerm
out >   (Env (snoc G s) → U) =< ((g
out >                             : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >                            U)
out >   
out > compareTerm (not syntactically equal)
out >   (Env (snoc G s) → U) =< ((g
out >                             : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >                            U)
out >   
out > { compareAtom
out > compareAtom (Env (snoc G s) → U) =<
out >             ((g : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >              U)
out >             
out > compareAtom (Env (snoc G s) → U) =<
out >             ((g : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >              U)
out >             
out > { compare function types
out >   t1 = (Env (snoc G s) → U)
out >   t2 = ((g
out >          : Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v)) →
out >         U)
out > { working on problems [64]
out > { compareType
out > compareType Σ (Env G)
out >             (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v) =<
out >             Env (snoc G s)
out >    sorts: Set  and  Set
out > compareTerm
out >   Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v) =< Env
out >                                                                (snoc G s)
out >   
out > compareTerm (not syntactically equal)
out >   Σ (Env G) (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v) =< Env
out >                                                                (snoc G s)
out >   
out > { compareAtom
out > compareAtom Σ (Env G)
out >             (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v) =<
out >             Env (snoc G s) 
out > compareAtom Σ (Env G)
out >             (λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v) =<
out >             Σ (Env G) (λ g → El (s g)) 
out > compareElims
out >   a     = ((A : Set) (B : A → Set) → Set)
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env G, $ λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v]
out >   els02 = [$ Env G, $ λ g → El (s g)]
out > { compare Apply
out >   a    = ((A : Set) (B : A → Set) → Set)
out >   v    = Σ
out >   arg1 = Env G
out >   arg2 = Env G
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env @3
out >   arg2 = CompileTimeInlining-minimized.Env @3
out > { working on problems [65]
out > compareTerm Env G = Env G : Set
out > problem 65 was solved!
out > }
out > compareElims
out >   a     = ((B : Env G → Set) → Set)
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env G)
out >   els01 = [$ λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v]
out >   els02 = [$ λ g → El (s g)]
out > { compare Apply
out >   a    = ((B : Env G → Set) → Set)
out >   v    = Σ (Env G)
out >   arg1 = λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v
out >   arg2 = λ g → El (s g)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env @3 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env @3)
out >   arg1 = λ v -> _45 @4 @3 @2 @1 @0
out >   arg2 = λ g -> CompileTimeInlining-minimized.El (@3 @0)
out > { working on problems [66]
out > compareTerm
out >   λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v =< λ g → El (s g)
out >   : Env G → Set
out > compareTerm (not syntactically equal)
out >   λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v =< λ g → El (s g)
out >   : Env G → Set
out > { compareTerm
out > compareTerm λ v → _B_45 (G = G) (s = s) (t = t) (u = u) v =<
out > λ g → El (s g) : (Env G → Set)
out > compareTerm
out >   _B_45 (G = G) (s = s) (t = t) (u = u) v =< El (s v)
out >   : Set
out > compareTerm (not syntactically equal)
out >   _B_45 (G = G) (s = s) (t = t) (u = u) v =< El (s v)
out >   : Set
out > attempting shortcut
out >   _B_45 (G = G) (s = s) (t = t) (u = u) v := El (s v)
out > term _B_45 (G = G) (s = s) (t = t) (u = u) v :DirLeq El (s v)
out > term _B_45 (G = G) (s = s) (t = t) (u = u) v :DirLeq El (s v)
out > is _45 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _B_45
out >   _B_45  :  Set := El (s x)
out > elimView of  El (s x)
out > v = Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})]
out > elimView (projections reduced) of  El (s x)
out > elimView of  s x
out > v = Var 3 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  s x
out > elimView of  x
out > v = Var 0 []
out > elimView (projections reduced) of  x
out > { coerceSize
out > { compareType
out > compareType Env G =< Env G
out >    sorts: Set  and  Set
out > compareTerm Env G =< Env G 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _B_45 := λ G s t u z → El (s z)
out > shortcut successful
out >   result: CompileTimeInlining-minimized.El (@3 @0)
out > }
out > problem 66 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 64 was solved!
out > }
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 63 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [67]
out > coerce term      v  = (λ g → u (fst g)) ≡ t
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 67 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [68]
out > problem 68 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [69]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 69 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [70]
out > coerce term      v  = u
out >        from type t1 = (Env G → U)
out >        to type   t2 = (Env G → U)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Env G → U) =< (Env G → U)
out >    sorts: Set  and  Set
out > compareTerm (Env G → U) =< (Env G → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 70 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [71]
out > coerce term      v  = Var G u
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 71 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [72]
out > coerce term      v  = Σ ((λ g → u (fst g)) ≡ t) (λ _ → Var G u)
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 72 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [73]
out > coerce term      v  = Σ (Env G → U)
out >                       (λ u → Σ ((λ g → u (fst g)) ≡ t) (λ _ → Var G u))
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 73 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [74]
out > coerce term      v  = Either ((λ g → s (fst g)) ≡ t)
out >                       (Σ (Env G → U) (λ u → Σ ((λ g → u (fst g)) ≡ t) (λ _ → Var G u)))
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set₁  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 74 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 2 remaining.
out > { working on problems []
out > { solving constraint
out > [] Set = Set
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] Set = Set
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _46 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [75]
out > coerce term      v  = Ctxt
out >        from type t1 = Set
out >        to type   t2 = _46
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _46
out >    sorts: Set₁  and  univSort _46
out > compareTerm Set =< _46 
out > compareTerm (not syntactically equal) Set =< _46 
out > { compareAtom
out > compareAtom Set =< _46 
out > compareAtom Set =< _46 
out > equalSort
out >   Set == _46
out >   Set == _46
out > term _46 :DirEq Set
out > term _46 :DirEq Set
out > is _46 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _46
out >   _46 := Set  is a sort
out > solving _46 := Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 75 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _47 : (G : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [76]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 76 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [77]
out > coerce term      v  = Env G
out >        from type t1 = Set
out >        to type   t2 = _47
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _47
out >    sorts: Set₁  and  univSort _47
out > compareTerm Set =< _47 
out > compareTerm (not syntactically equal) Set =< _47 
out > { compareAtom
out > compareAtom Set =< _47 
out > compareAtom Set =< _47 
out > equalSort
out >   Set == _47
out >   Set == _47 @0
out > term _47 :DirEq Set
out > term _47 :DirEq Set
out > is _47 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _47
out >   _47 := Set  is a sort
out > solving _47 := (λ G → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 77 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _48 : (G₁ : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [78]
out > coerce term      v  = U
out >        from type t1 = Set
out >        to type   t2 = _48
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _48
out >    sorts: Set₁  and  univSort _48
out > compareTerm Set =< _48 
out > compareTerm (not syntactically equal) Set =< _48 
out > { compareAtom
out > compareAtom Set =< _48 
out > compareAtom Set =< _48 
out > equalSort
out >   Set == _48
out >   Set == _48 @0
out > term _48 :DirEq Set
out > term _48 :DirEq Set
out > is _48 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _48
out >   _48 := Set  is a sort
out > solving _48 := λ G → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 78 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _49 : (G₁ : Ctxt) (s : Env G₁ → U) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [79]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 79 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [80]
out > coerce term      v  = s
out >        from type t1 = (Env G → U)
out >        to type   t2 = (Env G → U)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Env G → U) =< (Env G → U)
out >    sorts: Set  and  Set
out > compareTerm (Env G → U) =< (Env G → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 80 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [81]
out > coerce term      v  = Var G s
out >        from type t1 = Set
out >        to type   t2 = _49
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _49
out >    sorts: Set₁  and  univSort _49
out > compareTerm Set =< _49 
out > compareTerm (not syntactically equal) Set =< _49 
out > { compareAtom
out > compareAtom Set =< _49 
out > compareAtom Set =< _49 
out > equalSort
out >   Set == _49
out >   Set == _49 @1 @0
out > term _49 :DirEq Set
out > term _49 :DirEq Set
out > is _49 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _49
out >   _49 := Set  is a sort
out > solving _49 := (λ G s → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 81 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _50 : (G₁ : Ctxt) (s₁ : Env G₁ → U) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [82]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 82 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [83]
out > coerce term      v  = Env G
out >        from type t1 = Set
out >        to type   t2 = _50
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _50
out >    sorts: Set₁  and  univSort _50
out > compareTerm Set =< _50 
out > compareTerm (not syntactically equal) Set =< _50 
out > { compareAtom
out > compareAtom Set =< _50 
out > compareAtom Set =< _50 
out > equalSort
out >   Set == _50
out >   Set == _50 @1 @0
out > term _50 :DirEq Set
out > term _50 :DirEq Set
out > is _50 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _50
out >   _50 := Set  is a sort
out > solving _50 := λ G s → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 83 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _51 : (G₁ : Ctxt) (s₁ : Env G₁ → U) (g : Env G₁) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [84]
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 84 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [85]
out > coerce term      v  = g
out >        from type t1 = (Env G)
out >        to type   t2 = (Env G)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Env G) =< (Env G)
out >    sorts: Set  and  Set
out > compareTerm (Env G) =< (Env G) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 85 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [86]
out > coerce term      v  = El (s g)
out >        from type t1 = Set
out >        to type   t2 = _51
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _51
out >    sorts: Set₁  and  univSort _51
out > compareTerm Set =< _51 
out > compareTerm (not syntactically equal) Set =< _51 
out > { compareAtom
out > compareAtom Set =< _51 
out > compareAtom Set =< _51 
out > equalSort
out >   Set == _51
out >   Set == _51 @2 @1 @0
out > term _51 :DirEq Set
out > term _51 :DirEq Set
out > is _51 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _51
out >   _51 := Set  is a sort
out > solving _51 := λ G s g → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 86 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > { working on problems [87]
out > problem 87 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [88]
out > problem 88 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [89]
out > problem 89 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [90]
out > problem 90 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [91]
out > problem 91 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [92]
out > { compareType
out > compareType (g : Σ (Env vs) (λ v → El (v₁ v))) → U =
out >             Env (snoc vs v₁) → U
out >    sorts: Set  and  Set
out > compareTerm
out >   (g : Σ (Env vs) (λ v → El (v₁ v))) → U = Env (snoc vs v₁) → U
out >   
out > compareTerm (not syntactically equal)
out >   (g : Σ (Env vs) (λ v → El (v₁ v))) → U = Env (snoc vs v₁) → U
out >   
out > { compareAtom
out > compareAtom (g : Σ (Env vs) (λ v → El (v₁ v))) → U =
out >             Env (snoc vs v₁) → U 
out > compareAtom (g : Σ (Env vs) (λ v → El (v₁ v))) → U =
out >             Env (snoc vs v₁) → U 
out > { compare function types
out >   t1 = (g : Σ (Env vs) (λ v → El (v₁ v))) → U
out >   t2 = Env (snoc vs v₁) → U
out > { working on problems [93]
out > { compareType
out > compareType Env (snoc vs v₁) = Σ (Env vs) (λ v → El (v₁ v))
out >    sorts: Set  and  Set
out > compareTerm Env (snoc vs v₁) = Σ (Env vs) (λ v → El (v₁ v)) 
out > compareTerm (not syntactically equal)
out >   Env (snoc vs v₁) = Σ (Env vs) (λ v → El (v₁ v))
out >   
out > { compareAtom
out > compareAtom Env (snoc vs v₁) = Σ (Env vs) (λ v → El (v₁ v)) 
out > compareAtom Σ (Env vs) (λ g → El (v₁ g)) =
out >             Σ (Env vs) (λ v → El (v₁ v)) 
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env vs, $ λ g → El (v₁ g)]
out >   els02 = [$ Env vs, $ λ v → El (v₁ v)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env vs
out >   arg2 = Env vs
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env @2
out >   arg2 = CompileTimeInlining-minimized.Env @2
out > { working on problems [94]
out > compareTerm Env vs = Env vs : Set
out > problem 94 was solved!
out > }
out > compareElims
out >   a     = (B : Env vs → Set) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env vs)
out >   els01 = [$ λ g → El (v₁ g)]
out >   els02 = [$ λ v → El (v₁ v)]
out > { compare Apply
out >   a    = (B : Env vs → Set) → Set
out >   v    = Σ (Env vs)
out >   arg1 = λ g → El (v₁ g)
out >   arg2 = λ v → El (v₁ v)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env @2 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env @2)
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (@2 @0)
out >   arg2 = λ v -> CompileTimeInlining-minimized.El (@2 @0)
out > { working on problems [95]
out > compareTerm λ g → El (v₁ g) = λ v → El (v₁ v) : Env vs → Set
out > problem 95 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 93 was solved!
out > }
out > { compareType
out > compareType U = U
out >    sorts: Set  and  Set
out > compareTerm U = U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 92 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [96]
out > problem 96 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [vs, v, g] |-
out >   _52 : (vs₁ : Ctxt) (v₁ : Env vs₁ → U) (g₁ : Env (snoc vs₁ v₁)) →
out >         Set
out > new meta (ConcreteDef): [vs, v, g] |-
out >   _53 : (vs₁ : Ctxt) (v₁ : Env vs₁ → U) (g₁ : Env (snoc vs₁ v₁)) →
out >         _A_52 (vs = vs₁) (v = v₁) (g = g₁) → Set
out > { working on problems [97]
out > coerce term      v  = g
out >        from type t1 = (Σ (Env vs) (λ g₁ → El (v g₁)))
out >        to type   t2 = (Σ _A_52 _B_53)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Σ (Env vs) (λ g₁ → El (v g₁))) =< (Σ _A_52 _B_53)
out >    sorts: Set  and  Set
out > compareTerm (Σ (Env vs) (λ g₁ → El (v g₁))) =< (Σ _A_52 _B_53) 
out > compareTerm (not syntactically equal)
out >   (Σ (Env vs) (λ g₁ → El (v g₁))) =< (Σ _A_52 _B_53)
out >   
out > { compareAtom
out > compareAtom (Σ (Env vs) (λ g₁ → El (v g₁))) =< (Σ _A_52 _B_53) 
out > compareAtom (Σ (Env vs) (λ g₁ → El (v g₁))) =< (Σ _A_52 _B_53) 
out > compareElims
out >   a     = ((A : Set) (B : A → Set) → Set)
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ (Env vs), $ λ g₁ → El (v g₁)]
out >   els02 = [$ _A_52, $ _B_53]
out > { compare Apply
out >   a    = ((A : Set) (B : A → Set) → Set)
out >   v    = Σ
out >   arg1 = (Env vs)
out >   arg2 = _A_52
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env @2
out >   arg2 = _52 @2 @1 @0
out > { working on problems [98]
out > compareTerm (Env vs) = _A_52 : Set
out > compareTerm (not syntactically equal) (Env vs) = _A_52 : Set
out > attempting shortcut _A_52 := (Env vs)
out > term _A_52 :DirEq (Env vs)
out > term _A_52 :DirEq (Env vs)
out > is _52 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_52
out >   _A_52  :  Set := (Env vs)
out > elimView of  (Env vs)
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 []})]
out > elimView (projections reduced) of  (Env vs)
out > elimView of  vs
out > v = Var 2 []
out > elimView (projections reduced) of  vs
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_52 := λ vs v g → Env vs
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Env @2
out > problem 98 was solved!
out > }
out > compareElims
out >   a     = ((B : Env vs → Set) → Set)
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = (Σ (Env vs))
out >   els01 = [$ λ g₁ → El (v g₁)]
out >   els02 = [$ _B_53]
out > { compare Apply
out >   a    = ((B : Env vs → Set) → Set)
out >   v    = (Σ (Env vs))
out >   arg1 = λ g₁ → El (v g₁)
out >   arg2 = _B_53
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env @2 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env @2)
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (@2 @0)
out >   arg2 = _53 @2 @1 @0
out > { working on problems [99]
out > compareTerm λ g₁ → El (v g₁) =< _B_53 : Env vs → Set
out > compareTerm (not syntactically equal)
out >   λ g₁ → El (v g₁) =< _B_53
out >   : Env vs → Set
out > attempting shortcut _B_53 := λ g₁ → El (v g₁)
out > term _B_53 :DirGeq λ g₁ → El (v g₁)
out > term _B_53 :DirGeq λ g₁ → El (v g₁)
out > is _53 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _B_53
out >   _B_53  :  (Env vs → Set) := λ g → El (v g)
out > elimView of  λ g → El (v g)
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "g" Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})])
out > elimView (projections reduced) of  λ g → El (v g)
out > elimView of  (El (v g))
out > v = Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 2 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})]
out > elimView (projections reduced) of  (El (v g))
out > elimView of  (v g)
out > v = Var 2 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  (v g)
out > elimView of  g
out > v = Var 0 []
out > elimView (projections reduced) of  g
out > { coerceSize
out > { compareType
out > compareType (Env vs) =< (Env vs)
out >    sorts: Set  and  Set
out > compareTerm (Env vs) =< (Env vs) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _B_53 := λ vs v g g₁ → El (v g₁)
out > shortcut successful
out >   result: λ g -> CompileTimeInlining-minimized.El (@2 @0)
out > problem 99 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 97 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [100]
out > coerce term      v  = snd g
out >        from type t1 = El (v (fst g))
out >        to type   t2 = El (v (fst g))
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType El (v (fst g)) =< El (v (fst g))
out >    sorts: Set  and  Set
out > compareTerm El (v (fst g)) =< El (v (fst g)) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 100 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > { working on problems [101]
out > problem 101 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [102]
out > problem 102 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [103]
out > problem 103 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [104]
out > problem 104 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [105]
out > problem 105 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [106]
out > problem 106 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [107]
out > problem 107 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [108]
out > problem 108 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [109]
out > problem 109 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [110]
out > { compareType
out > compareType (g : Σ (Env vs) (λ v → El (v₁ v))) → U =
out >             Env (snoc vs v₁) → U
out >    sorts: Set  and  Set
out > compareTerm
out >   (g : Σ (Env vs) (λ v → El (v₁ v))) → U = Env (snoc vs v₁) → U
out >   
out > compareTerm (not syntactically equal)
out >   (g : Σ (Env vs) (λ v → El (v₁ v))) → U = Env (snoc vs v₁) → U
out >   
out > { compareAtom
out > compareAtom (g : Σ (Env vs) (λ v → El (v₁ v))) → U =
out >             Env (snoc vs v₁) → U 
out > compareAtom (g : Σ (Env vs) (λ v → El (v₁ v))) → U =
out >             Env (snoc vs v₁) → U 
out > { compare function types
out >   t1 = (g : Σ (Env vs) (λ v → El (v₁ v))) → U
out >   t2 = Env (snoc vs v₁) → U
out > { working on problems [111]
out > { compareType
out > compareType Env (snoc vs v₁) = Σ (Env vs) (λ v → El (v₁ v))
out >    sorts: Set  and  Set
out > compareTerm Env (snoc vs v₁) = Σ (Env vs) (λ v → El (v₁ v)) 
out > compareTerm (not syntactically equal)
out >   Env (snoc vs v₁) = Σ (Env vs) (λ v → El (v₁ v))
out >   
out > { compareAtom
out > compareAtom Env (snoc vs v₁) = Σ (Env vs) (λ v → El (v₁ v)) 
out > compareAtom Σ (Env vs) (λ g → El (v₁ g)) =
out >             Σ (Env vs) (λ v → El (v₁ v)) 
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env vs, $ λ g → El (v₁ g)]
out >   els02 = [$ Env vs, $ λ v → El (v₁ v)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env vs
out >   arg2 = Env vs
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env @3
out >   arg2 = CompileTimeInlining-minimized.Env @3
out > { working on problems [112]
out > compareTerm Env vs = Env vs : Set
out > problem 112 was solved!
out > }
out > compareElims
out >   a     = (B : Env vs → Set) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env vs)
out >   els01 = [$ λ g → El (v₁ g)]
out >   els02 = [$ λ v → El (v₁ v)]
out > { compare Apply
out >   a    = (B : Env vs → Set) → Set
out >   v    = Σ (Env vs)
out >   arg1 = λ g → El (v₁ g)
out >   arg2 = λ v → El (v₁ v)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env @3 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env @3)
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (@3 @0)
out >   arg2 = λ v -> CompileTimeInlining-minimized.El (@3 @0)
out > { working on problems [113]
out > compareTerm λ g → El (v₁ g) = λ v → El (v₁ v) : Env vs → Set
out > problem 113 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 111 was solved!
out > }
out > { compareType
out > compareType U = U
out >    sorts: Set  and  Set
out > compareTerm U = U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 110 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [114]
out > problem 114 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [vs, fst₁, v, x, g] |-
out >   _54 : ((vs₁ : Ctxt) (fst₂ v₁ : Env vs₁ → U) (x₁ : Var vs₁ fst₂)
out >          (g₁ : Env (snoc vs₁ v₁)) →
out >          Ctxt)
out > new meta (ConcreteDef): [vs, fst₁, v, x, g] |-
out >   _55 : ((vs₁ : Ctxt) (fst₂ v₁ : Env vs₁ → U) (x₁ : Var vs₁ fst₂)
out >          (g₁ : Env (snoc vs₁ v₁)) →
out >          Env (_G_54 (vs = vs₁) (fst = fst₂) (v = v₁) (x = x₁) (g = g₁)) → U)
out > { working on problems [115]
out > coerce term      v  = x
out >        from type t1 = (Var vs fst₁)
out >        to type   t2 = (Var _G_54 _s_55)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Var vs fst₁) =< (Var _G_54 _s_55)
out >    sorts: Set  and  Set
out > compareTerm (Var vs fst₁) =< (Var _G_54 _s_55) 
out > compareTerm (not syntactically equal)
out >   (Var vs fst₁) =< (Var _G_54 _s_55)
out >   
out > { compareAtom
out > compareAtom (Var vs fst₁) =< (Var _G_54 _s_55) 
out > compareAtom (Var vs fst₁) =< [ (Var _G_54 _s_55) ]_54 
out > compareElims
out >   a     = ((G : Ctxt) → (Env G → U) → Set)
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Var
out >   els01 = [$ vs, $ fst₁]
out >   els02 = [$ _G_54, $ _s_55]
out > { compare Apply
out >   a    = ((G : Ctxt) → (Env G → U) → Set)
out >   v    = Var
out >   arg1 = vs
out >   arg2 = _G_54
out >   raw:
out >   a    = (G : CompileTimeInlining-minimized.Ctxt) ->
out >            (CompileTimeInlining-minimized.Env @0 ->
out >               CompileTimeInlining-minimized.U) ->
out >              Set
out >   v    = CompileTimeInlining-minimized.Var
out >   arg1 = @4
out >   arg2 = _54 @4 @3 @2 @1 @0
out > { working on problems [116]
out > compareTerm vs = _G_54 : Ctxt
out > compareTerm (not syntactically equal) vs = _G_54 : Ctxt
out > attempting shortcut _G_54 := vs
out > term _G_54 :DirEq vs
out > term _G_54 :DirEq vs
out > is _54 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _G_54
out >   _G_54  :  Ctxt := vs
out > elimView of  vs
out > v = Var 4 []
out > elimView (projections reduced) of  vs
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _G_54 := (λ vs fst₁ v x g → vs)
out > shortcut successful
out >   result: @4
out > problem 116 was solved!
out > }
out > compareElims
out >   a     = ((Env vs → U) → Set)
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = (Var vs)
out >   els01 = [$ fst₁]
out >   els02 = [$ _s_55]
out > { compare Apply
out >   a    = ((Env vs → U) → Set)
out >   v    = (Var vs)
out >   arg1 = fst₁
out >   arg2 = _s_55
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Env @4 ->
out >             CompileTimeInlining-minimized.U) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Var @4
out >   arg1 = @3
out >   arg2 = _55 @4 @3 @2 @1 @0
out > { working on problems [117]
out > compareTerm fst₁ =< _s_55 : Env vs → U
out > compareTerm (not syntactically equal) fst₁ =< _s_55 : Env vs → U
out > attempting shortcut _s_55 := fst₁
out > term _s_55 :DirGeq fst₁
out > term _s_55 :DirGeq fst₁
out > is _55 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _s_55
out >   _s_55  :  (Env vs → U) := fst₁
out > elimView of  fst₁
out > v = Var 3 []
out > elimView (projections reduced) of  fst₁
out > { coerceSize
out > { compareType
out > compareType (Env vs → U) =< (Env vs → U)
out >    sorts: Set  and  Set
out > compareTerm (Env vs → U) =< (Env vs → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _s_55 := (λ vs fst₁ v x g → fst₁)
out > shortcut successful
out >   result: @3
out > problem 117 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 115 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [vs, fst₁, v, x, g] |-
out >   _56 : (vs₁ : Ctxt) (fst₂ v₁ : Env vs₁ → U) (x₁ : Var vs₁ fst₂)
out >         (g₁ : Env (snoc vs₁ v₁)) →
out >         Set
out > new meta (ConcreteDef): [vs, fst₁, v, x, g] |-
out >   _57 : (vs₁ : Ctxt) (fst₂ v₁ : Env vs₁ → U) (x₁ : Var vs₁ fst₂)
out >         (g₁ : Env (snoc vs₁ v₁)) →
out >         _A_56 (vs = vs₁) (fst = fst₂) (v = v₁) (x = x₁) (g = g₁) → Set
out > { working on problems [118]
out > coerce term      v  = g
out >        from type t1 = (Σ (Env vs) (λ g₁ → El (v g₁)))
out >        to type   t2 = (Σ _A_56 _B_57)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Σ (Env vs) (λ g₁ → El (v g₁))) =< (Σ _A_56 _B_57)
out >    sorts: Set  and  Set
out > compareTerm (Σ (Env vs) (λ g₁ → El (v g₁))) =< (Σ _A_56 _B_57) 
out > compareTerm (not syntactically equal)
out >   (Σ (Env vs) (λ g₁ → El (v g₁))) =< (Σ _A_56 _B_57)
out >   
out > { compareAtom
out > compareAtom (Σ (Env vs) (λ g₁ → El (v g₁))) =< (Σ _A_56 _B_57) 
out > compareAtom (Σ (Env vs) (λ g₁ → El (v g₁))) =< (Σ _A_56 _B_57) 
out > compareElims
out >   a     = ((A : Set) (B : A → Set) → Set)
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ (Env vs), $ λ g₁ → El (v g₁)]
out >   els02 = [$ _A_56, $ _B_57]
out > { compare Apply
out >   a    = ((A : Set) (B : A → Set) → Set)
out >   v    = Σ
out >   arg1 = (Env vs)
out >   arg2 = _A_56
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env @4
out >   arg2 = _56 @4 @3 @2 @1 @0
out > { working on problems [119]
out > compareTerm (Env vs) = _A_56 : Set
out > compareTerm (not syntactically equal) (Env vs) = _A_56 : Set
out > attempting shortcut _A_56 := (Env vs)
out > term _A_56 :DirEq (Env vs)
out > term _A_56 :DirEq (Env vs)
out > is _56 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_56
out >   _A_56  :  Set := (Env vs)
out > elimView of  (Env vs)
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 4 []})]
out > elimView (projections reduced) of  (Env vs)
out > elimView of  vs
out > v = Var 4 []
out > elimView (projections reduced) of  vs
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_56 := λ vs fst₁ v x g → Env vs
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Env @4
out > problem 119 was solved!
out > }
out > compareElims
out >   a     = ((B : Env vs → Set) → Set)
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = (Σ (Env vs))
out >   els01 = [$ λ g₁ → El (v g₁)]
out >   els02 = [$ _B_57]
out > { compare Apply
out >   a    = ((B : Env vs → Set) → Set)
out >   v    = (Σ (Env vs))
out >   arg1 = λ g₁ → El (v g₁)
out >   arg2 = _B_57
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env @4 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env @4)
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (@3 @0)
out >   arg2 = _57 @4 @3 @2 @1 @0
out > { working on problems [120]
out > compareTerm λ g₁ → El (v g₁) =< _B_57 : Env vs → Set
out > compareTerm (not syntactically equal)
out >   λ g₁ → El (v g₁) =< _B_57
out >   : Env vs → Set
out > attempting shortcut _B_57 := λ g₁ → El (v g₁)
out > term _B_57 :DirGeq λ g₁ → El (v g₁)
out > term _B_57 :DirGeq λ g₁ → El (v g₁)
out > is _57 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _B_57
out >   _B_57  :  (Env vs → Set) := λ g → El (v g)
out > elimView of  λ g → El (v g)
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "g" Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})])
out > elimView (projections reduced) of  λ g → El (v g)
out > elimView of  (El (v g))
out > v = Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})]
out > elimView (projections reduced) of  (El (v g))
out > elimView of  (v g)
out > v = Var 3 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  (v g)
out > elimView of  g
out > v = Var 0 []
out > elimView (projections reduced) of  g
out > { coerceSize
out > { compareType
out > compareType (Env vs) =< (Env vs)
out >    sorts: Set  and  Set
out > compareTerm (Env vs) =< (Env vs) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _B_57 := λ vs fst₁ v x g g₁ → El (v g₁)
out > shortcut successful
out >   result: λ g -> CompileTimeInlining-minimized.El (@3 @0)
out > problem 120 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 118 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [121]
out > coerce term      v  = fst g
out >        from type t1 = Env vs
out >        to type   t2 = Env vs
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Env vs =< Env vs
out >    sorts: Set  and  Set
out > compareTerm Env vs =< Env vs 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 121 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [122]
out > coerce term      v  = lookup vs fst₁ x (fst g)
out >        from type t1 = El (fst₁ (fst g))
out >        to type   t2 = El (fst₁ (fst g))
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType El (fst₁ (fst g)) =< El (fst₁ (fst g))
out >    sorts: Set  and  Set
out > compareTerm El (fst₁ (fst g)) =< El (fst₁ (fst g)) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 122 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > { working on problems [123]
out > { compareType
out > compareType (g : Σ (Env G) (λ v → El (x v))) → U =
out >             Env (snoc G x) → U
out >    sorts: Set  and  Set
out > compareTerm
out >   (g : Σ (Env G) (λ v → El (x v))) → U = Env (snoc G x) → U
out >   
out > compareTerm (not syntactically equal)
out >   (g : Σ (Env G) (λ v → El (x v))) → U = Env (snoc G x) → U
out >   
out > { compareAtom
out > compareAtom (g : Σ (Env G) (λ v → El (x v))) → U =
out >             Env (snoc G x) → U 
out > compareAtom (g : Σ (Env G) (λ v → El (x v))) → U =
out >             Env (snoc G x) → U 
out > { compare function types
out >   t1 = (g : Σ (Env G) (λ v → El (x v))) → U
out >   t2 = Env (snoc G x) → U
out > { working on problems [124]
out > { compareType
out > compareType Env (snoc G x) = Σ (Env G) (λ v → El (x v))
out >    sorts: Set  and  Set
out > compareTerm Env (snoc G x) = Σ (Env G) (λ v → El (x v)) 
out > compareTerm (not syntactically equal)
out >   Env (snoc G x) = Σ (Env G) (λ v → El (x v))
out >   
out > { compareAtom
out > compareAtom Env (snoc G x) = Σ (Env G) (λ v → El (x v)) 
out > compareAtom Σ (Env G) (λ g → El (x g)) = Σ (Env G) (λ v → El (x v))
out >             
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env G, $ λ g → El (x g)]
out >   els02 = [$ Env G, $ λ v → El (x v)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env G
out >   arg2 = Env G
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env @2
out >   arg2 = CompileTimeInlining-minimized.Env @2
out > { working on problems [125]
out > compareTerm Env G = Env G : Set
out > problem 125 was solved!
out > }
out > compareElims
out >   a     = (B : Env G → Set) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env G)
out >   els01 = [$ λ g → El (x g)]
out >   els02 = [$ λ v → El (x v)]
out > { compare Apply
out >   a    = (B : Env G → Set) → Set
out >   v    = Σ (Env G)
out >   arg1 = λ g → El (x g)
out >   arg2 = λ v → El (x v)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env @2 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env @2)
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (@2 @0)
out >   arg2 = λ v -> CompileTimeInlining-minimized.El (@2 @0)
out > { working on problems [126]
out > compareTerm λ g → El (x g) = λ v → El (x v) : Env G → Set
out > problem 126 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 124 was solved!
out > }
out > { compareType
out > compareType U = U
out >    sorts: Set  and  Set
out > compareTerm U = U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 123 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [127]
out > { compareType
out > compareType (g : Σ (Env G) (λ v → El (x v))) → U =
out >             Env (snoc G x) → U
out >    sorts: Set  and  Set
out > compareTerm
out >   (g : Σ (Env G) (λ v → El (x v))) → U = Env (snoc G x) → U
out >   
out > compareTerm (not syntactically equal)
out >   (g : Σ (Env G) (λ v → El (x v))) → U = Env (snoc G x) → U
out >   
out > { compareAtom
out > compareAtom (g : Σ (Env G) (λ v → El (x v))) → U =
out >             Env (snoc G x) → U 
out > compareAtom (g : Σ (Env G) (λ v → El (x v))) → U =
out >             Env (snoc G x) → U 
out > { compare function types
out >   t1 = (g : Σ (Env G) (λ v → El (x v))) → U
out >   t2 = Env (snoc G x) → U
out > { working on problems [128]
out > { compareType
out > compareType Env (snoc G x) = Σ (Env G) (λ v → El (x v))
out >    sorts: Set  and  Set
out > compareTerm Env (snoc G x) = Σ (Env G) (λ v → El (x v)) 
out > compareTerm (not syntactically equal)
out >   Env (snoc G x) = Σ (Env G) (λ v → El (x v))
out >   
out > { compareAtom
out > compareAtom Env (snoc G x) = Σ (Env G) (λ v → El (x v)) 
out > compareAtom Σ (Env G) (λ g → El (x g)) = Σ (Env G) (λ v → El (x v))
out >             
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env G, $ λ g → El (x g)]
out >   els02 = [$ Env G, $ λ v → El (x v)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env G
out >   arg2 = Env G
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env @3
out >   arg2 = CompileTimeInlining-minimized.Env @3
out > { working on problems [129]
out > compareTerm Env G = Env G : Set
out > problem 129 was solved!
out > }
out > compareElims
out >   a     = (B : Env G → Set) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env G)
out >   els01 = [$ λ g → El (x g)]
out >   els02 = [$ λ v → El (x v)]
out > { compare Apply
out >   a    = (B : Env G → Set) → Set
out >   v    = Σ (Env G)
out >   arg1 = λ g → El (x g)
out >   arg2 = λ v → El (x v)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env @3 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env @3)
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (@3 @0)
out >   arg2 = λ v -> CompileTimeInlining-minimized.El (@3 @0)
out > { working on problems [130]
out > compareTerm λ g → El (x g) = λ v → El (x v) : Env G → Set
out > problem 130 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 128 was solved!
out > }
out > { compareType
out > compareType U = U
out >    sorts: Set  and  Set
out > compareTerm U = U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 127 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _58 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > new meta (ConcreteDef): [] |- _59 : _58
out > { working on problems [131]
out > { compareType
out > compareType Ctxt =< _59
out >    sorts: Set  and  _58
out > compareTerm Ctxt =< _59 
out > compareTerm (not syntactically equal) Ctxt =< _59 
out > attempting shortcut _59 := Ctxt
out > term _59 :DirGeq Ctxt
out > term _59 :DirGeq Ctxt
out > is _59 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _59
out >   _59  :  _58 := Ctxt
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< _58
out > }
out > solving _59 := Ctxt
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Ctxt
out > equalSort
out >   Set == _58
out >   Set == _58
out > term _58 :DirEq Set
out > term _58 :DirEq Set
out > is _58 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _58
out >   _58 := Set  is a sort
out > solving _58 := Set
out > }
out > problem 131 was solved!
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] Set =< Set
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [132]
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 132 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [] |- _60 : Set
out > { working on problems [133]
out > coerce term      v  = whatever
out >        from type t1 = _A_60
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType _A_60 =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm _A_60 =< Ctxt 
out > compareTerm (not syntactically equal) _A_60 =< Ctxt 
out > attempting shortcut _A_60 := Ctxt
out > term _A_60 :DirLeq Ctxt
out > term _A_60 :DirLeq Ctxt
out > is _60 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_60
out >   _A_60  :  Set := Ctxt
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_60 := Ctxt
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Ctxt
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 133 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [134]
out > problem 134 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [135]
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 135 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [136]
out > coerce term      v  = Set
out >        from type t1 = Set₁
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set₁ =< Set
out >    sorts: Set₂  and  Set₁
out > compareTerm Set₁ =< Set 
out > compareTerm (not syntactically equal) Set₁ =< Set 
out > { compareAtom
out > compareAtom Set₁ =< Set 
out > compareAtom Set₁ =< Set 
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) == Agda.Primitive.lzero
out > reduced
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > }
out > equalSort
out >   Set₂ == Set₁
out >   Set2 == Set1
out > equalLevel (lsuc (lsuc lzero)) (lsuc lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc (Agda.Primitive.lsuc Agda.Primitive.lzero)) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > reduced
out >   (Agda.Primitive.lsuc (Agda.Primitive.lsuc Agda.Primitive.lzero)) ==
out >   Agda.Primitive.lzero
out > equalLevel lsuc (lsuc lzero) == lzero
out > }
out > }
out > problem 136 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [137]
out > problem 137 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [138]
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 138 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [g] |-
out >   _61 : (g₁ : Env (snoc whatever (λ _ → el Set))) → Set
out > new meta (ConcreteDef): [g] |-
out >   _62 : (g₁ : Env (snoc whatever (λ _ → el Set))) →
out >         _A_61 (g = g₁) → Set
out > { working on problems [139]
out > coerce term      v  = g
out >        from type t1 = (Σ (Env whatever) (λ g₁ → El (el Set)))
out >        to type   t2 = (Σ _A_61 _B_62)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Σ (Env whatever) (λ g₁ → El (el Set))) =<
out >             (Σ _A_61 _B_62)
out >    sorts: Set  and  Set
out > compareTerm
out >   (Σ (Env whatever) (λ g₁ → El (el Set))) =< (Σ _A_61 _B_62)
out >   
out > compareTerm (not syntactically equal)
out >   (Σ (Env whatever) (λ g₁ → El (el Set))) =< (Σ _A_61 _B_62)
out >   
out > { compareAtom
out > compareAtom (Σ (Env whatever) (λ g₁ → El (el Set))) =<
out >             (Σ _A_61 _B_62) 
out > compareAtom (Σ (Env whatever) (λ g₁ → El (el Set))) =<
out >             (Σ _A_61 _B_62) 
out > compareElims
out >   a     = ((A : Set) (B : A → Set) → Set)
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ (Env whatever), $ λ g₁ → El (el Set)]
out >   els02 = [$ _A_61, $ _B_62]
out > { compare Apply
out >   a    = ((A : Set) (B : A → Set) → Set)
out >   v    = Σ
out >   arg1 = (Env whatever)
out >   arg2 = _A_61
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env
out >            (CompileTimeInlining-minimized.whatever {_60})
out >   arg2 = _61 @0
out > { working on problems [140]
out > compareTerm (Env whatever) = _A_61 : Set
out > compareTerm (not syntactically equal) (Env whatever) = _A_61 : Set
out > attempting shortcut _A_61 := (Env whatever)
out > term _A_61 :DirEq (Env whatever)
out > term _A_61 :DirEq (Env whatever)
out > is _61 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_61
out >   _A_61  :  Set := (Env whatever)
out > elimView of  (Env whatever)
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]})]
out > elimView (projections reduced) of  (Env whatever)
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_61 := λ g → Env whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Env
out >             (CompileTimeInlining-minimized.whatever
out >                {CompileTimeInlining-minimized.Ctxt})
out > problem 140 was solved!
out > }
out > compareElims
out >   a     = ((B : Env whatever → Set) → Set)
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = (Σ (Env whatever))
out >   els01 = [$ λ g₁ → El (el Set)]
out >   els02 = [$ _B_62]
out > { compare Apply
out >   a    = ((B : Env whatever → Set) → Set)
out >   v    = (Σ (Env whatever))
out >   arg1 = λ g₁ → El (el Set)
out >   arg2 = _B_62
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env
out >                 (CompileTimeInlining-minimized.whatever {_60}) ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env
out >               (CompileTimeInlining-minimized.whatever {_60}))
out >   arg1 = λ g ->
out >            CompileTimeInlining-minimized.El
out >              (CompileTimeInlining-minimized.U.el Set)
out >   arg2 = _62 @0
out > { working on problems [141]
out > compareTerm λ g₁ → El (el Set) =< _B_62 : Env whatever → Set
out > compareTerm (not syntactically equal)
out >   λ g₁ → El (el Set) =< _B_62
out >   : Env whatever → Set
out > attempting shortcut _B_62 := λ g₁ → El (el Set)
out > term _B_62 :DirGeq λ g₁ → El (el Set)
out > term _B_62 :DirGeq λ g₁ → El (el Set)
out > is _62 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _B_62
out >   _B_62  :  (Env whatever → Set) := λ g → El (el Set)
out > elimView of  λ g → El (el Set)
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "g" Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]})])
out > elimView (projections reduced) of  λ g → El (el Set)
out > elimView of  (El (el Set))
out > v = Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]})]
out > elimView (projections reduced) of  (El (el Set))
out > elimView of  (el Set)
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  (el Set)
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) == Agda.Primitive.lzero
out > reduced
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _B_62 := λ g g₁ → El (el Set)
out > shortcut successful
out >   result: λ g ->
out >             CompileTimeInlining-minimized.El
out >               (CompileTimeInlining-minimized.U.el Set)
out > problem 141 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 139 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [142]
out > coerce term      v  = snd g
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set == Set₁
out >   Set == Set1
out > equalLevel (lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lzero == lsuc lzero
out > }
out > }
out > problem 142 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _63 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [143]
out > coerce term      v  = Ctxt
out >        from type t1 = Set
out >        to type   t2 = _63
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _63
out >    sorts: Set₁  and  univSort _63
out > compareTerm Set =< _63 
out > compareTerm (not syntactically equal) Set =< _63 
out > { compareAtom
out > compareAtom Set =< _63 
out > compareAtom Set =< _63 
out > equalSort
out >   Set == _63
out >   Set == _63
out > term _63 :DirEq Set
out > term _63 :DirEq Set
out > is _63 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _63
out >   _63 := Set  is a sort
out > solving _63 := Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 143 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _64 : (G : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [144]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 144 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [145]
out > coerce term      v  = Env G
out >        from type t1 = Set
out >        to type   t2 = _64
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _64
out >    sorts: Set₁  and  univSort _64
out > compareTerm Set =< _64 
out > compareTerm (not syntactically equal) Set =< _64 
out > { compareAtom
out > compareAtom Set =< _64 
out > compareAtom Set =< _64 
out > equalSort
out >   Set == _64
out >   Set == _64 @0
out > term _64 :DirEq Set
out > term _64 :DirEq Set
out > is _64 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _64
out >   _64 := Set  is a sort
out > solving _64 := (λ G → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 145 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _65 : (G₁ : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [146]
out > coerce term      v  = U
out >        from type t1 = Set
out >        to type   t2 = _65
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _65
out >    sorts: Set₁  and  univSort _65
out > compareTerm Set =< _65 
out > compareTerm (not syntactically equal) Set =< _65 
out > { compareAtom
out > compareAtom Set =< _65 
out > compareAtom Set =< _65 
out > equalSort
out >   Set == _65
out >   Set == _65 @0
out > term _65 :DirEq Set
out > term _65 :DirEq Set
out > is _65 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _65
out >   _65 := Set  is a sort
out > solving _65 := λ G → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 146 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _66 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [147]
out > coerce term      v  = Ctxt
out >        from type t1 = Set
out >        to type   t2 = _66
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _66
out >    sorts: Set₁  and  univSort _66
out > compareTerm Set =< _66 
out > compareTerm (not syntactically equal) Set =< _66 
out > { compareAtom
out > compareAtom Set =< _66 
out > compareAtom Set =< _66 
out > equalSort
out >   Set == _66
out >   Set == _66
out > term _66 :DirEq Set
out > term _66 :DirEq Set
out > is _66 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _66
out >   _66 := Set  is a sort
out > solving _66 := Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 147 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _67 : (G : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [148]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 148 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [149]
out > coerce term      v  = Env G
out >        from type t1 = Set
out >        to type   t2 = _67
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _67
out >    sorts: Set₁  and  univSort _67
out > compareTerm Set =< _67 
out > compareTerm (not syntactically equal) Set =< _67 
out > { compareAtom
out > compareAtom Set =< _67 
out > compareAtom Set =< _67 
out > equalSort
out >   Set == _67
out >   Set == _67 @0
out > term _67 :DirEq Set
out > term _67 :DirEq Set
out > is _67 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _67
out >   _67 := Set  is a sort
out > solving _67 := (λ G → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 149 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _68 : (G₁ : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [150]
out > coerce term      v  = U
out >        from type t1 = Set
out >        to type   t2 = _68
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _68
out >    sorts: Set₁  and  univSort _68
out > compareTerm Set =< _68 
out > compareTerm (not syntactically equal) Set =< _68 
out > { compareAtom
out > compareAtom Set =< _68 
out > compareAtom Set =< _68 
out > equalSort
out >   Set == _68
out >   Set == _68 @0
out > term _68 :DirEq Set
out > term _68 :DirEq Set
out > is _68 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _68
out >   _68 := Set  is a sort
out > solving _68 := λ G → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 150 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _69 : (G₁ : Ctxt) (s : Env G₁ → U) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [151]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 151 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [152]
out > coerce term      v  = Env G
out >        from type t1 = Set
out >        to type   t2 = _69
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _69
out >    sorts: Set₁  and  univSort _69
out > compareTerm Set =< _69 
out > compareTerm (not syntactically equal) Set =< _69 
out > { compareAtom
out > compareAtom Set =< _69 
out > compareAtom Set =< _69 
out > equalSort
out >   Set == _69
out >   Set == _69 @1 @0
out > term _69 :DirEq Set
out > term _69 :DirEq Set
out > is _69 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _69
out >   _69 := Set  is a sort
out > solving _69 := (λ G s → Set)
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 152 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _70 : (G₁ : Ctxt) (s₁ : Env G₁ → U) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [153]
out > coerce term      v  = U
out >        from type t1 = Set
out >        to type   t2 = _70
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _70
out >    sorts: Set₁  and  univSort _70
out > compareTerm Set =< _70 
out > compareTerm (not syntactically equal) Set =< _70 
out > { compareAtom
out > compareAtom Set =< _70 
out > compareAtom Set =< _70 
out > equalSort
out >   Set == _70
out >   Set == _70 @1 @0
out > term _70 :DirEq Set
out > term _70 :DirEq Set
out > is _70 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _70
out >   _70 := Set  is a sort
out > solving _70 := λ G s → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 153 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _71 : (G₁ : Ctxt) (s₁ t : Env G₁ → U) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [154]
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 154 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [155]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 155 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [156]
out > coerce term      v  = s
out >        from type t1 = (Env G → U)
out >        to type   t2 = (Env G → U)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Env G → U) =< (Env G → U)
out >    sorts: Set  and  Set
out > compareTerm (Env G → U) =< (Env G → U) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 156 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [157]
out > problem 157 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [158]
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 158 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [G, s, t, g] |-
out >   _72 : (G₁ : Ctxt) (s₁ t₁ : Env G₁ → U) (g₁ : Env (snoc G₁ s₁)) →
out >         Set
out > new meta (ConcreteDef): [G, s, t, g] |-
out >   _73 : (G₁ : Ctxt) (s₁ t₁ : Env G₁ → U) (g₁ : Env (snoc G₁ s₁)) →
out >         _A_72 (G = G₁) (s = s₁) (t = t₁) (g = g₁) → Set
out > { working on problems [159]
out > coerce term      v  = g
out >        from type t1 = (Σ (Env G) (λ g₁ → El (s g₁)))
out >        to type   t2 = (Σ _A_72 _B_73)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Σ (Env G) (λ g₁ → El (s g₁))) =< (Σ _A_72 _B_73)
out >    sorts: Set  and  Set
out > compareTerm (Σ (Env G) (λ g₁ → El (s g₁))) =< (Σ _A_72 _B_73) 
out > compareTerm (not syntactically equal)
out >   (Σ (Env G) (λ g₁ → El (s g₁))) =< (Σ _A_72 _B_73)
out >   
out > { compareAtom
out > compareAtom (Σ (Env G) (λ g₁ → El (s g₁))) =< (Σ _A_72 _B_73) 
out > compareAtom (Σ (Env G) (λ g₁ → El (s g₁))) =< (Σ _A_72 _B_73) 
out > compareElims
out >   a     = ((A : Set) (B : A → Set) → Set)
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ (Env G), $ λ g₁ → El (s g₁)]
out >   els02 = [$ _A_72, $ _B_73]
out > { compare Apply
out >   a    = ((A : Set) (B : A → Set) → Set)
out >   v    = Σ
out >   arg1 = (Env G)
out >   arg2 = _A_72
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env @3
out >   arg2 = _72 @3 @2 @1 @0
out > { working on problems [160]
out > compareTerm (Env G) = _A_72 : Set
out > compareTerm (not syntactically equal) (Env G) = _A_72 : Set
out > attempting shortcut _A_72 := (Env G)
out > term _A_72 :DirEq (Env G)
out > term _A_72 :DirEq (Env G)
out > is _72 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_72
out >   _A_72  :  Set := (Env G)
out > elimView of  (Env G)
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 []})]
out > elimView (projections reduced) of  (Env G)
out > elimView of  G
out > v = Var 3 []
out > elimView (projections reduced) of  G
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_72 := λ G s t g → Env G
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Env @3
out > problem 160 was solved!
out > }
out > compareElims
out >   a     = ((B : Env G → Set) → Set)
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = (Σ (Env G))
out >   els01 = [$ λ g₁ → El (s g₁)]
out >   els02 = [$ _B_73]
out > { compare Apply
out >   a    = ((B : Env G → Set) → Set)
out >   v    = (Σ (Env G))
out >   arg1 = λ g₁ → El (s g₁)
out >   arg2 = _B_73
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env @3 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env @3)
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (@3 @0)
out >   arg2 = _73 @3 @2 @1 @0
out > { working on problems [161]
out > compareTerm λ g₁ → El (s g₁) =< _B_73 : Env G → Set
out > compareTerm (not syntactically equal)
out >   λ g₁ → El (s g₁) =< _B_73
out >   : Env G → Set
out > attempting shortcut _B_73 := λ g₁ → El (s g₁)
out > term _B_73 :DirGeq λ g₁ → El (s g₁)
out > term _B_73 :DirGeq λ g₁ → El (s g₁)
out > is _73 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _B_73
out >   _B_73  :  (Env G → Set) := λ g → El (s g)
out > elimView of  λ g → El (s g)
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "g" Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})])
out > elimView (projections reduced) of  λ g → El (s g)
out > elimView of  (El (s g))
out > v = Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 3 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})]
out > elimView (projections reduced) of  (El (s g))
out > elimView of  (s g)
out > v = Var 3 [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  (s g)
out > elimView of  g
out > v = Var 0 []
out > elimView (projections reduced) of  g
out > { coerceSize
out > { compareType
out > compareType (Env G) =< (Env G)
out >    sorts: Set  and  Set
out > compareTerm (Env G) =< (Env G) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _B_73 := λ G s t g g₁ → El (s g₁)
out > shortcut successful
out >   result: λ g -> CompileTimeInlining-minimized.El (@3 @0)
out > problem 161 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 159 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [162]
out > coerce term      v  = fst g
out >        from type t1 = Env G
out >        to type   t2 = Env G
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Env G =< Env G
out >    sorts: Set  and  Set
out > compareTerm Env G =< Env G 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 162 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [163]
out > coerce term      v  = Var (snoc G s) (λ g → t (fst g))
out >        from type t1 = Set
out >        to type   t2 = _71
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _71
out >    sorts: Set₁  and  univSort _71
out > compareTerm Set =< _71 
out > compareTerm (not syntactically equal) Set =< _71 
out > { compareAtom
out > compareAtom Set =< _71 
out > compareAtom Set =< _71 
out > equalSort
out >   Set == _71
out >   Set == _71 @2 @1 @0
out > term _71 :DirEq Set
out > term _71 :DirEq Set
out > is _71 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _71
out >   _71 := Set  is a sort
out > solving _71 := λ G s t → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 163 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _74 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [164]
out > coerce term      v  = Ctxt
out >        from type t1 = Set
out >        to type   t2 = _74
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _74
out >    sorts: Set₁  and  univSort _74
out > compareTerm Set =< _74 
out > compareTerm (not syntactically equal) Set =< _74 
out > { compareAtom
out > compareAtom Set =< _74 
out > compareAtom Set =< _74 
out > equalSort
out >   Set == _74
out >   Set == _74
out > term _74 :DirEq Set
out > term _74 :DirEq Set
out > is _74 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _74
out >   _74 := Set  is a sort
out > solving _74 := Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 164 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _75 : (G : Ctxt) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [165]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 165 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [166]
out > problem 166 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [167]
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 167 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [168]
out > coerce term      v  = Set
out >        from type t1 = Set₁
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set₁ =< Set
out >    sorts: Set₂  and  Set₁
out > compareTerm Set₁ =< Set 
out > compareTerm (not syntactically equal) Set₁ =< Set 
out > { compareAtom
out > compareAtom Set₁ =< Set 
out > compareAtom Set₁ =< Set 
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) == Agda.Primitive.lzero
out > reduced
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > }
out > equalSort
out >   Set₂ == Set₁
out >   Set2 == Set1
out > equalLevel (lsuc (lsuc lzero)) (lsuc lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc (Agda.Primitive.lsuc Agda.Primitive.lzero)) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > reduced
out >   (Agda.Primitive.lsuc (Agda.Primitive.lsuc Agda.Primitive.lzero)) ==
out >   Agda.Primitive.lzero
out > equalLevel lsuc (lsuc lzero) == lzero
out > }
out > }
out > problem 168 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [169]
out > coerce term      v  = Var G (λ _ → el Set)
out >        from type t1 = Set
out >        to type   t2 = _75
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _75
out >    sorts: Set₁  and  univSort _75
out > compareTerm Set =< _75 
out > compareTerm (not syntactically equal) Set =< _75 
out > { compareAtom
out > compareAtom Set =< _75 
out > compareAtom Set =< _75 
out > equalSort
out >   Set == _75
out >   Set == _75 @0
out > term _75 :DirEq Set
out > term _75 :DirEq Set
out > is _75 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _75
out >   _75 := Set  is a sort
out > solving _75 := λ G → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 169 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _76 : (G₁ : Ctxt) (x : Var G₁ (λ _ → el Set)) →
out >                     "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [170]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 170 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [171]
out > problem 171 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [172]
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 172 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [173]
out > coerce term      v  = G
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 173 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [174]
out > problem 174 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [175]
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 175 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [176]
out > coerce term      v  = Set
out >        from type t1 = Set₁
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set₁ =< Set
out >    sorts: Set₂  and  Set₁
out > compareTerm Set₁ =< Set 
out > compareTerm (not syntactically equal) Set₁ =< Set 
out > { compareAtom
out > compareAtom Set₁ =< Set 
out > compareAtom Set₁ =< Set 
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) == Agda.Primitive.lzero
out > reduced
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > }
out > equalSort
out >   Set₂ == Set₁
out >   Set2 == Set1
out > equalLevel (lsuc (lsuc lzero)) (lsuc lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc (Agda.Primitive.lsuc Agda.Primitive.lzero)) ==
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero)
out > reduced
out >   (Agda.Primitive.lsuc (Agda.Primitive.lsuc Agda.Primitive.lzero)) ==
out >   Agda.Primitive.lzero
out > equalLevel lsuc (lsuc lzero) == lzero
out > }
out > }
out > problem 176 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [177]
out > coerce term      v  = x
out >        from type t1 = (Var G (λ _ → el Set))
out >        to type   t2 = (Var G (λ _ → el Set))
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Var G (λ _ → el Set)) =< (Var G (λ _ → el Set))
out >    sorts: Set  and  Set
out > compareTerm (Var G (λ _ → el Set)) =< (Var G (λ _ → el Set)) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 177 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [178]
out > coerce term      v  = g
out >        from type t1 = (Env G)
out >        to type   t2 = (Env G)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Env G) =< (Env G)
out >    sorts: Set  and  Set
out > compareTerm (Env G) =< (Env G) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 178 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [179]
out > coerce term      v  = lookup G (λ _ → el Set) x g
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set == Set₁
out >   Set == Set1
out > equalLevel (lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lzero == lsuc lzero
out > }
out > }
out > problem 179 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [180]
out > coerce term      v  = Type G
out >                       (λ g → el (lookup G (λ _ → el Set) x g))
out >        from type t1 = Set
out >        to type   t2 = _76
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _76
out >    sorts: Set₁  and  univSort _76
out > compareTerm Set =< _76 
out > compareTerm (not syntactically equal) Set =< _76 
out > { compareAtom
out > compareAtom Set =< _76 
out > compareAtom Set =< _76 
out > equalSort
out >   Set == _76
out >   Set == _76 @1 @0
out > term _76 :DirEq Set
out > term _76 :DirEq Set
out > is _76 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _76
out >   _76 := Set  is a sort
out > solving _76 := λ G x → Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 180 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new sort meta _77 : "dummyType: src/full/Agda/TypeChecking/MetaVars.hs"
out > { working on problems [181]
out > coerce term      v  = myctxt
out >        from type t1 = Ctxt
out >        to type   t2 = Ctxt
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 181 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [182]
out > problem 182 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [183]
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 183 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [g] |- _78 : (g₁ : Env myctxt) → Set
out > new meta (ConcreteDef): [g] |-
out >   _79 : (g₁ : Env myctxt) → _A_78 (g = g₁) → Set
out > new meta (ConcreteDef): [g] |- _80 : (g₁ : Env myctxt) → Set
out > new meta (ConcreteDef): [g] |-
out >   _81 : (g₁ : Env myctxt) → _A_80 (g = g₁) → Set
out > { working on problems [184]
out > coerce term      v  = g
out >        from type t1 = (Σ (Env (snoc whatever (λ _ → el Set)))
out >                        (λ g₁ → El (el (snd g₁))))
out >        to type   t2 = (Σ _A_80 _B_81)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Σ (Env (snoc whatever (λ _ → el Set)))
out >              (λ g₁ → El (el (snd g₁)))) =<
out >             (Σ _A_80 _B_81)
out >    sorts: Set  and  Set
out > compareTerm
out >   (Σ (Env (snoc whatever (λ _ → el Set)))
out >    (λ g₁ → El (el (snd g₁)))) =< (Σ _A_80 _B_81)
out >   
out > compareTerm (not syntactically equal)
out >   (Σ (Env (snoc whatever (λ _ → el Set)))
out >    (λ g₁ → El (el (snd g₁)))) =< (Σ _A_80 _B_81)
out >   
out > { compareAtom
out > compareAtom (Σ (Env (snoc whatever (λ _ → el Set)))
out >              (λ g₁ → El (el (snd g₁)))) =<
out >             (Σ _A_80 _B_81) 
out > compareAtom (Σ (Env (snoc whatever (λ _ → el Set)))
out >              (λ g₁ → El (el (snd g₁)))) =<
out >             (Σ _A_80 _B_81) 
out > compareElims
out >   a     = ((A : Set) (B : A → Set) → Set)
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ (Env (snoc whatever (λ _ → el Set))),
out >            $ λ g₁ → El (el (snd g₁))]
out >   els02 = [$ _A_80, $ _B_81]
out > { compare Apply
out >   a    = ((A : Set) (B : A → Set) → Set)
out >   v    = Σ
out >   arg1 = (Env (snoc whatever (λ _ → el Set)))
out >   arg2 = _A_80
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env
out >            (CompileTimeInlining-minimized.Ctxt.snoc
out >               (CompileTimeInlining-minimized.whatever
out >                  {CompileTimeInlining-minimized.Ctxt})
out >               (λ _ -> CompileTimeInlining-minimized.U.el Set))
out >   arg2 = _80 @0
out > { working on problems [185]
out > compareTerm (Env (snoc whatever (λ _ → el Set))) = _A_80 : Set
out > compareTerm (not syntactically equal)
out >   (Env (snoc whatever (λ _ → el Set))) = _A_80
out >   : Set
out > attempting shortcut _A_80 := (Env (snoc whatever (λ _ → el Set)))
out > term _A_80 :DirEq (Env (snoc whatever (λ _ → el Set)))
out > term _A_80 :DirEq (Env (snoc whatever (λ _ → el Set)))
out > is _80 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_80
out >   _A_80  :  Set := (Env (snoc whatever (λ _ → el Set)))
out > elimView of  (Env (snoc whatever (λ _ → el Set)))
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Con (ConHead {conName = CompileTimeInlining-minimized.Ctxt.snoc, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "_" Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})])})]})]
out > elimView (projections reduced) of  (Env
out >                                     (snoc whatever (λ _ → el Set)))
out > elimView of  (snoc whatever (λ _ → el Set))
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.Ctxt.snoc, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "_" Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})])})]
out > elimView (projections reduced) of  (snoc whatever (λ _ → el Set))
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  λ _ → el Set
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "_" Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})])
out > elimView (projections reduced) of  λ _ → el Set
out > elimView of  (el Set)
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  (el Set)
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) == Agda.Primitive.lzero
out > reduced
out >   (Agda.Primitive.lsuc Agda.Primitive.lzero) == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_80 := λ g → Env (snoc whatever (λ _ → el Set))
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Env
out >             (CompileTimeInlining-minimized.Ctxt.snoc
out >                (CompileTimeInlining-minimized.whatever
out >                   {CompileTimeInlining-minimized.Ctxt})
out >                (λ _ -> CompileTimeInlining-minimized.U.el Set))
out > problem 185 was solved!
out > }
out > compareElims
out >   a     = ((B : Env (snoc whatever (λ _ → el Set)) → Set) → Set)
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = (Σ (Env (snoc whatever (λ _ → el Set))))
out >   els01 = [$ λ g₁ → El (el (snd g₁))]
out >   els02 = [$ _B_81]
out > { compare Apply
out >   a    = ((B : Env (snoc whatever (λ _ → el Set)) → Set) → Set)
out >   v    = (Σ (Env (snoc whatever (λ _ → el Set))))
out >   arg1 = λ g₁ → El (el (snd g₁))
out >   arg2 = _B_81
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env
out >                 (CompileTimeInlining-minimized.Ctxt.snoc
out >                    (CompileTimeInlining-minimized.whatever
out >                       {CompileTimeInlining-minimized.Ctxt})
out >                    (λ _ -> CompileTimeInlining-minimized.U.el Set)) ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env
out >               (CompileTimeInlining-minimized.Ctxt.snoc
out >                  (CompileTimeInlining-minimized.whatever
out >                     {CompileTimeInlining-minimized.Ctxt})
out >                  (λ _ -> CompileTimeInlining-minimized.U.el Set)))
out >   arg1 = λ g ->
out >            CompileTimeInlining-minimized.El
out >              (CompileTimeInlining-minimized.U.el
out >                 (@0 .CompileTimeInlining-minimized.Σ.snd))
out >   arg2 = _81 @0
out > { working on problems [186]
out > compareTerm
out >   λ g₁ → El (el (snd g₁)) =< _B_81
out >   : Env (snoc whatever (λ _ → el Set)) → Set
out > compareTerm (not syntactically equal)
out >   λ g₁ → El (el (snd g₁)) =< _B_81
out >   : Env (snoc whatever (λ _ → el Set)) → Set
out > attempting shortcut _B_81 := λ g₁ → El (el (snd g₁))
out > term _B_81 :DirGeq λ g₁ → El (el (snd g₁))
out > term _B_81 :DirGeq λ g₁ → El (el (snd g₁))
out > is _81 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _B_81
out >   _B_81  :  (Env (snoc whatever (λ _ → el Set)) → Set) := λ g →
out >                                                             El (el (snd g))
out > elimView of  λ g → El (el (snd g))
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "g" Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 [Proj ProjPrefix CompileTimeInlining-minimized.Σ.snd]})]})])
out > elimView (projections reduced) of  λ g → El (el (snd g))
out > elimView of  (El (el (snd g)))
out > v = Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 [Proj ProjPrefix CompileTimeInlining-minimized.Σ.snd]})]})]
out > elimView (projections reduced) of  (El (el (snd g)))
out > elimView of  (el (snd g))
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 [Proj ProjPrefix CompileTimeInlining-minimized.Σ.snd]})]
out > elimView (projections reduced) of  (el (snd g))
out > elimView of  (snd g)
out > v = Var 0 [Proj ProjPrefix CompileTimeInlining-minimized.Σ.snd]
out > elimView (projections reduced) of  (snd g)
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _B_81 := λ g g₁ → El (el (snd g₁))
out > shortcut successful
out >   result: λ g ->
out >             CompileTimeInlining-minimized.El
out >               (CompileTimeInlining-minimized.U.el
out >                  (@0 .CompileTimeInlining-minimized.Σ.snd))
out > problem 186 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 184 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [187]
out > coerce term      v  = fst g
out >        from type t1 = Σ (Env whatever) (λ g₁ → El (el Set))
out >        to type   t2 = Σ _A_78 _B_79
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Σ (Env whatever) (λ g₁ → El (el Set)) =< Σ _A_78 _B_79
out >    sorts: Set  and  Set
out > compareTerm Σ (Env whatever) (λ g₁ → El (el Set)) =< Σ _A_78 _B_79 
out > compareTerm (not syntactically equal)
out >   Σ (Env whatever) (λ g₁ → El (el Set)) =< Σ _A_78 _B_79
out >   
out > { compareAtom
out > compareAtom Σ (Env whatever) (λ g₁ → El (el Set)) =< Σ _A_78 _B_79 
out > compareAtom Σ (Env whatever) (λ g₁ → El (el Set)) =< Σ _A_78 _B_79 
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env whatever, $ λ g₁ → El (el Set)]
out >   els02 = [$ _A_78, $ _B_79]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env whatever
out >   arg2 = _A_78
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env
out >            (CompileTimeInlining-minimized.whatever
out >               {CompileTimeInlining-minimized.Ctxt})
out >   arg2 = _78 @0
out > { working on problems [188]
out > compareTerm Env whatever = _A_78 : Set
out > compareTerm (not syntactically equal) Env whatever = _A_78 : Set
out > attempting shortcut _A_78 := Env whatever
out > term _A_78 :DirEq Env whatever
out > term _A_78 :DirEq Env whatever
out > is _78 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_78
out >   _A_78  :  Set := Env whatever
out > elimView of  Env whatever
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]})]
out > elimView (projections reduced) of  Env whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_78 := λ g → Env whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Env
out >             (CompileTimeInlining-minimized.whatever
out >                {CompileTimeInlining-minimized.Ctxt})
out > problem 188 was solved!
out > }
out > compareElims
out >   a     = (B : Env whatever → Set) → Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env whatever)
out >   els01 = [$ λ g₁ → El (el Set)]
out >   els02 = [$ _B_79]
out > { compare Apply
out >   a    = (B : Env whatever → Set) → Set
out >   v    = Σ (Env whatever)
out >   arg1 = λ g₁ → El (el Set)
out >   arg2 = _B_79
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env
out >                 (CompileTimeInlining-minimized.whatever
out >                    {CompileTimeInlining-minimized.Ctxt}) ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env
out >               (CompileTimeInlining-minimized.whatever
out >                  {CompileTimeInlining-minimized.Ctxt}))
out >   arg1 = λ g ->
out >            CompileTimeInlining-minimized.El
out >              (CompileTimeInlining-minimized.U.el Set)
out >   arg2 = _79 @0
out > { working on problems [189]
out > compareTerm λ g₁ → El (el Set) =< _B_79 : Env whatever → Set
out > compareTerm (not syntactically equal)
out >   λ g₁ → El (el Set) =< _B_79
out >   : Env whatever → Set
out > attempting shortcut _B_79 := λ g₁ → El (el Set)
out > term _B_79 :DirGeq λ g₁ → El (el Set)
out > term _B_79 :DirGeq λ g₁ → El (el Set)
out > is _79 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _B_79
out >   _B_79  :  Env whatever → Set := λ g → El (el Set)
out > elimView of  λ g → El (el Set)
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "g" Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]})])
out > elimView (projections reduced) of  λ g → El (el Set)
out > elimView of  El (el Set)
out > v = Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]})]
out > elimView (projections reduced) of  El (el Set)
out > elimView of  el Set
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  el Set
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _B_79 := λ g g₁ → El (el Set)
out > shortcut successful
out >   result: λ g ->
out >             CompileTimeInlining-minimized.El
out >               (CompileTimeInlining-minimized.U.el Set)
out > problem 189 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 187 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [190]
out > coerce term      v  = snd (fst g)
out >        from type t1 = Set
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< Set
out >    sorts: Set  and  Set₁
out > compareTerm Set =< Set 
out > equalSort
out >   Set == Set₁
out >   Set == Set1
out > equalLevel (lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lzero == lsuc lzero
out > }
out > }
out > problem 190 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [191]
out > coerce term      v  = Type myctxt (λ g → el (snd (fst g)))
out >        from type t1 = Set
out >        to type   t2 = _77
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Set =< _77
out >    sorts: Set₁  and  univSort _77
out > compareTerm Set =< _77 
out > compareTerm (not syntactically equal) Set =< _77 
out > { compareAtom
out > compareAtom Set =< _77 
out > compareAtom Set =< _77 
out > equalSort
out >   Set == _77
out >   Set == _77
out > term _77 :DirEq Set
out > term _77 :DirEq Set
out > is _77 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _77
out >   _77 := Set  is a sort
out > solving _77 := Set
out > }
out > equalSort
out >   Set₁ == Set₁
out >   Set1 == Set1
out > equalLevel (lsuc lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero ==
out >   Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lsuc lzero == lsuc lzero
out > }
out > }
out > problem 191 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [] |- _82 : Ctxt
out > new meta (ConcreteDef): [] |- _83 : Ctxt
out > { working on problems [192]
out > problem 192 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [193]
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 193 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > new meta (ConcreteDef): [z] |- _84 : (z₁ : Env _G_83) → Set
out > new meta (ConcreteDef): [z] |-
out >   _85 : (z₁ : Env _G_83) → _A_84 (z = z₁) → Set
out > { working on problems [194]
out > coerce term      v  = z
out >        from type t1 = (Env _G_83)
out >        to type   t2 = (Σ _A_84 _B_85)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType (Env _G_83) =< (Σ _A_84 _B_85)
out >    sorts: Set  and  Set
out > compareTerm (Env _G_83) =< (Σ _A_84 _B_85) 
out > compareTerm (not syntactically equal)
out >   (Env _G_83) =< (Σ _A_84 _B_85)
out >   
out > { compareAtom
out > compareAtom (Env _G_83) =< (Σ _A_84 _B_85) 
out > compareAtom [ (Env _G_83) ]_83 =< (Σ _A_84 _B_85) 
out > new meta (ConcreteDef): [z] |- _86 : ((z₁ : Env _G_83) → Ctxt)
out > new meta (ConcreteDef): [z] |-
out >   _87 : ((z₁ : Env _G_83) → Env (_G_86 (z = z₁)) → U)
out > compareElims
out >   a     = (Ctxt → Set)
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Env
out >   els01 = [$ (snoc _G_86 _s_87)]
out >   els02 = [$ _G_83]
out > { compare Apply
out >   a    = (Ctxt → Set)
out >   v    = Env
out >   arg1 = (snoc _G_86 _s_87)
out >   arg2 = _G_83
out >   raw:
out >   a    = CompileTimeInlining-minimized.Ctxt -> Set
out >   v    = CompileTimeInlining-minimized.Env
out >   arg1 = CompileTimeInlining-minimized.Ctxt.snoc (_86 @0) (_87 @0)
out >   arg2 = _83
out > { working on problems [195]
out > compareTerm (snoc _G_86 _s_87) = _G_83 : Ctxt
out > compareTerm (not syntactically equal)
out >   (snoc _G_86 _s_87) = _G_83
out >   : Ctxt
out > attempting shortcut _G_83 := (snoc _G_86 _s_87)
out > term _G_83 :DirEq (snoc _G_86 _s_87)
out > term _G_83 :DirEq (snoc _G_86 _s_87)
out > is _83 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _G_83
out >   _G_83  :  Ctxt := (snoc _G_88 (λ v → _s_89 v))
out > elimView of  (snoc _G_88 (λ v → _s_89 v))
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.Ctxt.snoc, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 88) []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 89) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])})]
out > elimView (projections reduced) of  (snoc _G_88 (λ v → _s_89 v))
out > elimView of  _G_88
out > v = MetaV (MetaId 88) []
out > elimView (projections reduced) of  _G_88
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  λ v → _s_89 v
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "v" MetaV (MetaId 89) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})])
out > elimView (projections reduced) of  λ v → _s_89 v
out > elimView of  (_s_89 v)
out > v = MetaV (MetaId 89) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  (_s_89 v)
out > elimView of  v
out > v = Var 0 []
out > elimView (projections reduced) of  v
out > { coerceSize
out > { compareType
out > compareType (Env _G_88) =< (Env _G_88)
out >    sorts: Set  and  Set
out > compareTerm (Env _G_88) =< (Env _G_88) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _G_83 := (snoc _G_88 (λ v → _s_89 v))
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Ctxt.snoc _88 (λ v -> _89 @0)
out > problem 195 was solved!
out > }
out > }
out > compareTerm
out >   (Σ (Env _G_88) (λ g → El (_s_89 g))) =< (Σ _A_84 _B_85)
out >   
out > compareTerm (not syntactically equal)
out >   (Σ (Env _G_88) (λ g → El (_s_89 g))) =< (Σ _A_84 _B_85)
out >   
out > { compareAtom
out > compareAtom (Σ (Env _G_88) (λ g → El (_s_89 g))) =< (Σ _A_84 _B_85)
out >             
out > compareAtom (Σ (Env _G_88) (λ g → El (_s_89 g))) =< (Σ _A_84 _B_85)
out >             
out > compareElims
out >   a     = ((A : Set) (B : A → Set) → Set)
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ (Env _G_88), $ λ g → El (_s_89 g)]
out >   els02 = [$ _A_84, $ _B_85]
out > { compare Apply
out >   a    = ((A : Set) (B : A → Set) → Set)
out >   v    = Σ
out >   arg1 = (Env _G_88)
out >   arg2 = _A_84
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env _88
out >   arg2 = _84 @0
out > { working on problems [196]
out > compareTerm (Env _G_88) = _A_84 : Set
out > compareTerm (not syntactically equal) (Env _G_88) = _A_84 : Set
out > attempting shortcut _A_84 := (Env _G_88)
out > term _A_84 :DirEq (Env _G_88)
out > term _A_84 :DirEq (Env _G_88)
out > is _84 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _A_84
out >   _A_84  :  Set := (Env _G_88)
out > elimView of  (Env _G_88)
out > v = Def CompileTimeInlining-minimized.Env [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 88) []})]
out > elimView (projections reduced) of  (Env _G_88)
out > elimView of  _G_88
out > v = MetaV (MetaId 88) []
out > elimView (projections reduced) of  _G_88
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _A_84 := λ z → Env _G_88
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Env _88
out > problem 196 was solved!
out > }
out > compareElims
out >   a     = ((B : Env _G_88 → Set) → Set)
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = (Σ (Env _G_88))
out >   els01 = [$ λ g → El (_s_89 g)]
out >   els02 = [$ _B_85]
out > { compare Apply
out >   a    = ((B : Env _G_88 → Set) → Set)
out >   v    = (Σ (Env _G_88))
out >   arg1 = λ g → El (_s_89 g)
out >   arg2 = _B_85
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env _88 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env _88)
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (_89 @0)
out >   arg2 = _85 @0
out > { working on problems [197]
out > compareTerm λ g → El (_s_89 g) =< _B_85 : Env _G_88 → Set
out > compareTerm (not syntactically equal)
out >   λ g → El (_s_89 g) =< _B_85
out >   : Env _G_88 → Set
out > attempting shortcut _B_85 := λ g → El (_s_89 g)
out > term _B_85 :DirGeq λ g → El (_s_89 g)
out > term _B_85 :DirGeq λ g → El (_s_89 g)
out > is _85 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _B_85
out >   _B_85  :  (Env _G_88 → Set) := λ g → El (_s_89 g)
out > elimView of  λ g → El (_s_89 g)
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "g" Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 89) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})])
out > elimView (projections reduced) of  λ g → El (_s_89 g)
out > elimView of  (El (_s_89 g))
out > v = Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 89) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})]
out > elimView (projections reduced) of  (El (_s_89 g))
out > elimView of  (_s_89 g)
out > v = MetaV (MetaId 89) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  (_s_89 g)
out > elimView of  g
out > v = Var 0 []
out > elimView (projections reduced) of  g
out > { coerceSize
out > { compareType
out > compareType (Env _G_88) =< (Env _G_88)
out >    sorts: Set  and  Set
out > compareTerm (Env _G_88) =< (Env _G_88) 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _B_85 := λ z g → El (_s_89 g)
out > shortcut successful
out >   result: λ g -> CompileTimeInlining-minimized.El (_89 @0)
out > problem 197 was solved!
out > }
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 194 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > { working on problems [198]
out > coerce term      v  = snd z
out >        from type t1 = El (_s_89 (fst z))
out >        to type   t2 = Set
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType El (_s_89 (fst z)) =< Set
out >    sorts: Set  and  Set₁
out > compareTerm El (_s_89 (fst z)) =< Set 
out > compareTerm (not syntactically equal) El (_s_89 (fst z)) =< Set 
out > { compareAtom
out > compareAtom El (_s_89 (fst z)) =< Set 
out > compareAtom [ El (_s_89 (fst z)) ]_89 =< Set 
out > }
out > equalSort
out >   Set == Set₁
out >   Set == Set1
out > equalLevel (lzero) (lsuc lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lsuc Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lsuc Agda.Primitive.lzero
out > equalLevel lzero == lsuc lzero
out > }
out > }
out > problem 198 was not solved.
out > }
out > Solving awake constraints. 0 remaining.
out > blocked _90 := snd
out >      by [[198] El (_s_89 (fst z)) =< Set ]
out > new meta (ConcreteDef): [z] |-
out >   _91 : (z₁ : Env (snoc _G_88 (λ v → _s_89 v))) → Set
out > setting twin of _91 to be _90
out > new meta (ConcreteDef): [] |-
out >   _92 : (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out > { working on problems [199]
out > coerce term      v  = suc (snoc _G_88 (λ v → _s_89 v))
out >                       (λ z → el (_91 (z = z))) _t_92
out >        from type t1 = Either
out >                       ((λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)))
out >                       (Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >                        (λ u →
out >                           Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >                           (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u)))
out >        to type   t2 = Var _G_82 (λ _ → el Set)
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Either
out >             ((λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)))
out >             (Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >              (λ u →
out >                 Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >                 (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))) =<
out >             Var _G_82 (λ _ → el Set)
out >    sorts: Set  and  Set
out > compareTerm
out >   Either ((λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)))
out >   (Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >    (λ u →
out >       Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >       (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))) =< Var _G_82
out >                                                       (λ _ → el Set)
out >   
out > compareTerm (not syntactically equal)
out >   Either ((λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)))
out >   (Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >    (λ u →
out >       Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >       (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))) =< Var _G_82
out >                                                       (λ _ → el Set)
out >   
out > { compareAtom
out > compareAtom Either
out >             ((λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)))
out >             (Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >              (λ u →
out >                 Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >                 (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))) =<
out >             Var _G_82 (λ _ → el Set) 
out > compareAtom Either
out >             ((λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)))
out >             (Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >              (λ u →
out >                 Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >                 (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))) =<
out >             [ Var _G_82 (λ _ → el Set) ]_82 
out > new meta (ConcreteDef): [] |- _93 : Ctxt
out > new meta (ConcreteDef): [] |- _94 : Env _G_93 → U
out > new meta (ConcreteDef): [] |- _95 : Env (snoc _G_93 _s_94) → U
out > compareElims
out >   a     = (G : Ctxt) → (Env G → U) → Set
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Var
out >   els01 = [$ snoc _G_93 _s_94, $ _t_95]
out >   els02 = [$ _G_82, $ λ _ → el Set]
out > { compare Apply
out >   a    = (G : Ctxt) → (Env G → U) → Set
out >   v    = Var
out >   arg1 = snoc _G_93 _s_94
out >   arg2 = _G_82
out >   raw:
out >   a    = (G : CompileTimeInlining-minimized.Ctxt) ->
out >            (CompileTimeInlining-minimized.Env @0 ->
out >               CompileTimeInlining-minimized.U) ->
out >              Set
out >   v    = CompileTimeInlining-minimized.Var
out >   arg1 = CompileTimeInlining-minimized.Ctxt.snoc _93 _94
out >   arg2 = _82
out > { working on problems [200]
out > compareTerm snoc _G_93 _s_94 = _G_82 : Ctxt
out > compareTerm (not syntactically equal)
out >   snoc _G_93 _s_94 = _G_82
out >   : Ctxt
out > attempting shortcut _G_82 := snoc _G_93 _s_94
out > term _G_82 :DirEq snoc _G_93 _s_94
out > term _G_82 :DirEq snoc _G_93 _s_94
out > is _82 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _G_82
out >   _G_82  :  Ctxt := snoc _G_93 _s_94
out > elimView of  snoc _G_93 _s_94
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.Ctxt.snoc, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 93) []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 94) []})]
out > elimView (projections reduced) of  snoc _G_93 _s_94
out > elimView of  _G_93
out > v = MetaV (MetaId 93) []
out > elimView (projections reduced) of  _G_93
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  _s_94
out > v = MetaV (MetaId 94) []
out > elimView (projections reduced) of  _s_94
out > { coerceSize
out > { compareType
out > compareType Env _G_93 → U =< Env _G_93 → U
out >    sorts: Set  and  Set
out > compareTerm Env _G_93 → U =< Env _G_93 → U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _G_82 := snoc _G_93 _s_94
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Ctxt.snoc _93 _94
out > problem 200 was solved!
out > }
out > compareElims
out >   a     = (Env (snoc _G_93 _s_94) → U) → Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Var (snoc _G_93 _s_94)
out >   els01 = [$ _t_95]
out >   els02 = [$ λ _ → el Set]
out > { compare Apply
out >   a    = (Env (snoc _G_93 _s_94) → U) → Set
out >   v    = Var (snoc _G_93 _s_94)
out >   arg1 = _t_95
out >   arg2 = λ _ → el Set
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Env
out >             (CompileTimeInlining-minimized.Ctxt.snoc _93 _94) ->
out >             CompileTimeInlining-minimized.U) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Var
out >            (CompileTimeInlining-minimized.Ctxt.snoc _93 _94)
out >   arg1 = _95
out >   arg2 = λ _ -> CompileTimeInlining-minimized.U.el Set
out > { working on problems [201]
out > compareTerm _t_95 =< λ _ → el Set : Env (snoc _G_93 _s_94) → U
out > compareTerm (not syntactically equal)
out >   _t_95 =< λ _ → el Set
out >   : Env (snoc _G_93 _s_94) → U
out > attempting shortcut _t_95 := λ _ → el Set
out > term _t_95 :DirLeq λ _ → el Set
out > term _t_95 :DirLeq λ _ → el Set
out > is _95 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _t_95
out >   _t_95  :  Env (snoc _G_93 _s_94) → U := λ _ → el Set
out > elimView of  λ _ → el Set
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "_" Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})])
out > elimView (projections reduced) of  λ _ → el Set
out > elimView of  el Set
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  el Set
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _t_95 := λ _ → el Set
out > shortcut successful
out >   result: λ _ -> CompileTimeInlining-minimized.U.el Set
out > problem 201 was solved!
out > }
out > }
out > }
out > compareTerm
out >   Either ((λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)))
out >   (Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >    (λ u →
out >       Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >       (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))) =< Either
out >                                                       ((λ g → _s_94 (fst g)) ≡ (λ _ → el Set))
out >                                                       (Σ (Env _G_93 → U)
out >                                                        (λ u →
out >                                                           Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                                                           (λ _ → Var _G_93 u)))
out >   
out > compareTerm (not syntactically equal)
out >   Either ((λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)))
out >   (Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >    (λ u →
out >       Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >       (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))) =< Either
out >                                                       ((λ g → _s_94 (fst g)) ≡ (λ _ → el Set))
out >                                                       (Σ (Env _G_93 → U)
out >                                                        (λ u →
out >                                                           Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                                                           (λ _ → Var _G_93 u)))
out >   
out > { compareAtom
out > compareAtom Either
out >             ((λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)))
out >             (Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >              (λ u →
out >                 Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >                 (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))) =<
out >             Either ((λ g → _s_94 (fst g)) ≡ (λ _ → el Set))
out >             (Σ (Env _G_93 → U)
out >              (λ u → Σ ((λ g → u (fst g)) ≡ (λ _ → el Set)) (λ _ → Var _G_93 u)))
out >             
out > compareAtom Either
out >             ((λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)))
out >             (Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >              (λ u →
out >                 Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >                 (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))) =<
out >             Either ((λ g → _s_94 (fst g)) ≡ (λ _ → el Set))
out >             (Σ (Env _G_93 → U)
out >              (λ u → Σ ((λ g → u (fst g)) ≡ (λ _ → el Set)) (λ _ → Var _G_93 u)))
out >             
out > compareElims
out >   a     = Set → Set → Set
out >   pols0 (truncated to 10) = Covariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Either
out >   els01 = [$ (λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)),
out >            $ Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >              (λ u →
out >                 Σ ((λ g → u (fst g)) ≡ (λ g → _t_92 (fst g)))
out >                 (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))]
out >   els02 = [$ (λ g → _s_94 (fst g)) ≡ (λ _ → el Set),
out >            $ Σ (Env _G_93 → U)
out >              (λ u → Σ ((λ g → u (fst g)) ≡ (λ _ → el Set)) (λ _ → Var _G_93 u))]
out > { compare Apply
out >   a    = Set → Set → Set
out >   v    = Either
out >   arg1 = (λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g))
out >   arg2 = (λ g → _s_94 (fst g)) ≡ (λ _ → el Set)
out >   raw:
out >   a    = Set -> Set -> Set
out >   v    = CompileTimeInlining-minimized.Either
out >   arg1 = CompileTimeInlining-minimized._≡_
out >            {(g : CompileTimeInlining-minimized.Σ
out >                    (CompileTimeInlining-minimized.Env
out >                       (CompileTimeInlining-minimized.Ctxt.snoc _88 (λ v -> _89 @0)))
out >                    (λ v ->
out >                       CompileTimeInlining-minimized.El
out >                         (CompileTimeInlining-minimized.U.el (_91 @0)))) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g ->
out >               CompileTimeInlining-minimized.U.el
out >                 (_91 (@0 .CompileTimeInlining-minimized.Σ.fst)))
out >            (λ g -> _92 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >   arg2 = CompileTimeInlining-minimized._≡_
out >            {(g : CompileTimeInlining-minimized.Σ
out >                    (CompileTimeInlining-minimized.Env _93)
out >                    (λ v -> CompileTimeInlining-minimized.El (_94 @0))) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g -> _94 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >            (λ _ -> CompileTimeInlining-minimized.U.el Set)
out > { working on problems [202]
out > compareTerm
out >   (λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)) =< (λ g →
out >                                                                _s_94 (fst g))
out >                                                             ≡ (λ _ → el Set)
out >   : Set
out > compareTerm (not syntactically equal)
out >   (λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g)) =< (λ g →
out >                                                                _s_94 (fst g))
out >                                                             ≡ (λ _ → el Set)
out >   : Set
out > { compareTerm
out > compareTerm (λ g → el (_91 (z = (fst g)))) ≡ (λ g → _t_92 (fst g))
out > =< (λ g → _s_94 (fst g)) ≡ (λ _ → el Set) : Set
out > { compareAtom
out > compareAtom (λ g → el (_91 (z = (fst g)))) ≡
out >             (λ g → _t_92 (fst g)) =<
out >             (λ g → _s_94 (fst g)) ≡ (λ _ → el Set) : Set
out > compareAtom (λ g → el (_91 (z = (fst g)))) ≡
out >             (λ g → _t_92 (fst g)) =<
out >             (λ g → _s_94 (fst g)) ≡ (λ _ → el Set) : Set
out > compareElims
out >   a     = {A : Set} → A → A → Set
out >   pols0 (truncated to 10) = Invariant Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_
out >   els01 = [$ {_}, $ λ g → el (_91 (z = (fst g))),
out >            $ λ g → _t_92 (fst g)]
out >   els02 = [$ {_}, $ λ g → _s_94 (fst g), $ λ _ → el Set]
out > { compare Apply
out >   a    = {A : Set} → A → A → Set
out >   v    = _≡_
out >   arg1 = {_}
out >   arg2 = {_}
out >   raw:
out >   a    = {A : Set} -> @0 -> @0 -> Set
out >   v    = CompileTimeInlining-minimized._≡_
out >   arg1 = {(g : CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env
out >                     (CompileTimeInlining-minimized.Ctxt.snoc _88 (λ v -> _89 @0)))
out >                  (λ v ->
out >                     CompileTimeInlining-minimized.El
out >                       (CompileTimeInlining-minimized.U.el (_91 @0)))) ->
out >             CompileTimeInlining-minimized.U}
out >   arg2 = {(g : CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env _93)
out >                  (λ v -> CompileTimeInlining-minimized.El (_94 @0))) ->
out >             CompileTimeInlining-minimized.U}
out > { working on problems [203]
out > compareTerm
out >   (g
out >    : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >      (λ v → El (el (_91 (z = v))))) →
out >   U = (g : Σ (Env _G_93) (λ v → El (_s_94 v))) → U
out >   : Set
out > compareTerm (not syntactically equal)
out >   (g
out >    : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >      (λ v → El (el (_91 (z = v))))) →
out >   U = (g : Σ (Env _G_93) (λ v → El (_s_94 v))) → U
out >   : Set
out > { compareTerm
out > compareTerm
out > (g
out >  : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >    (λ v → El (el (_91 (z = v))))) →
out > U
out > = (g : Σ (Env _G_93) (λ v → El (_s_94 v))) → U : Set
out > { compareAtom
out > compareAtom (g
out >              : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >                (λ v → El (el (_91 (z = v))))) →
out >             U =
out >             (g : Σ (Env _G_93) (λ v → El (_s_94 v))) → U : Set
out > compareAtom (g
out >              : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >                (λ v → El (el (_91 (z = v))))) →
out >             U =
out >             (g : Σ (Env _G_93) (λ v → El (_s_94 v))) → U : Set
out > { compare function types
out >   t1 = (g
out >         : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >           (λ v → El (el (_91 (z = v))))) →
out >        U
out >   t2 = (g : Σ (Env _G_93) (λ v → El (_s_94 v))) → U
out > { working on problems [204]
out > { compareType
out > compareType Σ (Env _G_93) (λ v → El (_s_94 v)) =
out >             Σ (Env (snoc _G_88 (λ v → _s_89 v))) (λ v → El (el (_91 (z = v))))
out >    sorts: Set  and  Set
out > compareTerm
out >   Σ (Env _G_93) (λ v → El (_s_94 v)) = Σ
out >                                        (Env (snoc _G_88 (λ v → _s_89 v)))
out >                                        (λ v → El (el (_91 (z = v))))
out >   
out > compareTerm (not syntactically equal)
out >   Σ (Env _G_93) (λ v → El (_s_94 v)) = Σ
out >                                        (Env (snoc _G_88 (λ v → _s_89 v)))
out >                                        (λ v → El (el (_91 (z = v))))
out >   
out > { compareAtom
out > compareAtom Σ (Env _G_93) (λ v → El (_s_94 v)) =
out >             Σ (Env (snoc _G_88 (λ v → _s_89 v))) (λ v → El (el (_91 (z = v)))) 
out > compareAtom Σ (Env _G_93) (λ v → El (_s_94 v)) =
out >             Σ (Env (snoc _G_88 (λ v → _s_89 v))) (λ v → El (el (_91 (z = v)))) 
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env _G_93, $ λ v → El (_s_94 v)]
out >   els02 = [$ Env (snoc _G_88 (λ v → _s_89 v)),
out >            $ λ v → El (el (_91 (z = v)))]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env _G_93
out >   arg2 = Env (snoc _G_88 (λ v → _s_89 v))
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env _93
out >   arg2 = CompileTimeInlining-minimized.Env
out >            (CompileTimeInlining-minimized.Ctxt.snoc _88 (λ v -> _89 @0))
out > { working on problems [205]
out > compareTerm Env _G_93 = Env (snoc _G_88 (λ v → _s_89 v)) : Set
out > compareTerm (not syntactically equal)
out >   Env _G_93 = Env (snoc _G_88 (λ v → _s_89 v))
out >   : Set
out > { compareTerm
out > compareTerm Env _G_93 = Env (snoc _G_88 (λ v → _s_89 v)) : Set
out > { compareAtom
out > compareAtom Env _G_93 = Env (snoc _G_88 (λ v → _s_89 v)) : Set
out > compareAtom [ Env _G_93 ]_93 = Σ (Env _G_88) (λ g → El (_s_89 g))
out >             : Set
out > new meta (ConcreteDef): [] |- _96 : Ctxt
out > new meta (ConcreteDef): [] |- _97 : Env _G_96 → U
out > compareElims
out >   a     = Ctxt → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Env
out >   els01 = [$ snoc _G_96 _s_97]
out >   els02 = [$ _G_93]
out > { compare Apply
out >   a    = Ctxt → Set
out >   v    = Env
out >   arg1 = snoc _G_96 _s_97
out >   arg2 = _G_93
out >   raw:
out >   a    = CompileTimeInlining-minimized.Ctxt -> Set
out >   v    = CompileTimeInlining-minimized.Env
out >   arg1 = CompileTimeInlining-minimized.Ctxt.snoc _96 _97
out >   arg2 = _93
out > { working on problems [206]
out > compareTerm snoc _G_96 _s_97 = _G_93 : Ctxt
out > compareTerm (not syntactically equal)
out >   snoc _G_96 _s_97 = _G_93
out >   : Ctxt
out > attempting shortcut _G_93 := snoc _G_96 _s_97
out > term _G_93 :DirEq snoc _G_96 _s_97
out > term _G_93 :DirEq snoc _G_96 _s_97
out > is _93 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _G_93
out >   _G_93  :  Ctxt := snoc _G_96 _s_97
out > elimView of  snoc _G_96 _s_97
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.Ctxt.snoc, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 96) []}),Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 97) []})]
out > elimView (projections reduced) of  snoc _G_96 _s_97
out > elimView of  _G_96
out > v = MetaV (MetaId 96) []
out > elimView (projections reduced) of  _G_96
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > elimView of  _s_97
out > v = MetaV (MetaId 97) []
out > elimView (projections reduced) of  _s_97
out > { coerceSize
out > { compareType
out > compareType Env _G_96 → U =< Env _G_96 → U
out >    sorts: Set  and  Set
out > compareTerm Env _G_96 → U =< Env _G_96 → U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _G_93 := snoc _G_96 _s_97
out > shortcut successful
out >   result: CompileTimeInlining-minimized.Ctxt.snoc _96 _97
out > problem 206 was solved!
out > }
out > }
out > compareTerm
out >   Σ (Env _G_96) (λ g → El (_s_97 g)) = Σ (Env _G_88)
out >                                        (λ g → El (_s_89 g))
out >   : Set
out > compareTerm (not syntactically equal)
out >   Σ (Env _G_96) (λ g → El (_s_97 g)) = Σ (Env _G_88)
out >                                        (λ g → El (_s_89 g))
out >   : Set
out > { compareTerm
out > compareTerm Σ (Env _G_96) (λ g → El (_s_97 g)) =
out > Σ (Env _G_88) (λ g → El (_s_89 g)) : Set
out > { compareAtom
out > compareAtom Σ (Env _G_96) (λ g → El (_s_97 g)) =
out >             Σ (Env _G_88) (λ g → El (_s_89 g)) : Set
out > compareAtom Σ (Env _G_96) (λ g → El (_s_97 g)) =
out >             Σ (Env _G_88) (λ g → El (_s_89 g)) : Set
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env _G_96, $ λ g → El (_s_97 g)]
out >   els02 = [$ Env _G_88, $ λ g → El (_s_89 g)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env _G_96
out >   arg2 = Env _G_88
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env _96
out >   arg2 = CompileTimeInlining-minimized.Env _88
out > { working on problems [207]
out > compareTerm Env _G_96 = Env _G_88 : Set
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 : Set
out > { compareTerm
out > compareTerm Env _G_96 = Env _G_88 : Set
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareAtom [ Env _G_96 ]_96 = [ Env _G_88 ]_88 : Set
out > compareTerm Env _G_96 = Env _G_88 : Set
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 : Set
out > { compareTerm
out > compareTerm Env _G_96 = Env _G_88 : Set
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareElims
out >   a     = Ctxt → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Env
out >   els01 = [$ _G_96]
out >   els02 = [$ _G_88]
out > { compare Apply
out >   a    = Ctxt → Set
out >   v    = Env
out >   arg1 = _G_96
out >   arg2 = _G_88
out >   raw:
out >   a    = CompileTimeInlining-minimized.Ctxt -> Set
out >   v    = CompileTimeInlining-minimized.Env
out >   arg1 = _96
out >   arg2 = _88
out > { working on problems [208]
out > compareTerm _G_96 = _G_88 : Ctxt
out > compareTerm (not syntactically equal) _G_96 = _G_88 : Ctxt
out > attempting shortcut _G_96 := _G_88
out > term _G_96 :DirEq _G_88
out > attempting shortcut _G_88 := _G_96
out > term _G_88 :DirEq _G_96
out > { compareTerm
out > compareTerm _G_96 = _G_88 : Ctxt
out > { compareAtom
out > compareAtom _G_96 = _G_88 : Ctxt
out > compareAtom _G_96 = _G_88 : Ctxt
out > term _G_96 :DirEq _G_88
out > term _G_88 :DirEq _G_96
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > problem 207 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = Env _G_96
out >   arg2 = Env _G_88
out > antiUnify
out > a = Set
out > u = Env _G_96
out > v = Env _G_88
out > antiUnify
out > a = Ctxt
out > u = _G_96
out > v = _G_88
out > blocked _98 := _G_96
out >      by [[199, 202, 203, 204, 205, 207] Env _G_96 = Env _G_88
out >                                           : Set]
out > new meta (ConcreteDef): [] |- _99 : Ctxt
out > setting twin of _99 to be _98
out > Anti-unification: Env _99
out > compareElims
out >   a     = (B : Env _99 → Set) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env _99)
out >   els01 = [$ λ g → El (_s_97 g)]
out >   els02 = [$ λ g → El (_s_89 g)]
out > { compare Apply
out >   a    = (B : Env _99 → Set) → Set
out >   v    = Σ (Env _99)
out >   arg1 = λ g → El (_s_97 g)
out >   arg2 = λ g → El (_s_89 g)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env _99 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env _99)
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (_97 @0)
out >   arg2 = λ g -> CompileTimeInlining-minimized.El (_89 @0)
out > { working on problems [208]
out > compareTerm λ g → El (_s_97 g) = λ g → El (_s_89 g) : Env _99 → Set
out > compareTerm (not syntactically equal)
out >   λ g → El (_s_97 g) = λ g → El (_s_89 g)
out >   : Env _99 → Set
out > { compareTerm
out > compareTerm λ g → El (_s_97 g) = λ g → El (_s_89 g) : Env _99 → Set
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_97 g) = El (_s_89 g)
out >   : Set
out > { compareTerm
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > { compareAtom
out > compareAtom El (_s_97 g) = El (_s_89 g) : Set
out > compareAtom [ El (_s_97 g) ]_97 = [ El (_s_89 g) ]_89 : Set
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_97 g) = El (_s_89 g)
out >   : Set
out > { compareTerm
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > { compareAtom
out > compareAtom El (_s_97 g) = El (_s_89 g) : Set
out > compareAtom El (_s_97 g) = El (_s_89 g) : Set
out > compareElims
out >   a     = U → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = El
out >   els01 = [$ _s_97 g]
out >   els02 = [$ _s_89 g]
out > { compare Apply
out >   a    = U → Set
out >   v    = El
out >   arg1 = _s_97 g
out >   arg2 = _s_89 g
out >   raw:
out >   a    = CompileTimeInlining-minimized.U -> Set
out >   v    = CompileTimeInlining-minimized.El
out >   arg1 = _97 @0
out >   arg2 = _89 @0
out > { working on problems [209]
out > compareTerm _s_97 g = _s_89 g : U
out > compareTerm (not syntactically equal) _s_97 g = _s_89 g : U
out > attempting shortcut _s_97 g := _s_89 g
out > term _s_97 g :DirEq _s_89 g
out > attempting shortcut _s_89 g := _s_97 g
out > term _s_89 g :DirEq _s_97 g
out > { compareTerm
out > compareTerm _s_97 g = _s_89 g : U
out > { compareAtom
out > compareAtom _s_97 g = _s_89 g : U
out > compareAtom _s_97 g = _s_89 g : U
out > term _s_97 g :DirEq _s_89 g
out > term _s_89 g :DirEq _s_97 g
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > }
out > problem 208 was not solved.
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > problem 205 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = Env (snoc _G_96 _s_97)
out >   arg2 = Env (snoc _G_88 (λ v → _s_89 v))
out > antiUnify
out > a = Set
out > u = Σ (Env _G_96) (λ g → El (_s_97 g))
out > v = Σ (Env _G_88) (λ g → El (_s_89 g))
out > antiUnify
out > a = Set
out > u = Env _G_96
out > v = Env _G_88
out > antiUnify
out > a = Ctxt
out > u = _G_96
out > v = _G_88
out > blocked _100 := _G_96
out >      by [[199, 202, 203, 204, 205, 208] El (_s_97 g) = El (_s_89 g)
out >                                           : Set,
out >          [199, 202, 203, 204, 205] _98 := _G_96 [blocked on problem 207],
out >          [199, 202, 203, 204, 205, 207] Env _G_96 = Env _G_88 : Set]
out > new meta (ConcreteDef): [] |- _101 : Ctxt
out > setting twin of _101 to be _100
out > antiUnify
out > a = Env _101 → Set
out > u = λ g → El (_s_97 g)
out > v = λ g → El (_s_89 g)
out > antiUnify
out > a = Set
out > u = El (_s_97 _)
out > v = El (_s_89 _)
out > antiUnify
out > a = U
out > u = _s_97 _
out > v = _s_89 _
out > blocked _102 := λ z → _s_97 z
out >      by [[199, 202, 203, 204, 205, 208] El (_s_97 g) = El (_s_89 g)
out >                                           : Set,
out >          [199, 202, 203, 204, 205] _98 := _G_96 [blocked on problem 207],
out >          [199, 202, 203, 204, 205, 207] Env _G_96 = Env _G_88 : Set]
out > new meta (ConcreteDef): [_] |- _103 : (_ : Env _101) → U
out > setting twin of _103 to be _102
out > Anti-unification: Σ (Env _101) (λ g → El (_103 (_ = g)))
out > compareElims
out >   a     = (B : Σ (Env _101) (λ g → El (_103 (_ = g))) → Set) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Σ (Env _101) (λ g → El (_103 (_ = g))))
out >   els01 = [$ λ v → El (_s_94 v)]
out >   els02 = [$ λ v → El (el (_91 (z = v)))]
out > { compare Apply
out >   a    = (B : Σ (Env _101) (λ g → El (_103 (_ = g))) → Set) → Set
out >   v    = Σ (Σ (Env _101) (λ g → El (_103 (_ = g))))
out >   arg1 = λ v → El (_s_94 v)
out >   arg2 = λ v → El (el (_91 (z = v)))
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Σ
out >                 (CompileTimeInlining-minimized.Env _101)
out >                 (λ g -> CompileTimeInlining-minimized.El (_103 @0)) ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Env _101)
out >               (λ g -> CompileTimeInlining-minimized.El (_103 @0)))
out >   arg1 = λ v -> CompileTimeInlining-minimized.El (_94 @0)
out >   arg2 = λ v ->
out >            CompileTimeInlining-minimized.El
out >              (CompileTimeInlining-minimized.U.el (_91 @0))
out > { working on problems [209]
out > compareTerm
out >   λ v → El (_s_94 v) = λ v → El (el (_91 (z = v)))
out >   : Σ (Env _101) (λ g → El (_103 (_ = g))) → Set
out > compareTerm (not syntactically equal)
out >   λ v → El (_s_94 v) = λ v → El (el (_91 (z = v)))
out >   : Σ (Env _101) (λ g → El (_103 (_ = g))) → Set
out > { compareTerm
out > compareTerm λ v → El (_s_94 v) = λ v → El (el (_91 (z = v))) :
out > Σ (Env _101) (λ g → El (_103 (_ = g))) → Set
out > compareTerm El (_s_94 v) = El (el (_91 (z = v))) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_94 v) = El (el (_91 (z = v)))
out >   : Set
out > { compareTerm
out > compareTerm El (_s_94 v) = El (el (_91 (z = v))) : Set
out > { compareAtom
out > compareAtom El (_s_94 v) = El (el (_91 (z = v))) : Set
out > compareAtom [ El (_s_94 v) ]_94 = _91 (z = v) : Set
out > term _91 (z = v) :DirEq El (_s_94 v)
out > term _91 (z = v) :DirEq El (_s_94 v)
out > is _91 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _91
out >   _91  :  Set := El (_s_94 z)
out > elimView of  El (_s_94 z)
out > v = Def CompileTimeInlining-minimized.El [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = MetaV (MetaId 94) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]})]
out > elimView (projections reduced) of  El (_s_94 z)
out > elimView of  _s_94 z
out > v = MetaV (MetaId 94) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  _s_94 z
out > elimView of  z
out > v = Var 0 []
out > elimView (projections reduced) of  z
out > { coerceSize
out > { compareType
out > compareType Σ (Env _G_88) (λ g → El (_s_89 g)) =<
out >             Env (snoc _G_96 _s_97)
out >    sorts: Set  and  Set
out > compareTerm
out >   Σ (Env _G_88) (λ g → El (_s_89 g)) =< Env (snoc _G_96 _s_97)
out >   
out > compareTerm (not syntactically equal)
out >   Σ (Env _G_88) (λ g → El (_s_89 g)) =< Env (snoc _G_96 _s_97)
out >   
out > { compareAtom
out > compareAtom Σ (Env _G_88) (λ g → El (_s_89 g)) =<
out >             Env (snoc _G_96 _s_97) 
out > compareAtom Σ (Env _G_88) (λ g → El (_s_89 g)) =<
out >             Σ (Env _G_96) (λ g → El (_s_97 g)) 
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env _G_88, $ λ g → El (_s_89 g)]
out >   els02 = [$ Env _G_96, $ λ g → El (_s_97 g)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env _G_88
out >   arg2 = Env _G_96
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env _88
out >   arg2 = CompileTimeInlining-minimized.Env _96
out > { working on problems [210]
out > compareTerm Env _G_88 = Env _G_96 : Set
out > compareTerm (not syntactically equal) Env _G_88 = Env _G_96 : Set
out > { compareTerm
out > compareTerm Env _G_88 = Env _G_96 : Set
out > { compareAtom
out > compareAtom Env _G_88 = Env _G_96 : Set
out > compareAtom [ Env _G_88 ]_88 = [ Env _G_96 ]_96 : Set
out > compareTerm Env _G_88 = Env _G_96 : Set
out > compareTerm (not syntactically equal) Env _G_88 = Env _G_96 : Set
out > { compareTerm
out > compareTerm Env _G_88 = Env _G_96 : Set
out > { compareAtom
out > compareAtom Env _G_88 = Env _G_96 : Set
out > compareAtom Env _G_88 = Env _G_96 : Set
out > compareElims
out >   a     = Ctxt → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Env
out >   els01 = [$ _G_88]
out >   els02 = [$ _G_96]
out > { compare Apply
out >   a    = Ctxt → Set
out >   v    = Env
out >   arg1 = _G_88
out >   arg2 = _G_96
out >   raw:
out >   a    = CompileTimeInlining-minimized.Ctxt -> Set
out >   v    = CompileTimeInlining-minimized.Env
out >   arg1 = _88
out >   arg2 = _96
out > { working on problems [211]
out > compareTerm _G_88 = _G_96 : Ctxt
out > compareTerm (not syntactically equal) _G_88 = _G_96 : Ctxt
out > attempting shortcut _G_96 := _G_88
out > don't assign metas
out > attempting shortcut _G_88 := _G_96
out > don't assign metas
out > { compareTerm
out > compareTerm _G_88 = _G_96 : Ctxt
out > { compareAtom
out > compareAtom _G_88 = _G_96 : Ctxt
out > compareAtom _G_88 = _G_96 : Ctxt
out > don't assign metas
out > don't assign metas
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > problem 210 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = Env _G_88
out >   arg2 = Env _G_96
out > antiUnify
out > a = Set
out > u = Env _G_88
out > v = Env _G_96
out > antiUnify
out > a = Ctxt
out > u = _G_88
out > v = _G_96
out > blocked _104 := λ z → _G_88
out >      by [[199, 202, 203, 204, 209, 210] Env _G_88 = Env _G_96
out >                                           : Set]
out > new meta (ConcreteDef): [z] |-
out >   _105 : (z₁ : Env (snoc _G_88 (λ v → _s_89 v))) → Ctxt
out > setting twin of _105 to be _104
out > Anti-unification: Env _105
out > compareElims
out >   a     = (B : Env _105 → Set) → Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env _105)
out >   els01 = [$ λ g → El (_s_89 g)]
out >   els02 = [$ λ g → El (_s_97 g)]
out > { compare Apply
out >   a    = (B : Env _105 → Set) → Set
out >   v    = Σ (Env _105)
out >   arg1 = λ g → El (_s_89 g)
out >   arg2 = λ g → El (_s_97 g)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env (_105 @0) -> Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env (_105 @0))
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (_89 @0)
out >   arg2 = λ g -> CompileTimeInlining-minimized.El (_97 @0)
out > { working on problems [211]
out > compareTerm
out >   λ g → El (_s_89 g) =< λ g → El (_s_97 g)
out >   : Env _105 → Set
out > compareTerm (not syntactically equal)
out >   λ g → El (_s_89 g) =< λ g → El (_s_97 g)
out >   : Env _105 → Set
out > { compareTerm
out > compareTerm λ g → El (_s_89 g) =< λ g → El (_s_97 g) :
out > Env _105 → Set
out > compareTerm El (_s_89 g) =< El (_s_97 g) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_89 g) =< El (_s_97 g)
out >   : Set
out > { compareTerm
out > compareTerm El (_s_89 g) =< El (_s_97 g) : Set
out > { compareAtom
out > compareAtom El (_s_89 g) =< El (_s_97 g) : Set
out > compareAtom [ El (_s_89 g) ]_89 =< [ El (_s_97 g) ]_97 : Set
out > compareTerm El (_s_89 g) = El (_s_97 g) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_89 g) = El (_s_97 g)
out >   : Set
out > { compareTerm
out > compareTerm El (_s_89 g) = El (_s_97 g) : Set
out > { compareAtom
out > compareAtom El (_s_89 g) = El (_s_97 g) : Set
out > compareAtom El (_s_89 g) = El (_s_97 g) : Set
out > compareElims
out >   a     = U → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = El
out >   els01 = [$ _s_89 g]
out >   els02 = [$ _s_97 g]
out > { compare Apply
out >   a    = U → Set
out >   v    = El
out >   arg1 = _s_89 g
out >   arg2 = _s_97 g
out >   raw:
out >   a    = CompileTimeInlining-minimized.U -> Set
out >   v    = CompileTimeInlining-minimized.El
out >   arg1 = _89 @0
out >   arg2 = _97 @0
out > { working on problems [212]
out > compareTerm _s_89 g = _s_97 g : U
out > compareTerm (not syntactically equal) _s_89 g = _s_97 g : U
out > attempting shortcut _s_97 g := _s_89 g
out > don't assign metas
out > attempting shortcut _s_89 g := _s_97 g
out > don't assign metas
out > { compareTerm
out > compareTerm _s_89 g = _s_97 g : U
out > { compareAtom
out > compareAtom _s_89 g = _s_97 g : U
out > compareAtom _s_89 g = _s_97 g : U
out > don't assign metas
out > don't assign metas
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > }
out > problem 211 was not solved.
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > solving _91 := λ z → El (_s_94 z)
out > }
out > }
out > }
out > problem 209 was not solved.
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 204 was not solved.
out > }
out > { compareType
out > compareType U = U
out >    sorts: Set  and  Set
out > compareTerm U = U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > }
out > problem 203 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = {_}
out >   arg2 = {_}
out > antiUnify
out > a = Set
out > u = (g
out >      : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >        (λ v → El (el (El (_s_94 v))))) →
out >     U
out > v = (g : Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))) → U
out > antiUnify
out > a = Set
out > u = Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >     (λ v → El (el (El (_s_94 v))))
out > v = Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))
out > antiUnify
out > a = Set
out > u = Σ (Env _G_88) (λ g → El (_s_89 g))
out > v = Σ (Env _G_96) (λ g → El (_s_97 g))
out > antiUnify
out > a = Set
out > u = Env _G_88
out > v = Env _G_96
out > antiUnify
out > a = Ctxt
out > u = _G_88
out > v = _G_96
out > blocked _106 := _G_88
out >      by [[199, 202, 203, 204, 209, 211] El (_s_89 g)
out >                                           =< El (_s_97 g)
out >                                           : Set,
out >          [199, 202, 203, 204, 209] _104 := λ z → _G_88
out >                                      [blocked on problem 210],
out >          [199, 202, 203, 204, 209, 210] Env _G_88 = Env _G_96 : Set,
out >          [199, 202, 203, 204] _102 := λ z → _s_97 z
out >                                 [blocked on problem 205],
out >          [199, 202, 203, 204] _100 := _G_96 [blocked on problem 205],
out >          [199, 202, 203, 204, 205, 208] El (_s_97 g) = El (_s_89 g) : Set,
out >          [199, 202, 203, 204, 205] _98 := _G_96 [blocked on problem 207],
out >          [199, 202, 203, 204, 205, 207] Env _G_96 = Env _G_88 : Set]
out > new meta (ConcreteDef): [] |- _107 : Ctxt
out > setting twin of _107 to be _106
out > antiUnify
out > a = Env _107 → Set
out > u = λ g → El (_s_89 g)
out > v = λ g → El (_s_97 g)
out > antiUnify
out > a = Set
out > u = El (_s_89 _)
out > v = El (_s_97 _)
out > antiUnify
out > a = U
out > u = _s_89 _
out > v = _s_97 _
out > blocked _108 := λ z → _s_89 z
out >      by [[199, 202, 203, 204, 209, 211] El (_s_89 g)
out >                                           =< El (_s_97 g)
out >                                           : Set,
out >          [199, 202, 203, 204, 209] _104 := λ z → _G_88
out >                                      [blocked on problem 210],
out >          [199, 202, 203, 204, 209, 210] Env _G_88 = Env _G_96 : Set,
out >          [199, 202, 203, 204] _102 := λ z → _s_97 z
out >                                 [blocked on problem 205],
out >          [199, 202, 203, 204] _100 := _G_96 [blocked on problem 205],
out >          [199, 202, 203, 204, 205, 208] El (_s_97 g) = El (_s_89 g) : Set,
out >          [199, 202, 203, 204, 205] _98 := _G_96 [blocked on problem 207],
out >          [199, 202, 203, 204, 205, 207] Env _G_96 = Env _G_88 : Set]
out > new meta (ConcreteDef): [_] |- _109 : (_ : Env _107) → U
out > setting twin of _109 to be _108
out > antiUnify
out > a = Σ (Env _107) (λ g → El (_109 (_ = g))) → Set
out > u = λ v → El (el (El (_s_94 v)))
out > v = λ v → El (_s_94 v)
out > antiUnify
out > a = Set
out > u = El (_s_94 _)
out > v = El (_s_94 _)
out > Anti-unification: {_}
out > compareElims
out >   a     = (Σ (Σ (Env _107) (λ g → El (_109 (_ = g))))
out >            (λ v → El (_s_94 v)) →
out >            U) →
out >           (Σ (Σ (Env _107) (λ g → El (_109 (_ = g)))) (λ v → El (_s_94 v)) →
out >            U) →
out >           Set
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_
out >   els01 = [$ λ g → el (El (_s_94 (fst g))), $ λ g → _t_92 (fst g)]
out >   els02 = [$ λ g → _s_94 (fst g), $ λ _ → el Set]
out > { compare Apply
out >   a    = (Σ (Σ (Env _107) (λ g → El (_109 (_ = g))))
out >           (λ v → El (_s_94 v)) →
out >           U) →
out >          (Σ (Σ (Env _107) (λ g → El (_109 (_ = g)))) (λ v → El (_s_94 v)) →
out >           U) →
out >          Set
out >   v    = _≡_
out >   arg1 = λ g → el (El (_s_94 (fst g)))
out >   arg2 = λ g → _s_94 (fst g)
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Σ
out >             (CompileTimeInlining-minimized.Σ
out >                (CompileTimeInlining-minimized.Env _107)
out >                (λ g -> CompileTimeInlining-minimized.El (_109 @0)))
out >             (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >             CompileTimeInlining-minimized.U) ->
out >            (CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env _107)
out >                  (λ g -> CompileTimeInlining-minimized.El (_109 @0)))
out >               (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >               CompileTimeInlining-minimized.U) ->
out >              Set
out >   v    = CompileTimeInlining-minimized._≡_
out >            {CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env _107)
out >                  (λ g -> CompileTimeInlining-minimized.El (_109 @0)))
out >               (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >               CompileTimeInlining-minimized.U}
out >   arg1 = λ g ->
out >            CompileTimeInlining-minimized.U.el
out >              (_91 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >   arg2 = λ g -> _94 (@0 .CompileTimeInlining-minimized.Σ.fst)
out > { working on problems [212]
out > compareTerm
out >   λ g → el (El (_s_94 (fst g))) = λ g → _s_94 (fst g)
out >   : Σ (Σ (Env _107) (λ g → El (_109 (_ = g)))) (λ v → El (_s_94 v)) →
out >     U
out > compareTerm (not syntactically equal)
out >   λ g → el (El (_s_94 (fst g))) = λ g → _s_94 (fst g)
out >   : Σ (Σ (Env _107) (λ g → El (_109 (_ = g)))) (λ v → El (_s_94 v)) →
out >     U
out > { compareTerm
out > compareTerm λ g → el (El (_s_94 (fst g))) = λ g → _s_94 (fst g) :
out > Σ (Σ (Env _107) (λ g → El (_109 (_ = g)))) (λ v → El (_s_94 v)) → U
out > compareTerm el (El (_s_94 (fst g))) = _s_94 (fst g) : U
out > compareTerm (not syntactically equal)
out >   el (El (_s_94 (fst g))) = _s_94 (fst g)
out >   : U
out > attempting shortcut _s_94 (fst g) := el (El (_s_94 (fst g)))
out > term _s_94 (fst g) :DirEq el (El (_s_94 (fst g)))
out > term _s_94 (fst g) :DirEq el (El (_s_94 (fst g)))
out > is _94 a blocked term? 
out >   no
out > { compareTerm
out > compareTerm el (El (_s_94 (fst g))) = _s_94 (fst g) : U
out > { compareAtom
out > compareAtom el (El (_s_94 (fst g))) = _s_94 (fst g) : U
out > compareAtom el (El (_s_94 (fst g))) = _s_94 (fst g) : U
out > term _s_94 (fst g) :DirEq el (El (_s_94 (fst g)))
out > term _s_94 (fst g) :DirEq el (El (_s_94 (fst g)))
out > is _94 a blocked term? 
out >   no
out > }
out > }
out > }
out > problem 212 was not solved.
out > }
out > compareElims
out >   a     = (Σ (Σ (Env _107) (λ g → El (_109 (_ = g))))
out >            (λ v → El (_s_94 v)) →
out >            U) →
out >           Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_ (λ g → el (El (_s_94 (fst g))))
out >   els01 = [$ λ g → _t_92 (fst g)]
out >   els02 = [$ λ _ → el Set]
out > { compare Apply
out >   a    = (Σ (Σ (Env _107) (λ g → El (_109 (_ = g))))
out >           (λ v → El (_s_94 v)) →
out >           U) →
out >          Set
out >   v    = _≡_ (λ g → el (El (_s_94 (fst g))))
out >   arg1 = λ g → _t_92 (fst g)
out >   arg2 = λ _ → el Set
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Σ
out >             (CompileTimeInlining-minimized.Σ
out >                (CompileTimeInlining-minimized.Env _107)
out >                (λ g -> CompileTimeInlining-minimized.El (_109 @0)))
out >             (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >             CompileTimeInlining-minimized.U) ->
out >            Set
out >   v    = CompileTimeInlining-minimized._≡_
out >            {CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env _107)
out >                  (λ g -> CompileTimeInlining-minimized.El (_109 @0)))
out >               (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g ->
out >               CompileTimeInlining-minimized.U.el
out >                 (_91 (@0 .CompileTimeInlining-minimized.Σ.fst)))
out >   arg1 = λ g -> _92 (@0 .CompileTimeInlining-minimized.Σ.fst)
out >   arg2 = λ _ -> CompileTimeInlining-minimized.U.el Set
out > { working on problems [213]
out > compareTerm
out >   λ g → _t_92 (fst g) =< λ _ → el Set
out >   : Σ (Σ (Env _107) (λ g → El (_109 (_ = g)))) (λ v → El (_s_94 v)) →
out >     U
out > compareTerm (not syntactically equal)
out >   λ g → _t_92 (fst g) =< λ _ → el Set
out >   : Σ (Σ (Env _107) (λ g → El (_109 (_ = g)))) (λ v → El (_s_94 v)) →
out >     U
out > { compareTerm
out > compareTerm λ g → _t_92 (fst g) =< λ _ → el Set :
out > Σ (Σ (Env _107) (λ g → El (_109 (_ = g)))) (λ v → El (_s_94 v)) → U
out > compareTerm _t_92 (fst g) =< el Set : U
out > compareTerm (not syntactically equal) _t_92 (fst g) =< el Set : U
out > attempting shortcut _t_92 (fst g) := el Set
out > term _t_92 (fst g) :DirLeq el Set
out > term _t_92 (fst g) :DirLeq el Set
out > is _92 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _t_92
out >   _t_92  :  U := el Set
out > elimView of  el Set
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  el Set
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _t_92 := λ _ → el Set
out > shortcut successful
out >   result: CompileTimeInlining-minimized.U.el Set
out > }
out > problem 213 was solved!
out > }
out > }
out > }
out > }
out > }
out > }
out > problem 202 was not solved.
out > }
out > compareElims
out >   a     = Set → Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Either ((λ g → el (El (_s_94 (fst g)))) ≡ (λ g → el Set))
out >   els01 = [$ Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >              (λ u →
out >                 Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >                 (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))]
out >   els02 = [$ Σ (Env (snoc _G_96 _s_97) → U)
out >              (λ u →
out >                 Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                 (λ _ → Var (snoc _G_96 _s_97) u))]
out > { compare Apply
out >   a    = Set → Set
out >   v    = Either ((λ g → el (El (_s_94 (fst g)))) ≡ (λ g → el Set))
out >   arg1 = Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >          (λ u →
out >             Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >             (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))
out >   arg2 = Σ (Env (snoc _G_96 _s_97) → U)
out >          (λ u →
out >             Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >             (λ _ → Var (snoc _G_96 _s_97) u))
out >   raw:
out >   a    = Set -> Set
out >   v    = CompileTimeInlining-minimized.Either
out >            (CompileTimeInlining-minimized._≡_
out >               {(g : CompileTimeInlining-minimized.Σ
out >                       (CompileTimeInlining-minimized.Env
out >                          (CompileTimeInlining-minimized.Ctxt.snoc _88 (λ v -> _89 @0)))
out >                       (λ v ->
out >                          CompileTimeInlining-minimized.El
out >                            (CompileTimeInlining-minimized.U.el (_91 @0)))) ->
out >                  CompileTimeInlining-minimized.U}
out >               (λ g ->
out >                  CompileTimeInlining-minimized.U.el
out >                    (_91 (@0 .CompileTimeInlining-minimized.Σ.fst)))
out >               (λ g -> _92 (@0 .CompileTimeInlining-minimized.Σ.fst)))
out >   arg1 = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env _83 ->
out >               CompileTimeInlining-minimized.U)
out >            (λ u ->
out >               CompileTimeInlining-minimized.Σ
out >                 (CompileTimeInlining-minimized._≡_
out >                    {(g : CompileTimeInlining-minimized.Σ
out >                            (CompileTimeInlining-minimized.Env _83)
out >                            (λ v ->
out >                               CompileTimeInlining-minimized.El
out >                                 (CompileTimeInlining-minimized.U.el (_91 @0)))) ->
out >                       CompileTimeInlining-minimized.U}
out >                    (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >                    (λ g -> _92 (@0 .CompileTimeInlining-minimized.Σ.fst)))
out >                 (λ _ -> CompileTimeInlining-minimized.Var _83 @1))
out >   arg2 = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env _93 ->
out >               CompileTimeInlining-minimized.U)
out >            (λ u ->
out >               CompileTimeInlining-minimized.Σ
out >                 (CompileTimeInlining-minimized._≡_
out >                    {(g : CompileTimeInlining-minimized.Σ
out >                            (CompileTimeInlining-minimized.Env _93)
out >                            (λ v -> CompileTimeInlining-minimized.El (_94 @0))) ->
out >                       CompileTimeInlining-minimized.U}
out >                    (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >                    (λ _ -> CompileTimeInlining-minimized.U.el Set))
out >                 (λ _ -> CompileTimeInlining-minimized.Var _93 @1))
out > { working on problems [214]
out > compareTerm
out >   Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >   (λ u →
out >      Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >      (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u)) =< Σ
out >                                                     (Env (snoc _G_96 _s_97) → U)
out >                                                     (λ u →
out >                                                        Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                                                        (λ _ → Var (snoc _G_96 _s_97) u))
out >   : Set
out > compareTerm (not syntactically equal)
out >   Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >   (λ u →
out >      Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >      (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u)) =< Σ
out >                                                     (Env (snoc _G_96 _s_97) → U)
out >                                                     (λ u →
out >                                                        Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                                                        (λ _ → Var (snoc _G_96 _s_97) u))
out >   : Set
out > { compareTerm
out > compareTerm
out > Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out > (λ u →
out >    Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >    (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u))
out > =<
out > Σ (Env (snoc _G_96 _s_97) → U)
out > (λ u →
out >    Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >    (λ _ → Var (snoc _G_96 _s_97) u))
out > : Set
out > { compareAtom
out > compareAtom Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >             (λ u →
out >                Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >                (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u)) =<
out >             Σ (Env (snoc _G_96 _s_97) → U)
out >             (λ u →
out >                Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                (λ _ → Var (snoc _G_96 _s_97) u))
out >             : Set
out > compareAtom Σ (Env (snoc _G_88 (λ v → _s_89 v)) → U)
out >             (λ u →
out >                Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >                (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u)) =<
out >             Σ (Env (snoc _G_96 _s_97) → U)
out >             (λ u →
out >                Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                (λ _ → Var (snoc _G_96 _s_97) u))
out >             : Set
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env (snoc _G_88 (λ v → _s_89 v)) → U,
out >            $ λ u →
out >                Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >                (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u)]
out >   els02 = [$ Env (snoc _G_96 _s_97) → U,
out >            $ λ u →
out >                Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                (λ _ → Var (snoc _G_96 _s_97) u)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env (snoc _G_88 (λ v → _s_89 v)) → U
out >   arg2 = Env (snoc _G_96 _s_97) → U
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env
out >            (CompileTimeInlining-minimized.Ctxt.snoc _88 (λ v -> _89 @0)) ->
out >            CompileTimeInlining-minimized.U
out >   arg2 = CompileTimeInlining-minimized.Env
out >            (CompileTimeInlining-minimized.Ctxt.snoc _96 _97) ->
out >            CompileTimeInlining-minimized.U
out > { working on problems [215]
out > compareTerm
out >   Env (snoc _G_88 (λ v → _s_89 v)) → U = Env (snoc _G_96 _s_97) → U
out >   : Set
out > compareTerm (not syntactically equal)
out >   Env (snoc _G_88 (λ v → _s_89 v)) → U = Env (snoc _G_96 _s_97) → U
out >   : Set
out > { compareTerm
out > compareTerm Env (snoc _G_88 (λ v → _s_89 v)) → U =
out > Env (snoc _G_96 _s_97) → U : Set
out > { compareAtom
out > compareAtom Env (snoc _G_88 (λ v → _s_89 v)) → U =
out >             Env (snoc _G_96 _s_97) → U : Set
out > compareAtom Env (snoc _G_88 (λ v → _s_89 v)) → U =
out >             Env (snoc _G_96 _s_97) → U : Set
out > { compare function types
out >   t1 = Env (snoc _G_88 (λ v → _s_89 v)) → U
out >   t2 = Env (snoc _G_96 _s_97) → U
out > { working on problems [216]
out > { compareType
out > compareType Env (snoc _G_96 _s_97) =
out >             Env (snoc _G_88 (λ v → _s_89 v))
out >    sorts: Set  and  Set
out > compareTerm
out >   Env (snoc _G_96 _s_97) = Env (snoc _G_88 (λ v → _s_89 v))
out >   
out > compareTerm (not syntactically equal)
out >   Env (snoc _G_96 _s_97) = Env (snoc _G_88 (λ v → _s_89 v))
out >   
out > { compareAtom
out > compareAtom Env (snoc _G_96 _s_97) =
out >             Env (snoc _G_88 (λ v → _s_89 v)) 
out > compareAtom Σ (Env _G_96) (λ g → El (_s_97 g)) =
out >             Σ (Env _G_88) (λ g → El (_s_89 g)) 
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env _G_96, $ λ g → El (_s_97 g)]
out >   els02 = [$ Env _G_88, $ λ g → El (_s_89 g)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env _G_96
out >   arg2 = Env _G_88
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env _96
out >   arg2 = CompileTimeInlining-minimized.Env _88
out > { working on problems [217]
out > compareTerm Env _G_96 = Env _G_88 : Set
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 : Set
out > { compareTerm
out > compareTerm Env _G_96 = Env _G_88 : Set
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareAtom [ Env _G_96 ]_96 = [ Env _G_88 ]_88 : Set
out > compareTerm Env _G_96 = Env _G_88 : Set
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 : Set
out > { compareTerm
out > compareTerm Env _G_96 = Env _G_88 : Set
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareElims
out >   a     = Ctxt → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Env
out >   els01 = [$ _G_96]
out >   els02 = [$ _G_88]
out > { compare Apply
out >   a    = Ctxt → Set
out >   v    = Env
out >   arg1 = _G_96
out >   arg2 = _G_88
out >   raw:
out >   a    = CompileTimeInlining-minimized.Ctxt -> Set
out >   v    = CompileTimeInlining-minimized.Env
out >   arg1 = _96
out >   arg2 = _88
out > { working on problems [218]
out > compareTerm _G_96 = _G_88 : Ctxt
out > compareTerm (not syntactically equal) _G_96 = _G_88 : Ctxt
out > attempting shortcut _G_96 := _G_88
out > term _G_96 :DirEq _G_88
out > attempting shortcut _G_88 := _G_96
out > term _G_88 :DirEq _G_96
out > { compareTerm
out > compareTerm _G_96 = _G_88 : Ctxt
out > { compareAtom
out > compareAtom _G_96 = _G_88 : Ctxt
out > compareAtom _G_96 = _G_88 : Ctxt
out > term _G_96 :DirEq _G_88
out > term _G_88 :DirEq _G_96
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > problem 217 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = Env _G_96
out >   arg2 = Env _G_88
out > antiUnify
out > a = Set
out > u = Env _G_96
out > v = Env _G_88
out > antiUnify
out > a = Ctxt
out > u = _G_96
out > v = _G_88
out > blocked _110 := _G_96
out >      by [[199, 214, 215, 216, 217] Env _G_96 = Env _G_88 : Set]
out > new meta (ConcreteDef): [] |- _111 : Ctxt
out > setting twin of _111 to be _110
out > Anti-unification: Env _111
out > compareElims
out >   a     = (B : Env _111 → Set) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env _111)
out >   els01 = [$ λ g → El (_s_97 g)]
out >   els02 = [$ λ g → El (_s_89 g)]
out > { compare Apply
out >   a    = (B : Env _111 → Set) → Set
out >   v    = Σ (Env _111)
out >   arg1 = λ g → El (_s_97 g)
out >   arg2 = λ g → El (_s_89 g)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env _111 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env _111)
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (_97 @0)
out >   arg2 = λ g -> CompileTimeInlining-minimized.El (_89 @0)
out > { working on problems [218]
out > compareTerm
out >   λ g → El (_s_97 g) = λ g → El (_s_89 g)
out >   : Env _111 → Set
out > compareTerm (not syntactically equal)
out >   λ g → El (_s_97 g) = λ g → El (_s_89 g)
out >   : Env _111 → Set
out > { compareTerm
out > compareTerm λ g → El (_s_97 g) = λ g → El (_s_89 g) :
out > Env _111 → Set
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_97 g) = El (_s_89 g)
out >   : Set
out > { compareTerm
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > { compareAtom
out > compareAtom El (_s_97 g) = El (_s_89 g) : Set
out > compareAtom [ El (_s_97 g) ]_97 = [ El (_s_89 g) ]_89 : Set
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_97 g) = El (_s_89 g)
out >   : Set
out > { compareTerm
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > { compareAtom
out > compareAtom El (_s_97 g) = El (_s_89 g) : Set
out > compareAtom El (_s_97 g) = El (_s_89 g) : Set
out > compareElims
out >   a     = U → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = El
out >   els01 = [$ _s_97 g]
out >   els02 = [$ _s_89 g]
out > { compare Apply
out >   a    = U → Set
out >   v    = El
out >   arg1 = _s_97 g
out >   arg2 = _s_89 g
out >   raw:
out >   a    = CompileTimeInlining-minimized.U -> Set
out >   v    = CompileTimeInlining-minimized.El
out >   arg1 = _97 @0
out >   arg2 = _89 @0
out > { working on problems [219]
out > compareTerm _s_97 g = _s_89 g : U
out > compareTerm (not syntactically equal) _s_97 g = _s_89 g : U
out > attempting shortcut _s_97 g := _s_89 g
out > term _s_97 g :DirEq _s_89 g
out > attempting shortcut _s_89 g := _s_97 g
out > term _s_89 g :DirEq _s_97 g
out > { compareTerm
out > compareTerm _s_97 g = _s_89 g : U
out > { compareAtom
out > compareAtom _s_97 g = _s_89 g : U
out > compareAtom _s_97 g = _s_89 g : U
out > term _s_97 g :DirEq _s_89 g
out > term _s_89 g :DirEq _s_97 g
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > }
out > problem 218 was not solved.
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 216 was not solved.
out > }
out > { compareType
out > compareType U = U
out >    sorts: Set  and  Set
out > compareTerm U = U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > }
out > problem 215 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = Env (snoc _G_88 (λ v → _s_89 v)) → U
out >   arg2 = Env (snoc _G_96 _s_97) → U
out > antiUnify
out > a = Set
out > u = Env (snoc _G_88 (λ v → _s_89 v)) → U
out > v = Env (snoc _G_96 _s_97) → U
out > antiUnify
out > a = Set
out > u = Σ (Env _G_88) (λ g → El (_s_89 g))
out > v = Σ (Env _G_96) (λ g → El (_s_97 g))
out > antiUnify
out > a = Set
out > u = Env _G_88
out > v = Env _G_96
out > antiUnify
out > a = Ctxt
out > u = _G_88
out > v = _G_96
out > blocked _112 := _G_88
out >      by [[199, 214, 215, 216, 218] El (_s_97 g) = El (_s_89 g)
out >                                      : Set,
out >          [199, 214, 215, 216] _110 := _G_96 [blocked on problem 217],
out >          [199, 214, 215, 216, 217] Env _G_96 = Env _G_88 : Set]
out > new meta (ConcreteDef): [] |- _113 : Ctxt
out > setting twin of _113 to be _112
out > antiUnify
out > a = Env _113 → Set
out > u = λ g → El (_s_89 g)
out > v = λ g → El (_s_97 g)
out > antiUnify
out > a = Set
out > u = El (_s_89 _)
out > v = El (_s_97 _)
out > antiUnify
out > a = U
out > u = _s_89 _
out > v = _s_97 _
out > blocked _114 := λ z → _s_89 z
out >      by [[199, 214, 215, 216, 218] El (_s_97 g) = El (_s_89 g)
out >                                      : Set,
out >          [199, 214, 215, 216] _110 := _G_96 [blocked on problem 217],
out >          [199, 214, 215, 216, 217] Env _G_96 = Env _G_88 : Set]
out > new meta (ConcreteDef): [_] |- _115 : (_ : Env _113) → U
out > setting twin of _115 to be _114
out > Anti-unification: Σ (Env _113) (λ g → El (_115 (_ = g))) → U
out > compareElims
out >   a     = (B : (Σ (Env _113) (λ g → El (_115 (_ = g))) → U) → Set) →
out >           Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >   els01 = [$ λ u →
out >                Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >                (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u)]
out >   els02 = [$ λ u →
out >                Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                (λ _ → Var (snoc _G_96 _s_97) u)]
out > { compare Apply
out >   a    = (B : (Σ (Env _113) (λ g → El (_115 (_ = g))) → U) → Set) →
out >          Set
out >   v    = Σ (Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >   arg1 = λ u →
out >            Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >            (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u)
out >   arg2 = λ u →
out >            Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >            (λ _ → Var (snoc _G_96 _s_97) u)
out >   raw:
out >   a    = (B : (CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env _113)
out >                  (λ g -> CompileTimeInlining-minimized.El (_115 @0)) ->
out >                  CompileTimeInlining-minimized.U) ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Env _113)
out >               (λ g -> CompileTimeInlining-minimized.El (_115 @0)) ->
out >               CompileTimeInlining-minimized.U)
out >   arg1 = λ u ->
out >            CompileTimeInlining-minimized.Σ
out >              (CompileTimeInlining-minimized._≡_
out >                 {(g : CompileTimeInlining-minimized.Σ
out >                         (CompileTimeInlining-minimized.Env _83)
out >                         (λ v ->
out >                            CompileTimeInlining-minimized.El
out >                              (CompileTimeInlining-minimized.U.el (_91 @0)))) ->
out >                    CompileTimeInlining-minimized.U}
out >                 (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >                 (λ g -> _92 (@0 .CompileTimeInlining-minimized.Σ.fst)))
out >              (λ _ -> CompileTimeInlining-minimized.Var _83 @1)
out >   arg2 = λ u ->
out >            CompileTimeInlining-minimized.Σ
out >              (CompileTimeInlining-minimized._≡_
out >                 {(g : CompileTimeInlining-minimized.Σ
out >                         (CompileTimeInlining-minimized.Env _93)
out >                         (λ v -> CompileTimeInlining-minimized.El (_94 @0))) ->
out >                    CompileTimeInlining-minimized.U}
out >                 (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >                 (λ _ -> CompileTimeInlining-minimized.U.el Set))
out >              (λ _ -> CompileTimeInlining-minimized.Var _93 @1)
out > { working on problems [219]
out > compareTerm
out >   λ u →
out >     Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >     (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u) =< λ u →
out >                                                     Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                                                     (λ _ → Var (snoc _G_96 _s_97) u)
out >   : (Σ (Env _113) (λ g → El (_115 (_ = g))) → U) → Set
out > compareTerm (not syntactically equal)
out >   λ u →
out >     Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >     (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u) =< λ u →
out >                                                     Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                                                     (λ _ → Var (snoc _G_96 _s_97) u)
out >   : (Σ (Env _113) (λ g → El (_115 (_ = g))) → U) → Set
out > { compareTerm
out > compareTerm
out > λ u →
out >   Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >   (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u)
out > =<
out > λ u →
out >   Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >   (λ _ → Var (snoc _G_96 _s_97) u)
out > : (Σ (Env _113) (λ g → El (_115 (_ = g))) → U) → Set
out > compareTerm
out >   Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >   (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u) =< Σ
out >                                                 ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                                                 (λ _ → Var (snoc _G_96 _s_97) u)
out >   : Set
out > compareTerm (not syntactically equal)
out >   Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >   (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u) =< Σ
out >                                                 ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >                                                 (λ _ → Var (snoc _G_96 _s_97) u)
out >   : Set
out > { compareTerm
out > compareTerm
out > Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out > (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u)
out > =<
out > Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out > (λ _ → Var (snoc _G_96 _s_97) u)
out > : Set
out > { compareAtom
out > compareAtom Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >             (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u) =<
out >             Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >             (λ _ → Var (snoc _G_96 _s_97) u)
out >             : Set
out > compareAtom Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >             (λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u) =<
out >             Σ ((λ g → u (fst g)) ≡ (λ _ → el Set))
out >             (λ _ → Var (snoc _G_96 _s_97) u)
out >             : Set
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ (λ g → u (fst g)) ≡ (λ g → el Set),
out >            $ λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u]
out >   els02 = [$ (λ g → u (fst g)) ≡ (λ _ → el Set),
out >            $ λ _ → Var (snoc _G_96 _s_97) u]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = (λ g → u (fst g)) ≡ (λ g → el Set)
out >   arg2 = (λ g → u (fst g)) ≡ (λ _ → el Set)
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized._≡_
out >            {(g : CompileTimeInlining-minimized.Σ
out >                    (CompileTimeInlining-minimized.Env
out >                       (CompileTimeInlining-minimized.Ctxt.snoc _88 (λ v -> _89 @0)))
out >                    (λ v ->
out >                       CompileTimeInlining-minimized.El
out >                         (CompileTimeInlining-minimized.U.el (_91 @0)))) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >            (λ g -> _92 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >   arg2 = CompileTimeInlining-minimized._≡_
out >            {(g : CompileTimeInlining-minimized.Σ
out >                    (CompileTimeInlining-minimized.Env
out >                       (CompileTimeInlining-minimized.Ctxt.snoc _96 _97))
out >                    (λ v -> CompileTimeInlining-minimized.El (_94 @0))) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >            (λ _ -> CompileTimeInlining-minimized.U.el Set)
out > { working on problems [220]
out > compareTerm
out >   (λ g → u (fst g)) ≡ (λ g → el Set) = (λ g → u (fst g)) ≡
out >                                        (λ _ → el Set)
out >   : Set
out > compareTerm (not syntactically equal)
out >   (λ g → u (fst g)) ≡ (λ g → el Set) = (λ g → u (fst g)) ≡
out >                                        (λ _ → el Set)
out >   : Set
out > { compareTerm
out > compareTerm (λ g → u (fst g)) ≡ (λ g → el Set) =
out > (λ g → u (fst g)) ≡ (λ _ → el Set) : Set
out > { compareAtom
out > compareAtom (λ g → u (fst g)) ≡ (λ g → el Set) =
out >             (λ g → u (fst g)) ≡ (λ _ → el Set) : Set
out > compareAtom (λ g → u (fst g)) ≡ (λ g → el Set) =
out >             (λ g → u (fst g)) ≡ (λ _ → el Set) : Set
out > compareElims
out >   a     = {A : Set} → A → A → Set
out >   pols0 (truncated to 10) = Invariant Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_
out >   els01 = [$ {_}, $ λ g → u (fst g), $ λ g → el Set]
out >   els02 = [$ {_}, $ λ g → u (fst g), $ λ _ → el Set]
out > { compare Apply
out >   a    = {A : Set} → A → A → Set
out >   v    = _≡_
out >   arg1 = {_}
out >   arg2 = {_}
out >   raw:
out >   a    = {A : Set} -> @0 -> @0 -> Set
out >   v    = CompileTimeInlining-minimized._≡_
out >   arg1 = {(g : CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env
out >                     (CompileTimeInlining-minimized.Ctxt.snoc _88 (λ v -> _89 @0)))
out >                  (λ v ->
out >                     CompileTimeInlining-minimized.El
out >                       (CompileTimeInlining-minimized.U.el (_91 @0)))) ->
out >             CompileTimeInlining-minimized.U}
out >   arg2 = {(g : CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env
out >                     (CompileTimeInlining-minimized.Ctxt.snoc _96 _97))
out >                  (λ v -> CompileTimeInlining-minimized.El (_94 @0))) ->
out >             CompileTimeInlining-minimized.U}
out > { working on problems [221]
out > compareTerm
out >   (g
out >    : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >      (λ v → El (el (El (_s_94 v))))) →
out >   U = (g : Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))) → U
out >   : Set
out > compareTerm (not syntactically equal)
out >   (g
out >    : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >      (λ v → El (el (El (_s_94 v))))) →
out >   U = (g : Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))) → U
out >   : Set
out > { compareTerm
out > compareTerm
out > (g
out >  : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >    (λ v → El (el (El (_s_94 v))))) →
out > U
out > = (g : Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))) → U : Set
out > { compareAtom
out > compareAtom (g
out >              : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >                (λ v → El (el (El (_s_94 v))))) →
out >             U =
out >             (g : Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))) → U : Set
out > compareAtom (g
out >              : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >                (λ v → El (el (El (_s_94 v))))) →
out >             U =
out >             (g : Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))) → U : Set
out > { compare function types
out >   t1 = (g
out >         : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >           (λ v → El (el (El (_s_94 v))))) →
out >        U
out >   t2 = (g : Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))) → U
out > { working on problems [222]
out > { compareType
out > compareType Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v)) =
out >             Σ (Env (snoc _G_88 (λ v → _s_89 v))) (λ v → El (el (El (_s_94 v))))
out >    sorts: Set  and  Set
out > compareTerm
out >   Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v)) = Σ
out >                                                     (Env (snoc _G_88 (λ v → _s_89 v)))
out >                                                     (λ v → El (el (El (_s_94 v))))
out >   
out > compareTerm (not syntactically equal)
out >   Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v)) = Σ
out >                                                     (Env (snoc _G_88 (λ v → _s_89 v)))
out >                                                     (λ v → El (el (El (_s_94 v))))
out >   
out > { compareAtom
out > compareAtom Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v)) =
out >             Σ (Env (snoc _G_88 (λ v → _s_89 v))) (λ v → El (el (El (_s_94 v))))
out >             
out > compareAtom Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v)) =
out >             Σ (Env (snoc _G_88 (λ v → _s_89 v))) (λ v → El (el (El (_s_94 v))))
out >             
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env (snoc _G_96 _s_97), $ λ v → El (_s_94 v)]
out >   els02 = [$ Env (snoc _G_88 (λ v → _s_89 v)),
out >            $ λ v → El (el (El (_s_94 v)))]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env (snoc _G_96 _s_97)
out >   arg2 = Env (snoc _G_88 (λ v → _s_89 v))
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env
out >            (CompileTimeInlining-minimized.Ctxt.snoc _96 _97)
out >   arg2 = CompileTimeInlining-minimized.Env
out >            (CompileTimeInlining-minimized.Ctxt.snoc _88 (λ v -> _89 @0))
out > { working on problems [223]
out > compareTerm
out >   Env (snoc _G_96 _s_97) = Env (snoc _G_88 (λ v → _s_89 v))
out >   : Set
out > compareTerm (not syntactically equal)
out >   Env (snoc _G_96 _s_97) = Env (snoc _G_88 (λ v → _s_89 v))
out >   : Set
out > { compareTerm
out > compareTerm Env (snoc _G_96 _s_97) =
out > Env (snoc _G_88 (λ v → _s_89 v)) : Set
out > { compareAtom
out > compareAtom Env (snoc _G_96 _s_97) =
out >             Env (snoc _G_88 (λ v → _s_89 v)) : Set
out > compareAtom Σ (Env _G_96) (λ g → El (_s_97 g)) =
out >             Σ (Env _G_88) (λ g → El (_s_89 g)) : Set
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env _G_96, $ λ g → El (_s_97 g)]
out >   els02 = [$ Env _G_88, $ λ g → El (_s_89 g)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env _G_96
out >   arg2 = Env _G_88
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env _96
out >   arg2 = CompileTimeInlining-minimized.Env _88
out > { working on problems [224]
out > compareTerm Env _G_96 = Env _G_88 : Set
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 : Set
out > { compareTerm
out > compareTerm Env _G_96 = Env _G_88 : Set
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareAtom [ Env _G_96 ]_96 = [ Env _G_88 ]_88 : Set
out > compareTerm Env _G_96 = Env _G_88 : Set
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 : Set
out > { compareTerm
out > compareTerm Env _G_96 = Env _G_88 : Set
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareElims
out >   a     = Ctxt → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Env
out >   els01 = [$ _G_96]
out >   els02 = [$ _G_88]
out > { compare Apply
out >   a    = Ctxt → Set
out >   v    = Env
out >   arg1 = _G_96
out >   arg2 = _G_88
out >   raw:
out >   a    = CompileTimeInlining-minimized.Ctxt -> Set
out >   v    = CompileTimeInlining-minimized.Env
out >   arg1 = _96
out >   arg2 = _88
out > { working on problems [225]
out > compareTerm _G_96 = _G_88 : Ctxt
out > compareTerm (not syntactically equal) _G_96 = _G_88 : Ctxt
out > attempting shortcut _G_96 := _G_88
out > term _G_96 :DirEq _G_88
out > attempting shortcut _G_88 := _G_96
out > term _G_88 :DirEq _G_96
out > { compareTerm
out > compareTerm _G_96 = _G_88 : Ctxt
out > { compareAtom
out > compareAtom _G_96 = _G_88 : Ctxt
out > compareAtom _G_96 = _G_88 : Ctxt
out > term _G_96 :DirEq _G_88
out > term _G_88 :DirEq _G_96
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > problem 224 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = Env _G_96
out >   arg2 = Env _G_88
out > antiUnify
out > a = Set
out > u = Env _G_96
out > v = Env _G_88
out > antiUnify
out > a = Ctxt
out > u = _G_96
out > v = _G_88
out > blocked _116 := λ u → _G_96
out >      by [[199, 214, 219, 220, 221, 222, 223, 224] Env _G_96
out >                                                     = Env _G_88
out >                                                     : Set]
out > new meta (ConcreteDef): [u] |-
out >   _117 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U) → Ctxt
out > setting twin of _117 to be _116
out > Anti-unification: Env _117
out > compareElims
out >   a     = (B : Env _117 → Set) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env _117)
out >   els01 = [$ λ g → El (_s_97 g)]
out >   els02 = [$ λ g → El (_s_89 g)]
out > { compare Apply
out >   a    = (B : Env _117 → Set) → Set
out >   v    = Σ (Env _117)
out >   arg1 = λ g → El (_s_97 g)
out >   arg2 = λ g → El (_s_89 g)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env (_117 @0) -> Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env (_117 @0))
out >   arg1 = λ g -> CompileTimeInlining-minimized.El (_97 @0)
out >   arg2 = λ g -> CompileTimeInlining-minimized.El (_89 @0)
out > { working on problems [225]
out > compareTerm
out >   λ g → El (_s_97 g) = λ g → El (_s_89 g)
out >   : Env _117 → Set
out > compareTerm (not syntactically equal)
out >   λ g → El (_s_97 g) = λ g → El (_s_89 g)
out >   : Env _117 → Set
out > { compareTerm
out > compareTerm λ g → El (_s_97 g) = λ g → El (_s_89 g) :
out > Env _117 → Set
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_97 g) = El (_s_89 g)
out >   : Set
out > { compareTerm
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > { compareAtom
out > compareAtom El (_s_97 g) = El (_s_89 g) : Set
out > compareAtom [ El (_s_97 g) ]_97 = [ El (_s_89 g) ]_89 : Set
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_97 g) = El (_s_89 g)
out >   : Set
out > { compareTerm
out > compareTerm El (_s_97 g) = El (_s_89 g) : Set
out > { compareAtom
out > compareAtom El (_s_97 g) = El (_s_89 g) : Set
out > compareAtom El (_s_97 g) = El (_s_89 g) : Set
out > compareElims
out >   a     = U → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = El
out >   els01 = [$ _s_97 g]
out >   els02 = [$ _s_89 g]
out > { compare Apply
out >   a    = U → Set
out >   v    = El
out >   arg1 = _s_97 g
out >   arg2 = _s_89 g
out >   raw:
out >   a    = CompileTimeInlining-minimized.U -> Set
out >   v    = CompileTimeInlining-minimized.El
out >   arg1 = _97 @0
out >   arg2 = _89 @0
out > { working on problems [226]
out > compareTerm _s_97 g = _s_89 g : U
out > compareTerm (not syntactically equal) _s_97 g = _s_89 g : U
out > attempting shortcut _s_97 g := _s_89 g
out > term _s_97 g :DirEq _s_89 g
out > attempting shortcut _s_89 g := _s_97 g
out > term _s_89 g :DirEq _s_97 g
out > { compareTerm
out > compareTerm _s_97 g = _s_89 g : U
out > { compareAtom
out > compareAtom _s_97 g = _s_89 g : U
out > compareAtom _s_97 g = _s_89 g : U
out > term _s_97 g :DirEq _s_89 g
out > term _s_89 g :DirEq _s_97 g
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > }
out > problem 225 was not solved.
out > }
out > }
out > }
out > }
out > }
out > problem 223 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = Env (snoc _G_96 _s_97)
out >   arg2 = Env (snoc _G_88 (λ v → _s_89 v))
out > antiUnify
out > a = Set
out > u = Σ (Env _G_96) (λ g → El (_s_97 g))
out > v = Σ (Env _G_88) (λ g → El (_s_89 g))
out > antiUnify
out > a = Set
out > u = Env _G_96
out > v = Env _G_88
out > antiUnify
out > a = Ctxt
out > u = _G_96
out > v = _G_88
out > blocked _118 := λ u → _G_96
out >      by [[199, 214, 219, 220, 221, 222, 223, 225] El (_s_97 g)
out >                                                     = El (_s_89 g)
out >                                                     : Set,
out >          [199, 214, 219, 220, 221, 222, 223] _116 := λ u → _G_96
out >                                                [blocked on problem 224],
out >          [199, 214, 219, 220, 221, 222, 223, 224] Env _G_96 = Env _G_88
out >                                                     : Set]
out > new meta (ConcreteDef): [u] |-
out >   _119 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U) → Ctxt
out > setting twin of _119 to be _118
out > antiUnify
out > a = Env _119 → Set
out > u = λ g → El (_s_97 g)
out > v = λ g → El (_s_89 g)
out > antiUnify
out > a = Set
out > u = El (_s_97 _)
out > v = El (_s_89 _)
out > antiUnify
out > a = U
out > u = _s_97 _
out > v = _s_89 _
out > blocked _120 := λ u z → _s_97 z
out >      by [[199, 214, 219, 220, 221, 222, 223, 225] El (_s_97 g)
out >                                                     = El (_s_89 g)
out >                                                     : Set,
out >          [199, 214, 219, 220, 221, 222, 223] _116 := λ u → _G_96
out >                                                [blocked on problem 224],
out >          [199, 214, 219, 220, 221, 222, 223, 224] Env _G_96 = Env _G_88
out >                                                     : Set]
out > new meta (ConcreteDef): [u, _] |-
out >   _121 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >          (_ : Env (_119 (u = u₁))) →
out >          U
out > setting twin of _121 to be _120
out > Anti-unification: Σ (Env _119) (λ g → El (_121 (u = u) (_ = g)))
out > compareElims
out >   a     = (B
out >            : Σ (Env _119) (λ g → El (_121 (u = u) (_ = g))) → Set) →
out >           Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Σ (Env _119) (λ g → El (_121 (u = u) (_ = g))))
out >   els01 = [$ λ v → El (_s_94 v)]
out >   els02 = [$ λ v → El (el (El (_s_94 v)))]
out > { compare Apply
out >   a    = (B : Σ (Env _119) (λ g → El (_121 (u = u) (_ = g))) → Set) →
out >          Set
out >   v    = Σ (Σ (Env _119) (λ g → El (_121 (u = u) (_ = g))))
out >   arg1 = λ v → El (_s_94 v)
out >   arg2 = λ v → El (el (El (_s_94 v)))
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Σ
out >                 (CompileTimeInlining-minimized.Env (_119 @0))
out >                 (λ g -> CompileTimeInlining-minimized.El (_121 @1 @0)) ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Env (_119 @0))
out >               (λ g -> CompileTimeInlining-minimized.El (_121 @1 @0)))
out >   arg1 = λ v -> CompileTimeInlining-minimized.El (_94 @0)
out >   arg2 = λ v ->
out >            CompileTimeInlining-minimized.El
out >              (CompileTimeInlining-minimized.U.el (_91 @0))
out > { working on problems [226]
out > compareTerm
out >   λ v → El (_s_94 v) = λ v → El (el (El (_s_94 v)))
out >   : Σ (Env _119) (λ g → El (_121 (u = u) (_ = g))) → Set
out > compareTerm (not syntactically equal)
out >   λ v → El (_s_94 v) = λ v → El (el (El (_s_94 v)))
out >   : Σ (Env _119) (λ g → El (_121 (u = u) (_ = g))) → Set
out > { compareTerm
out > compareTerm λ v → El (_s_94 v) = λ v → El (el (El (_s_94 v))) :
out > Σ (Env _119) (λ g → El (_121 (u = u) (_ = g))) → Set
out > compareTerm El (_s_94 v) = El (el (El (_s_94 v))) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_94 v) = El (el (El (_s_94 v)))
out >   : Set
out > { compareTerm
out > compareTerm El (_s_94 v) = El (el (El (_s_94 v))) : Set
out > { compareAtom
out > compareAtom El (_s_94 v) = El (el (El (_s_94 v))) : Set
out > compareAtom [ El (_s_94 v) ]_94 = [ El (_s_94 v) ]_94 : Set
out > compareTerm El (_s_94 v) = El (_s_94 v) : Set
out > runPureConversion result: Right ()
out > }
out > }
out > }
out > problem 226 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 222 was not solved.
out > }
out > { compareType
out > compareType U = U
out >    sorts: Set  and  Set
out > compareTerm U = U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > }
out > problem 221 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = {_}
out >   arg2 = {_}
out > antiUnify
out > a = Set
out > u = (g
out >      : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >        (λ v → El (el (El (_s_94 v))))) →
out >     U
out > v = (g : Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))) → U
out > antiUnify
out > a = Set
out > u = Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >     (λ v → El (el (El (_s_94 v))))
out > v = Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))
out > antiUnify
out > a = Set
out > u = Σ (Env _G_88) (λ g → El (_s_89 g))
out > v = Σ (Env _G_96) (λ g → El (_s_97 g))
out > antiUnify
out > a = Set
out > u = Env _G_88
out > v = Env _G_96
out > antiUnify
out > a = Ctxt
out > u = _G_88
out > v = _G_96
out > blocked _122 := λ u → _G_88
out >      by [[199, 214, 219, 220, 221, 222] _120 := λ u z → _s_97 z
out >                                           [blocked on problem 223],
out >          [199, 214, 219, 220, 221, 222] _118 := λ u → _G_96
out >                                           [blocked on problem 223],
out >          [199, 214, 219, 220, 221, 222, 223, 225] El (_s_97 g)
out >                                                     = El (_s_89 g)
out >                                                     : Set,
out >          [199, 214, 219, 220, 221, 222, 223] _116 := λ u → _G_96
out >                                                [blocked on problem 224],
out >          [199, 214, 219, 220, 221, 222, 223, 224] Env _G_96 = Env _G_88
out >                                                     : Set]
out > new meta (ConcreteDef): [u] |-
out >   _123 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U) → Ctxt
out > setting twin of _123 to be _122
out > antiUnify
out > a = Env _123 → Set
out > u = λ g → El (_s_89 g)
out > v = λ g → El (_s_97 g)
out > antiUnify
out > a = Set
out > u = El (_s_89 _)
out > v = El (_s_97 _)
out > antiUnify
out > a = U
out > u = _s_89 _
out > v = _s_97 _
out > blocked _124 := λ u z → _s_89 z
out >      by [[199, 214, 219, 220, 221, 222] _120 := λ u z → _s_97 z
out >                                           [blocked on problem 223],
out >          [199, 214, 219, 220, 221, 222] _118 := λ u → _G_96
out >                                           [blocked on problem 223],
out >          [199, 214, 219, 220, 221, 222, 223, 225] El (_s_97 g)
out >                                                     = El (_s_89 g)
out >                                                     : Set,
out >          [199, 214, 219, 220, 221, 222, 223] _116 := λ u → _G_96
out >                                                [blocked on problem 224],
out >          [199, 214, 219, 220, 221, 222, 223, 224] Env _G_96 = Env _G_88
out >                                                     : Set]
out > new meta (ConcreteDef): [u, _] |-
out >   _125 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >          (_ : Env (_123 (u = u₁))) →
out >          U
out > setting twin of _125 to be _124
out > antiUnify
out > a = Σ (Env _123) (λ g → El (_125 (u = u) (_ = g))) → Set
out > u = λ v → El (el (El (_s_94 v)))
out > v = λ v → El (_s_94 v)
out > antiUnify
out > a = Set
out > u = El (_s_94 _)
out > v = El (_s_94 _)
out > Anti-unification: {_}
out > compareElims
out >   a     = (Σ (Σ (Env _123) (λ g → El (_125 (u = u) (_ = g))))
out >            (λ v → El (_s_94 v)) →
out >            U) →
out >           (Σ (Σ (Env _123) (λ g → El (_125 (u = u) (_ = g))))
out >            (λ v → El (_s_94 v)) →
out >            U) →
out >           Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_
out >   els01 = [$ λ g → u (fst g), $ λ g → el Set]
out >   els02 = [$ λ g → u (fst g), $ λ _ → el Set]
out > { compare Apply
out >   a    = (Σ (Σ (Env _123) (λ g → El (_125 (u = u) (_ = g))))
out >           (λ v → El (_s_94 v)) →
out >           U) →
out >          (Σ (Σ (Env _123) (λ g → El (_125 (u = u) (_ = g))))
out >           (λ v → El (_s_94 v)) →
out >           U) →
out >          Set
out >   v    = _≡_
out >   arg1 = λ g → u (fst g)
out >   arg2 = λ g → u (fst g)
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Σ
out >             (CompileTimeInlining-minimized.Σ
out >                (CompileTimeInlining-minimized.Env (_123 @0))
out >                (λ g -> CompileTimeInlining-minimized.El (_125 @1 @0)))
out >             (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >             CompileTimeInlining-minimized.U) ->
out >            (CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env (_123 @0))
out >                  (λ g -> CompileTimeInlining-minimized.El (_125 @1 @0)))
out >               (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >               CompileTimeInlining-minimized.U) ->
out >              Set
out >   v    = CompileTimeInlining-minimized._≡_
out >            {CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env (_123 @0))
out >                  (λ g -> CompileTimeInlining-minimized.El (_125 @1 @0)))
out >               (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >               CompileTimeInlining-minimized.U}
out >   arg1 = λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)
out >   arg2 = λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)
out > { working on problems [227]
out > compareTerm
out >   λ g → u (fst g) = λ g → u (fst g)
out >   : Σ (Σ (Env _123) (λ g → El (_125 (u = u) (_ = g))))
out >     (λ v → El (_s_94 v)) →
out >     U
out > problem 227 was solved!
out > }
out > compareElims
out >   a     = (Σ (Σ (Env _123) (λ g → El (_125 (u = u) (_ = g))))
out >            (λ v → El (_s_94 v)) →
out >            U) →
out >           Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_ (λ g → u (fst g))
out >   els01 = [$ λ g → el Set]
out >   els02 = [$ λ _ → el Set]
out > { compare Apply
out >   a    = (Σ (Σ (Env _123) (λ g → El (_125 (u = u) (_ = g))))
out >           (λ v → El (_s_94 v)) →
out >           U) →
out >          Set
out >   v    = _≡_ (λ g → u (fst g))
out >   arg1 = λ g → el Set
out >   arg2 = λ _ → el Set
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Σ
out >             (CompileTimeInlining-minimized.Σ
out >                (CompileTimeInlining-minimized.Env (_123 @0))
out >                (λ g -> CompileTimeInlining-minimized.El (_125 @1 @0)))
out >             (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >             CompileTimeInlining-minimized.U) ->
out >            Set
out >   v    = CompileTimeInlining-minimized._≡_
out >            {CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env (_123 @0))
out >                  (λ g -> CompileTimeInlining-minimized.El (_125 @1 @0)))
out >               (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >   arg1 = λ g -> _92 (@0 .CompileTimeInlining-minimized.Σ.fst)
out >   arg2 = λ _ -> CompileTimeInlining-minimized.U.el Set
out > { working on problems [228]
out > compareTerm
out >   λ g → el Set = λ _ → el Set
out >   : Σ (Σ (Env _123) (λ g → El (_125 (u = u) (_ = g))))
out >     (λ v → El (_s_94 v)) →
out >     U
out > problem 228 was solved!
out > }
out > }
out > }
out > }
out > }
out > }
out > problem 220 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = (λ g → u (fst g)) ≡ (λ g → el Set)
out >   arg2 = (λ g → u (fst g)) ≡ (λ _ → el Set)
out > antiUnify
out > a = Set
out > u = (λ g → u (fst g)) ≡ (λ g → el Set)
out > v = (λ g → u (fst g)) ≡ (λ _ → el Set)
out > antiUnify
out > a = Set
out > u = (g
out >      : Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >        (λ v → El (el (El (_s_94 v))))) →
out >     U
out > v = (g : Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))) → U
out > antiUnify
out > a = Set
out > u = Σ (Env (snoc _G_88 (λ v → _s_89 v)))
out >     (λ v → El (el (El (_s_94 v))))
out > v = Σ (Env (snoc _G_96 _s_97)) (λ v → El (_s_94 v))
out > antiUnify
out > a = Set
out > u = Σ (Env _G_88) (λ g → El (_s_89 g))
out > v = Σ (Env _G_96) (λ g → El (_s_97 g))
out > antiUnify
out > a = Set
out > u = Env _G_88
out > v = Env _G_96
out > antiUnify
out > a = Ctxt
out > u = _G_88
out > v = _G_96
out > blocked _126 := λ u → _G_88
out >      by [[199, 214, 219, 220] _124 := λ u z → _s_89 z
out >                                 [blocked on problem 221],
out >          [199, 214, 219, 220] _122 := λ u → _G_88 [blocked on problem 221],
out >          [199, 214, 219, 220, 221, 222] _120 := λ u z → _s_97 z
out >                                           [blocked on problem 223],
out >          [199, 214, 219, 220, 221, 222] _118 := λ u → _G_96
out >                                           [blocked on problem 223],
out >          [199, 214, 219, 220, 221, 222, 223, 225] El (_s_97 g)
out >                                                     = El (_s_89 g)
out >                                                     : Set,
out >          [199, 214, 219, 220, 221, 222, 223] _116 := λ u → _G_96
out >                                                [blocked on problem 224],
out >          [199, 214, 219, 220, 221, 222, 223, 224] Env _G_96 = Env _G_88
out >                                                     : Set]
out > new meta (ConcreteDef): [u] |-
out >   _127 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U) → Ctxt
out > setting twin of _127 to be _126
out > antiUnify
out > a = Env _127 → Set
out > u = λ g → El (_s_89 g)
out > v = λ g → El (_s_97 g)
out > antiUnify
out > a = Set
out > u = El (_s_89 _)
out > v = El (_s_97 _)
out > antiUnify
out > a = U
out > u = _s_89 _
out > v = _s_97 _
out > blocked _128 := λ u z → _s_89 z
out >      by [[199, 214, 219, 220] _124 := λ u z → _s_89 z
out >                                 [blocked on problem 221],
out >          [199, 214, 219, 220] _122 := λ u → _G_88 [blocked on problem 221],
out >          [199, 214, 219, 220, 221, 222] _120 := λ u z → _s_97 z
out >                                           [blocked on problem 223],
out >          [199, 214, 219, 220, 221, 222] _118 := λ u → _G_96
out >                                           [blocked on problem 223],
out >          [199, 214, 219, 220, 221, 222, 223, 225] El (_s_97 g)
out >                                                     = El (_s_89 g)
out >                                                     : Set,
out >          [199, 214, 219, 220, 221, 222, 223] _116 := λ u → _G_96
out >                                                [blocked on problem 224],
out >          [199, 214, 219, 220, 221, 222, 223, 224] Env _G_96 = Env _G_88
out >                                                     : Set]
out > new meta (ConcreteDef): [u, _] |-
out >   _129 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >          (_ : Env (_127 (u = u₁))) →
out >          U
out > setting twin of _129 to be _128
out > antiUnify
out > a = Σ (Env _127) (λ g → El (_129 (u = u) (_ = g))) → Set
out > u = λ v → El (el (El (_s_94 v)))
out > v = λ v → El (_s_94 v)
out > antiUnify
out > a = Set
out > u = El (_s_94 _)
out > v = El (_s_94 _)
out > Anti-unification: (λ g → u (fst g)) ≡ (λ g → el Set)
out > compareElims
out >   a     = (B : (λ g → u (fst g)) ≡ (λ g → el Set) → Set) → Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >   els01 = [$ λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u]
out >   els02 = [$ λ _ → Var (snoc _G_96 _s_97) u]
out > { compare Apply
out >   a    = (B : (λ g → u (fst g)) ≡ (λ g → el Set) → Set) → Set
out >   v    = Σ ((λ g → u (fst g)) ≡ (λ g → el Set))
out >   arg1 = λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u
out >   arg2 = λ _ → Var (snoc _G_96 _s_97) u
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized._≡_
out >                 {CompileTimeInlining-minimized.Σ
out >                    (CompileTimeInlining-minimized.Σ
out >                       (CompileTimeInlining-minimized.Env (_127 @0))
out >                       (λ g -> CompileTimeInlining-minimized.El (_129 @1 @0)))
out >                    (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >                    CompileTimeInlining-minimized.U}
out >                 (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >                 (λ g -> CompileTimeInlining-minimized.U.el Set) ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized._≡_
out >               {CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Σ
out >                     (CompileTimeInlining-minimized.Env (_127 @0))
out >                     (λ g -> CompileTimeInlining-minimized.El (_129 @1 @0)))
out >                  (λ v -> CompileTimeInlining-minimized.El (_94 @0)) ->
out >                  CompileTimeInlining-minimized.U}
out >               (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >               (λ g -> CompileTimeInlining-minimized.U.el Set))
out >   arg1 = λ _ -> CompileTimeInlining-minimized.Var _83 @1
out >   arg2 = λ _ -> CompileTimeInlining-minimized.Var _93 @1
out > { working on problems [229]
out > compareTerm
out >   λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u =< λ _ →
out >                                                 Var (snoc _G_96 _s_97) u
out >   : (λ g → u (fst g)) ≡ (λ g → el Set) → Set
out > compareTerm (not syntactically equal)
out >   λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u =< λ _ →
out >                                                 Var (snoc _G_96 _s_97) u
out >   : (λ g → u (fst g)) ≡ (λ g → el Set) → Set
out > { compareTerm
out > compareTerm λ _ → Var (snoc _G_88 (λ v → _s_89 v)) u =<
out > λ _ → Var (snoc _G_96 _s_97) u :
out > (λ g → u (fst g)) ≡ (λ g → el Set) → Set
out > compareTerm
out >   Var (snoc _G_88 (λ v → _s_89 v)) u =< Var (snoc _G_96 _s_97) u
out >   : Set
out > compareTerm (not syntactically equal)
out >   Var (snoc _G_88 (λ v → _s_89 v)) u =< Var (snoc _G_96 _s_97) u
out >   : Set
out > { compareTerm
out > compareTerm Var (snoc _G_88 (λ v → _s_89 v)) u =<
out > Var (snoc _G_96 _s_97) u : Set
out > { compareAtom
out > compareAtom Var (snoc _G_88 (λ v → _s_89 v)) u =<
out >             Var (snoc _G_96 _s_97) u : Set
out > compareAtom Either ((λ g → _s_89 (fst g)) ≡ u)
out >             (Σ (Env _G_88 → U)
out >              (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁))) =<
out >             Either ((λ g → _s_97 (fst g)) ≡ u)
out >             (Σ (Env _G_96 → U)
out >              (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁)))
out >             : Set
out > compareElims
out >   a     = Set → Set → Set
out >   pols0 (truncated to 10) = Covariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Either
out >   els01 = [$ (λ g → _s_89 (fst g)) ≡ u,
out >            $ Σ (Env _G_88 → U)
out >              (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁))]
out >   els02 = [$ (λ g → _s_97 (fst g)) ≡ u,
out >            $ Σ (Env _G_96 → U)
out >              (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁))]
out > { compare Apply
out >   a    = Set → Set → Set
out >   v    = Either
out >   arg1 = (λ g → _s_89 (fst g)) ≡ u
out >   arg2 = (λ g → _s_97 (fst g)) ≡ u
out >   raw:
out >   a    = Set -> Set -> Set
out >   v    = CompileTimeInlining-minimized.Either
out >   arg1 = CompileTimeInlining-minimized._≡_
out >            {(g : CompileTimeInlining-minimized.Σ
out >                    (CompileTimeInlining-minimized.Env _88)
out >                    (λ v -> CompileTimeInlining-minimized.El (_89 @0))) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g -> _89 (@0 .CompileTimeInlining-minimized.Σ.fst)) @1
out >   arg2 = CompileTimeInlining-minimized._≡_
out >            {(g : CompileTimeInlining-minimized.Σ
out >                    (CompileTimeInlining-minimized.Env _96)
out >                    (λ v -> CompileTimeInlining-minimized.El (_97 @0))) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g -> _97 (@0 .CompileTimeInlining-minimized.Σ.fst)) @1
out > { working on problems [230]
out > compareTerm
out >   (λ g → _s_89 (fst g)) ≡ u =< (λ g → _s_97 (fst g)) ≡ u
out >   : Set
out > compareTerm (not syntactically equal)
out >   (λ g → _s_89 (fst g)) ≡ u =< (λ g → _s_97 (fst g)) ≡ u
out >   : Set
out > { compareTerm
out > compareTerm (λ g → _s_89 (fst g)) ≡ u =< (λ g → _s_97 (fst g)) ≡ u
out > : Set
out > { compareAtom
out > compareAtom (λ g → _s_89 (fst g)) ≡ u =< (λ g → _s_97 (fst g)) ≡ u
out >             : Set
out > compareAtom (λ g → _s_89 (fst g)) ≡ u =< (λ g → _s_97 (fst g)) ≡ u
out >             : Set
out > compareElims
out >   a     = {A : Set} → A → A → Set
out >   pols0 (truncated to 10) = Invariant Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_
out >   els01 = [$ {_}, $ λ g → _s_89 (fst g), $ u]
out >   els02 = [$ {_}, $ λ g → _s_97 (fst g), $ u]
out > { compare Apply
out >   a    = {A : Set} → A → A → Set
out >   v    = _≡_
out >   arg1 = {_}
out >   arg2 = {_}
out >   raw:
out >   a    = {A : Set} -> @0 -> @0 -> Set
out >   v    = CompileTimeInlining-minimized._≡_
out >   arg1 = {(g : CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env _88)
out >                  (λ v -> CompileTimeInlining-minimized.El (_89 @0))) ->
out >             CompileTimeInlining-minimized.U}
out >   arg2 = {(g : CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env _96)
out >                  (λ v -> CompileTimeInlining-minimized.El (_97 @0))) ->
out >             CompileTimeInlining-minimized.U}
out > { working on problems [231]
out > compareTerm
out >   (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U = (g
out >                                                   : Σ (Env _G_96) (λ v → El (_s_97 v))) →
out >                                                  U
out >   : Set
out > compareTerm (not syntactically equal)
out >   (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U = (g
out >                                                   : Σ (Env _G_96) (λ v → El (_s_97 v))) →
out >                                                  U
out >   : Set
out > { compareTerm
out > compareTerm (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U =
out > (g : Σ (Env _G_96) (λ v → El (_s_97 v))) → U : Set
out > { compareAtom
out > compareAtom (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U =
out >             (g : Σ (Env _G_96) (λ v → El (_s_97 v))) → U : Set
out > compareAtom (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U =
out >             (g : Σ (Env _G_96) (λ v → El (_s_97 v))) → U : Set
out > { compare function types
out >   t1 = (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U
out >   t2 = (g : Σ (Env _G_96) (λ v → El (_s_97 v))) → U
out > { working on problems [232]
out > { compareType
out > compareType Σ (Env _G_96) (λ v → El (_s_97 v)) =
out >             Σ (Env _G_88) (λ v → El (_s_89 v))
out >    sorts: Set  and  Set
out > compareTerm
out >   Σ (Env _G_96) (λ v → El (_s_97 v)) = Σ (Env _G_88)
out >                                        (λ v → El (_s_89 v))
out >   
out > compareTerm (not syntactically equal)
out >   Σ (Env _G_96) (λ v → El (_s_97 v)) = Σ (Env _G_88)
out >                                        (λ v → El (_s_89 v))
out >   
out > { compareAtom
out > compareAtom Σ (Env _G_96) (λ v → El (_s_97 v)) =
out >             Σ (Env _G_88) (λ v → El (_s_89 v)) 
out > compareAtom Σ (Env _G_96) (λ v → El (_s_97 v)) =
out >             Σ (Env _G_88) (λ v → El (_s_89 v)) 
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env _G_96, $ λ v → El (_s_97 v)]
out >   els02 = [$ Env _G_88, $ λ v → El (_s_89 v)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env _G_96
out >   arg2 = Env _G_88
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env _96
out >   arg2 = CompileTimeInlining-minimized.Env _88
out > { working on problems [233]
out > compareTerm Env _G_96 = Env _G_88 : Set
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 : Set
out > { compareTerm
out > compareTerm Env _G_96 = Env _G_88 : Set
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareAtom [ Env _G_96 ]_96 = [ Env _G_88 ]_88 : Set
out > compareTerm Env _G_96 = Env _G_88 : Set
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 : Set
out > { compareTerm
out > compareTerm Env _G_96 = Env _G_88 : Set
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareElims
out >   a     = Ctxt → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Env
out >   els01 = [$ _G_96]
out >   els02 = [$ _G_88]
out > { compare Apply
out >   a    = Ctxt → Set
out >   v    = Env
out >   arg1 = _G_96
out >   arg2 = _G_88
out >   raw:
out >   a    = CompileTimeInlining-minimized.Ctxt -> Set
out >   v    = CompileTimeInlining-minimized.Env
out >   arg1 = _96
out >   arg2 = _88
out > { working on problems [234]
out > compareTerm _G_96 = _G_88 : Ctxt
out > compareTerm (not syntactically equal) _G_96 = _G_88 : Ctxt
out > attempting shortcut _G_96 := _G_88
out > term _G_96 :DirEq _G_88
out > attempting shortcut _G_88 := _G_96
out > term _G_88 :DirEq _G_96
out > { compareTerm
out > compareTerm _G_96 = _G_88 : Ctxt
out > { compareAtom
out > compareAtom _G_96 = _G_88 : Ctxt
out > compareAtom _G_96 = _G_88 : Ctxt
out > term _G_96 :DirEq _G_88
out > term _G_88 :DirEq _G_96
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > problem 233 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = Env _G_96
out >   arg2 = Env _G_88
out > antiUnify
out > a = Set
out > u = Env _G_96
out > v = Env _G_88
out > antiUnify
out > a = Ctxt
out > u = _G_96
out > v = _G_88
out > blocked _130 := λ u x → _G_96
out >      by [[199, 214, 219, 229, 230, 231, 232, 233] Env _G_96
out >                                                     = Env _G_88
out >                                                     : Set]
out > new meta (ConcreteDef): [u, x] |-
out >   _131 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >          (x₁ : (λ g → u₁ (fst g)) ≡ (λ g → el Set)) →
out >          Ctxt
out > setting twin of _131 to be _130
out > Anti-unification: Env _131
out > compareElims
out >   a     = (B : Env _131 → Set) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env _131)
out >   els01 = [$ λ v → El (_s_97 v)]
out >   els02 = [$ λ v → El (_s_89 v)]
out > { compare Apply
out >   a    = (B : Env _131 → Set) → Set
out >   v    = Σ (Env _131)
out >   arg1 = λ v → El (_s_97 v)
out >   arg2 = λ v → El (_s_89 v)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env (_131 @1 @0) ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env (_131 @1 @0))
out >   arg1 = λ v -> CompileTimeInlining-minimized.El (_97 @0)
out >   arg2 = λ v -> CompileTimeInlining-minimized.El (_89 @0)
out > { working on problems [234]
out > compareTerm
out >   λ v → El (_s_97 v) = λ v → El (_s_89 v)
out >   : Env _131 → Set
out > compareTerm (not syntactically equal)
out >   λ v → El (_s_97 v) = λ v → El (_s_89 v)
out >   : Env _131 → Set
out > { compareTerm
out > compareTerm λ v → El (_s_97 v) = λ v → El (_s_89 v) :
out > Env _131 → Set
out > compareTerm El (_s_97 v) = El (_s_89 v) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_97 v) = El (_s_89 v)
out >   : Set
out > { compareTerm
out > compareTerm El (_s_97 v) = El (_s_89 v) : Set
out > { compareAtom
out > compareAtom El (_s_97 v) = El (_s_89 v) : Set
out > compareAtom [ El (_s_97 v) ]_97 = [ El (_s_89 v) ]_89 : Set
out > compareTerm El (_s_97 v) = El (_s_89 v) : Set
out > compareTerm (not syntactically equal)
out >   El (_s_97 v) = El (_s_89 v)
out >   : Set
out > { compareTerm
out > compareTerm El (_s_97 v) = El (_s_89 v) : Set
out > { compareAtom
out > compareAtom El (_s_97 v) = El (_s_89 v) : Set
out > compareAtom El (_s_97 v) = El (_s_89 v) : Set
out > compareElims
out >   a     = U → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = El
out >   els01 = [$ _s_97 v]
out >   els02 = [$ _s_89 v]
out > { compare Apply
out >   a    = U → Set
out >   v    = El
out >   arg1 = _s_97 v
out >   arg2 = _s_89 v
out >   raw:
out >   a    = CompileTimeInlining-minimized.U -> Set
out >   v    = CompileTimeInlining-minimized.El
out >   arg1 = _97 @0
out >   arg2 = _89 @0
out > { working on problems [235]
out > compareTerm _s_97 v = _s_89 v : U
out > compareTerm (not syntactically equal) _s_97 v = _s_89 v : U
out > attempting shortcut _s_97 v := _s_89 v
out > term _s_97 v :DirEq _s_89 v
out > attempting shortcut _s_89 v := _s_97 v
out > term _s_89 v :DirEq _s_97 v
out > { compareTerm
out > compareTerm _s_97 v = _s_89 v : U
out > { compareAtom
out > compareAtom _s_97 v = _s_89 v : U
out > compareAtom _s_97 v = _s_89 v : U
out > term _s_97 v :DirEq _s_89 v
out > term _s_89 v :DirEq _s_97 v
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > }
out > problem 234 was not solved.
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 232 was not solved.
out > }
out > { compareType
out > compareType U = U
out >    sorts: Set  and  Set
out > compareTerm U = U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > }
out > problem 231 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = {_}
out >   arg2 = {_}
out > antiUnify
out > a = Set
out > u = (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U
out > v = (g : Σ (Env _G_96) (λ v → El (_s_97 v))) → U
out > antiUnify
out > a = Set
out > u = Σ (Env _G_88) (λ v → El (_s_89 v))
out > v = Σ (Env _G_96) (λ v → El (_s_97 v))
out > antiUnify
out > a = Set
out > u = Env _G_88
out > v = Env _G_96
out > antiUnify
out > a = Ctxt
out > u = _G_88
out > v = _G_96
out > blocked _132 := λ u x → _G_88
out >      by [[199, 214, 219, 229, 230, 231, 232, 234] El (_s_97 v)
out >                                                     = El (_s_89 v)
out >                                                     : Set,
out >          [199, 214, 219, 229, 230, 231, 232] _130 := λ u x → _G_96
out >                                                [blocked on problem 233],
out >          [199, 214, 219, 229, 230, 231, 232, 233] Env _G_96 = Env _G_88
out >                                                     : Set]
out > new meta (ConcreteDef): [u, x] |-
out >   _133 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >          (x₁ : (λ g → u₁ (fst g)) ≡ (λ g → el Set)) →
out >          Ctxt
out > setting twin of _133 to be _132
out > antiUnify
out > a = Env _133 → Set
out > u = λ v → El (_s_89 v)
out > v = λ v → El (_s_97 v)
out > antiUnify
out > a = Set
out > u = El (_s_89 _)
out > v = El (_s_97 _)
out > antiUnify
out > a = U
out > u = _s_89 _
out > v = _s_97 _
out > blocked _134 := λ u x z → _s_89 z
out >      by [[199, 214, 219, 229, 230, 231, 232, 234] El (_s_97 v)
out >                                                     = El (_s_89 v)
out >                                                     : Set,
out >          [199, 214, 219, 229, 230, 231, 232] _130 := λ u x → _G_96
out >                                                [blocked on problem 233],
out >          [199, 214, 219, 229, 230, 231, 232, 233] Env _G_96 = Env _G_88
out >                                                     : Set]
out > new meta (ConcreteDef): [u, x, _] |-
out >   _135 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >          (x₁ : (λ g → u₁ (fst g)) ≡ (λ g → el Set))
out >          (_ : Env (_133 (u = u₁) (x = x₁))) →
out >          U
out > setting twin of _135 to be _134
out > Anti-unification: {_}
out > compareElims
out >   a     = (Σ (Env _133) (λ v → El (_135 (u = u) (x = x) (_ = v))) →
out >            U) →
out >           (Σ (Env _133) (λ v → El (_135 (u = u) (x = x) (_ = v))) → U) → Set
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_
out >   els01 = [$ λ g → _s_89 (fst g), $ u]
out >   els02 = [$ λ g → _s_97 (fst g), $ u]
out > { compare Apply
out >   a    = (Σ (Env _133) (λ v → El (_135 (u = u) (x = x) (_ = v))) →
out >           U) →
out >          (Σ (Env _133) (λ v → El (_135 (u = u) (x = x) (_ = v))) → U) → Set
out >   v    = _≡_
out >   arg1 = λ g → _s_89 (fst g)
out >   arg2 = λ g → _s_97 (fst g)
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Σ
out >             (CompileTimeInlining-minimized.Env (_133 @1 @0))
out >             (λ v -> CompileTimeInlining-minimized.El (_135 @2 @1 @0)) ->
out >             CompileTimeInlining-minimized.U) ->
out >            (CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Env (_133 @1 @0))
out >               (λ v -> CompileTimeInlining-minimized.El (_135 @2 @1 @0)) ->
out >               CompileTimeInlining-minimized.U) ->
out >              Set
out >   v    = CompileTimeInlining-minimized._≡_
out >            {CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Env (_133 @1 @0))
out >               (λ v -> CompileTimeInlining-minimized.El (_135 @2 @1 @0)) ->
out >               CompileTimeInlining-minimized.U}
out >   arg1 = λ g -> _89 (@0 .CompileTimeInlining-minimized.Σ.fst)
out >   arg2 = λ g -> _97 (@0 .CompileTimeInlining-minimized.Σ.fst)
out > { working on problems [235]
out > compareTerm
out >   λ g → _s_89 (fst g) = λ g → _s_97 (fst g)
out >   : Σ (Env _133) (λ v → El (_135 (u = u) (x = x) (_ = v))) → U
out > compareTerm (not syntactically equal)
out >   λ g → _s_89 (fst g) = λ g → _s_97 (fst g)
out >   : Σ (Env _133) (λ v → El (_135 (u = u) (x = x) (_ = v))) → U
out > { compareTerm
out > compareTerm λ g → _s_89 (fst g) = λ g → _s_97 (fst g) :
out > Σ (Env _133) (λ v → El (_135 (u = u) (x = x) (_ = v))) → U
out > compareTerm _s_89 (fst g) = _s_97 (fst g) : U
out > compareTerm (not syntactically equal)
out >   _s_89 (fst g) = _s_97 (fst g)
out >   : U
out > attempting shortcut _s_97 (fst g) := _s_89 (fst g)
out > term _s_97 (fst g) :DirEq _s_89 (fst g)
out > term _s_97 (fst g) :DirEq _s_89 (fst g)
out > is _97 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _s_97
out >   _s_97  :  U := _s_89 x
out > elimView of  _s_89 x
out > v = MetaV (MetaId 89) [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 []})]
out > elimView (projections reduced) of  _s_89 x
out > elimView of  x
out > v = Var 0 []
out > elimView (projections reduced) of  x
out > { coerceSize
out > { compareType
out > compareType Env _G_96 =< Env _G_88
out >    sorts: Set  and  Set
out > compareTerm Env _G_96 =< Env _G_88 
out > compareTerm (not syntactically equal) Env _G_96 =< Env _G_88 
out > { compareAtom
out > compareAtom Env _G_96 =< Env _G_88 
out > compareAtom [ Env _G_96 ]_96 =< [ Env _G_88 ]_88 
out > compareTerm Env _G_96 = Env _G_88 
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 
out > compareAtom Env _G_96 = Env _G_88 
out > compareElims
out >   a     = Ctxt → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Env
out >   els01 = [$ _G_96]
out >   els02 = [$ _G_88]
out > { compare Apply
out >   a    = Ctxt → Set
out >   v    = Env
out >   arg1 = _G_96
out >   arg2 = _G_88
out >   raw:
out >   a    = CompileTimeInlining-minimized.Ctxt -> Set
out >   v    = CompileTimeInlining-minimized.Env
out >   arg1 = _96
out >   arg2 = _88
out > { working on problems [236]
out > compareTerm _G_96 = _G_88 : Ctxt
out > compareTerm (not syntactically equal) _G_96 = _G_88 : Ctxt
out > attempting shortcut _G_96 := _G_88
out > don't assign metas
out > attempting shortcut _G_88 := _G_96
out > don't assign metas
out > { compareTerm
out > compareTerm _G_96 = _G_88 : Ctxt
out > { compareAtom
out > compareAtom _G_96 = _G_88 : Ctxt
out > compareAtom _G_96 = _G_88 : Ctxt
out > don't assign metas
out > don't assign metas
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _s_97 := λ z → _s_89 z
out > shortcut successful
out >   result: _89 (@0 .CompileTimeInlining-minimized.Σ.fst)
out > }
out > problem 235 was not solved.
out > }
out > compareElims
out >   a     = (Σ (Env _133) (λ v → El (_135 (u = u) (x = x) (_ = v))) →
out >            U) →
out >           Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_ (λ g → _s_89 (fst g))
out >   els01 = [$ u]
out >   els02 = [$ u]
out > { compare Apply
out >   a    = (Σ (Env _133) (λ v → El (_135 (u = u) (x = x) (_ = v))) →
out >           U) →
out >          Set
out >   v    = _≡_ (λ g → _s_89 (fst g))
out >   arg1 = u
out >   arg2 = u
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Σ
out >             (CompileTimeInlining-minimized.Env (_133 @1 @0))
out >             (λ v -> CompileTimeInlining-minimized.El (_135 @2 @1 @0)) ->
out >             CompileTimeInlining-minimized.U) ->
out >            Set
out >   v    = CompileTimeInlining-minimized._≡_
out >            {CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Env (_133 @1 @0))
out >               (λ v -> CompileTimeInlining-minimized.El (_135 @2 @1 @0)) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g -> _89 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >   arg1 = @1
out >   arg2 = @1
out > { working on problems [236]
out > compareTerm
out >   u =< u
out >   : Σ (Env _133) (λ v → El (_135 (u = u) (x = x) (_ = v))) → U
out > problem 236 was solved!
out > }
out > }
out > }
out > }
out > }
out > }
out > problem 230 was not solved.
out > }
out > compareElims
out >   a     = Set → Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Either ((λ g → _s_89 (fst g)) ≡ u)
out >   els01 = [$ Σ (Env _G_88 → U)
out >              (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁))]
out >   els02 = [$ Σ (Env _G_96 → U)
out >              (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁))]
out > { compare Apply
out >   a    = Set → Set
out >   v    = Either ((λ g → _s_89 (fst g)) ≡ u)
out >   arg1 = Σ (Env _G_88 → U)
out >          (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁))
out >   arg2 = Σ (Env _G_96 → U)
out >          (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁))
out >   raw:
out >   a    = Set -> Set
out >   v    = CompileTimeInlining-minimized.Either
out >            (CompileTimeInlining-minimized._≡_
out >               {(g : CompileTimeInlining-minimized.Σ
out >                       (CompileTimeInlining-minimized.Env _88)
out >                       (λ v -> CompileTimeInlining-minimized.El (_89 @0))) ->
out >                  CompileTimeInlining-minimized.U}
out >               (λ g -> _89 (@0 .CompileTimeInlining-minimized.Σ.fst)) @1)
out >   arg1 = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env _88 ->
out >               CompileTimeInlining-minimized.U)
out >            (λ u ->
out >               CompileTimeInlining-minimized.Σ
out >                 (CompileTimeInlining-minimized._≡_
out >                    {(g : CompileTimeInlining-minimized.Σ
out >                            (CompileTimeInlining-minimized.Env _88)
out >                            (λ v -> CompileTimeInlining-minimized.El (_89 @0))) ->
out >                       CompileTimeInlining-minimized.U}
out >                    (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)) @2)
out >                 (λ _ -> CompileTimeInlining-minimized.Var _88 @1))
out >   arg2 = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env _96 ->
out >               CompileTimeInlining-minimized.U)
out >            (λ u ->
out >               CompileTimeInlining-minimized.Σ
out >                 (CompileTimeInlining-minimized._≡_
out >                    {(g : CompileTimeInlining-minimized.Σ
out >                            (CompileTimeInlining-minimized.Env _96)
out >                            (λ v -> CompileTimeInlining-minimized.El (_97 @0))) ->
out >                       CompileTimeInlining-minimized.U}
out >                    (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)) @2)
out >                 (λ _ -> CompileTimeInlining-minimized.Var _96 @1))
out > { working on problems [237]
out > compareTerm
out >   Σ (Env _G_88 → U)
out >   (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁)) =< Σ
out >                                                               (Env _G_96 → U)
out >                                                               (λ u₁ →
out >                                                                  Σ ((λ g → u₁ (fst g)) ≡ u)
out >                                                                  (λ _ → Var _G_96 u₁))
out >   : Set
out > compareTerm (not syntactically equal)
out >   Σ (Env _G_88 → U)
out >   (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁)) =< Σ
out >                                                               (Env _G_96 → U)
out >                                                               (λ u₁ →
out >                                                                  Σ ((λ g → u₁ (fst g)) ≡ u)
out >                                                                  (λ _ → Var _G_96 u₁))
out >   : Set
out > { compareTerm
out > compareTerm
out > Σ (Env _G_88 → U)
out > (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁))
out > =<
out > Σ (Env _G_96 → U)
out > (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁))
out > : Set
out > { compareAtom
out > compareAtom Σ (Env _G_88 → U)
out >             (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁)) =<
out >             Σ (Env _G_96 → U)
out >             (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁))
out >             : Set
out > compareAtom Σ (Env _G_88 → U)
out >             (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁)) =<
out >             Σ (Env _G_96 → U)
out >             (λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁))
out >             : Set
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env _G_88 → U,
out >            $ λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁)]
out >   els02 = [$ Env _G_96 → U,
out >            $ λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env _G_88 → U
out >   arg2 = Env _G_96 → U
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env _88 ->
out >            CompileTimeInlining-minimized.U
out >   arg2 = CompileTimeInlining-minimized.Env _96 ->
out >            CompileTimeInlining-minimized.U
out > { working on problems [238]
out > compareTerm Env _G_88 → U = Env _G_96 → U : Set
out > compareTerm (not syntactically equal)
out >   Env _G_88 → U = Env _G_96 → U
out >   : Set
out > { compareTerm
out > compareTerm Env _G_88 → U = Env _G_96 → U : Set
out > { compareAtom
out > compareAtom Env _G_88 → U = Env _G_96 → U : Set
out > compareAtom Env _G_88 → U = Env _G_96 → U : Set
out > { compare function types
out >   t1 = Env _G_88 → U
out >   t2 = Env _G_96 → U
out > { working on problems [239]
out > { compareType
out > compareType Env _G_96 = Env _G_88
out >    sorts: Set  and  Set
out > compareTerm Env _G_96 = Env _G_88 
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 
out > compareAtom [ Env _G_96 ]_96 = [ Env _G_88 ]_88 
out > compareTerm Env _G_96 = Env _G_88 
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 
out > compareAtom Env _G_96 = Env _G_88 
out > compareElims
out >   a     = Ctxt → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Env
out >   els01 = [$ _G_96]
out >   els02 = [$ _G_88]
out > { compare Apply
out >   a    = Ctxt → Set
out >   v    = Env
out >   arg1 = _G_96
out >   arg2 = _G_88
out >   raw:
out >   a    = CompileTimeInlining-minimized.Ctxt -> Set
out >   v    = CompileTimeInlining-minimized.Env
out >   arg1 = _96
out >   arg2 = _88
out > { working on problems [240]
out > compareTerm _G_96 = _G_88 : Ctxt
out > compareTerm (not syntactically equal) _G_96 = _G_88 : Ctxt
out > attempting shortcut _G_96 := _G_88
out > term _G_96 :DirEq _G_88
out > attempting shortcut _G_88 := _G_96
out > term _G_88 :DirEq _G_96
out > { compareTerm
out > compareTerm _G_96 = _G_88 : Ctxt
out > { compareAtom
out > compareAtom _G_96 = _G_88 : Ctxt
out > compareAtom _G_96 = _G_88 : Ctxt
out > term _G_96 :DirEq _G_88
out > term _G_88 :DirEq _G_96
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 239 was not solved.
out > }
out > { compareType
out > compareType U = U
out >    sorts: Set  and  Set
out > compareTerm U = U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > }
out > problem 238 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = Env _G_88 → U
out >   arg2 = Env _G_96 → U
out > antiUnify
out > a = Set
out > u = Env _G_88 → U
out > v = Env _G_96 → U
out > antiUnify
out > a = Set
out > u = Env _G_88
out > v = Env _G_96
out > antiUnify
out > a = Ctxt
out > u = _G_88
out > v = _G_96
out > blocked _136 := λ u x → _G_88
out >      by [[199, 214, 219, 229, 237, 238, 239] Env _G_96 = Env _G_88
out >                                                ]
out > new meta (ConcreteDef): [u, x] |-
out >   _137 : (u₁ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >          (x₁ : (λ g → u₁ (fst g)) ≡ (λ g → el Set)) →
out >          Ctxt
out > setting twin of _137 to be _136
out > Anti-unification: Env _137 → U
out > compareElims
out >   a     = (B : (Env _137 → U) → Set) → Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env _137 → U)
out >   els01 = [$ λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁)]
out >   els02 = [$ λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁)]
out > { compare Apply
out >   a    = (B : (Env _137 → U) → Set) → Set
out >   v    = Σ (Env _137 → U)
out >   arg1 = λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁)
out >   arg2 = λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁)
out >   raw:
out >   a    = (B : (CompileTimeInlining-minimized.Env (_137 @1 @0) ->
out >                  CompileTimeInlining-minimized.U) ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env (_137 @1 @0) ->
out >               CompileTimeInlining-minimized.U)
out >   arg1 = λ u ->
out >            CompileTimeInlining-minimized.Σ
out >              (CompileTimeInlining-minimized._≡_
out >                 {(g : CompileTimeInlining-minimized.Σ
out >                         (CompileTimeInlining-minimized.Env _88)
out >                         (λ v -> CompileTimeInlining-minimized.El (_89 @0))) ->
out >                    CompileTimeInlining-minimized.U}
out >                 (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)) @2)
out >              (λ _ -> CompileTimeInlining-minimized.Var _88 @1)
out >   arg2 = λ u ->
out >            CompileTimeInlining-minimized.Σ
out >              (CompileTimeInlining-minimized._≡_
out >                 {(g : CompileTimeInlining-minimized.Σ
out >                         (CompileTimeInlining-minimized.Env _96)
out >                         (λ v -> CompileTimeInlining-minimized.El (_97 @0))) ->
out >                    CompileTimeInlining-minimized.U}
out >                 (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)) @2)
out >              (λ _ -> CompileTimeInlining-minimized.Var _96 @1)
out > { working on problems [240]
out > compareTerm
out >   λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁) =< λ u₁ →
out >                                                               Σ ((λ g → u₁ (fst g)) ≡ u)
out >                                                               (λ _ → Var _G_96 u₁)
out >   : (Env _137 → U) → Set
out > compareTerm (not syntactically equal)
out >   λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁) =< λ u₁ →
out >                                                               Σ ((λ g → u₁ (fst g)) ≡ u)
out >                                                               (λ _ → Var _G_96 u₁)
out >   : (Env _137 → U) → Set
out > { compareTerm
out > compareTerm λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁)
out > =< λ u₁ → Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁) :
out > (Env _137 → U) → Set
out > compareTerm
out >   Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁) =< Σ
out >                                                      ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁)
out >   : Set
out > compareTerm (not syntactically equal)
out >   Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁) =< Σ
out >                                                      ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁)
out >   : Set
out > { compareTerm
out > compareTerm Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁) =<
out > Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁) : Set
out > { compareAtom
out > compareAtom Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁) =<
out >             Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁) : Set
out > compareAtom Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_88 u₁) =<
out >             Σ ((λ g → u₁ (fst g)) ≡ u) (λ _ → Var _G_96 u₁) : Set
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ (λ g → u₁ (fst g)) ≡ u, $ λ _ → Var _G_88 u₁]
out >   els02 = [$ (λ g → u₁ (fst g)) ≡ u, $ λ _ → Var _G_96 u₁]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = (λ g → u₁ (fst g)) ≡ u
out >   arg2 = (λ g → u₁ (fst g)) ≡ u
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized._≡_
out >            {(g : CompileTimeInlining-minimized.Σ
out >                    (CompileTimeInlining-minimized.Env _88)
out >                    (λ v -> CompileTimeInlining-minimized.El (_89 @0))) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)) @2
out >   arg2 = CompileTimeInlining-minimized._≡_
out >            {(g : CompileTimeInlining-minimized.Σ
out >                    (CompileTimeInlining-minimized.Env _96)
out >                    (λ v -> CompileTimeInlining-minimized.El (_97 @0))) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)) @2
out > { working on problems [241]
out > compareTerm (λ g → u₁ (fst g)) ≡ u = (λ g → u₁ (fst g)) ≡ u : Set
out > compareTerm (not syntactically equal)
out >   (λ g → u₁ (fst g)) ≡ u = (λ g → u₁ (fst g)) ≡ u
out >   : Set
out > { compareTerm
out > compareTerm (λ g → u₁ (fst g)) ≡ u = (λ g → u₁ (fst g)) ≡ u : Set
out > { compareAtom
out > compareAtom (λ g → u₁ (fst g)) ≡ u = (λ g → u₁ (fst g)) ≡ u : Set
out > compareAtom (λ g → u₁ (fst g)) ≡ u = (λ g → u₁ (fst g)) ≡ u : Set
out > compareElims
out >   a     = {A : Set} → A → A → Set
out >   pols0 (truncated to 10) = Invariant Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_
out >   els01 = [$ {_}, $ λ g → u₁ (fst g), $ u]
out >   els02 = [$ {_}, $ λ g → u₁ (fst g), $ u]
out > { compare Apply
out >   a    = {A : Set} → A → A → Set
out >   v    = _≡_
out >   arg1 = {_}
out >   arg2 = {_}
out >   raw:
out >   a    = {A : Set} -> @0 -> @0 -> Set
out >   v    = CompileTimeInlining-minimized._≡_
out >   arg1 = {(g : CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env _88)
out >                  (λ v -> CompileTimeInlining-minimized.El (_89 @0))) ->
out >             CompileTimeInlining-minimized.U}
out >   arg2 = {(g : CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env _96)
out >                  (λ v -> CompileTimeInlining-minimized.El (_97 @0))) ->
out >             CompileTimeInlining-minimized.U}
out > { working on problems [242]
out > compareTerm
out >   (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U = (g
out >                                                   : Σ (Env _G_96) (λ v → El (_s_89 v))) →
out >                                                  U
out >   : Set
out > compareTerm (not syntactically equal)
out >   (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U = (g
out >                                                   : Σ (Env _G_96) (λ v → El (_s_89 v))) →
out >                                                  U
out >   : Set
out > { compareTerm
out > compareTerm (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U =
out > (g : Σ (Env _G_96) (λ v → El (_s_89 v))) → U : Set
out > { compareAtom
out > compareAtom (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U =
out >             (g : Σ (Env _G_96) (λ v → El (_s_89 v))) → U : Set
out > compareAtom (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U =
out >             (g : Σ (Env _G_96) (λ v → El (_s_89 v))) → U : Set
out > { compare function types
out >   t1 = (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U
out >   t2 = (g : Σ (Env _G_96) (λ v → El (_s_89 v))) → U
out > { working on problems [243]
out > { compareType
out > compareType Σ (Env _G_96) (λ v → El (_s_89 v)) =
out >             Σ (Env _G_88) (λ v → El (_s_89 v))
out >    sorts: Set  and  Set
out > compareTerm
out >   Σ (Env _G_96) (λ v → El (_s_89 v)) = Σ (Env _G_88)
out >                                        (λ v → El (_s_89 v))
out >   
out > compareTerm (not syntactically equal)
out >   Σ (Env _G_96) (λ v → El (_s_89 v)) = Σ (Env _G_88)
out >                                        (λ v → El (_s_89 v))
out >   
out > { compareAtom
out > compareAtom Σ (Env _G_96) (λ v → El (_s_89 v)) =
out >             Σ (Env _G_88) (λ v → El (_s_89 v)) 
out > compareAtom Σ (Env _G_96) (λ v → El (_s_89 v)) =
out >             Σ (Env _G_88) (λ v → El (_s_89 v)) 
out > compareElims
out >   a     = (A : Set) (B : A → Set) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ
out >   els01 = [$ Env _G_96, $ λ v → El (_s_89 v)]
out >   els02 = [$ Env _G_88, $ λ v → El (_s_89 v)]
out > { compare Apply
out >   a    = (A : Set) (B : A → Set) → Set
out >   v    = Σ
out >   arg1 = Env _G_96
out >   arg2 = Env _G_88
out >   raw:
out >   a    = (A : Set) -> (B : @0 -> Set) -> Set
out >   v    = CompileTimeInlining-minimized.Σ
out >   arg1 = CompileTimeInlining-minimized.Env _96
out >   arg2 = CompileTimeInlining-minimized.Env _88
out > { working on problems [244]
out > compareTerm Env _G_96 = Env _G_88 : Set
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 : Set
out > { compareTerm
out > compareTerm Env _G_96 = Env _G_88 : Set
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareAtom [ Env _G_96 ]_96 = [ Env _G_88 ]_88 : Set
out > compareTerm Env _G_96 = Env _G_88 : Set
out > compareTerm (not syntactically equal) Env _G_96 = Env _G_88 : Set
out > { compareTerm
out > compareTerm Env _G_96 = Env _G_88 : Set
out > { compareAtom
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareAtom Env _G_96 = Env _G_88 : Set
out > compareElims
out >   a     = Ctxt → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Env
out >   els01 = [$ _G_96]
out >   els02 = [$ _G_88]
out > { compare Apply
out >   a    = Ctxt → Set
out >   v    = Env
out >   arg1 = _G_96
out >   arg2 = _G_88
out >   raw:
out >   a    = CompileTimeInlining-minimized.Ctxt -> Set
out >   v    = CompileTimeInlining-minimized.Env
out >   arg1 = _96
out >   arg2 = _88
out > { working on problems [245]
out > compareTerm _G_96 = _G_88 : Ctxt
out > compareTerm (not syntactically equal) _G_96 = _G_88 : Ctxt
out > attempting shortcut _G_96 := _G_88
out > term _G_96 :DirEq _G_88
out > attempting shortcut _G_88 := _G_96
out > term _G_88 :DirEq _G_96
out > { compareTerm
out > compareTerm _G_96 = _G_88 : Ctxt
out > { compareAtom
out > compareAtom _G_96 = _G_88 : Ctxt
out > compareAtom _G_96 = _G_88 : Ctxt
out > term _G_96 :DirEq _G_88
out > term _G_88 :DirEq _G_96
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > problem 244 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = Env _G_96
out >   arg2 = Env _G_88
out > antiUnify
out > a = Set
out > u = Env _G_96
out > v = Env _G_88
out > antiUnify
out > a = Ctxt
out > u = _G_96
out > v = _G_88
out > blocked _138 := λ u x u₁ → _G_96
out >      by [[199, 214, 219, 229, 237, 240, 241, 242, 243, 244] Env
out >                                                             _G_96
out >                                                               = Env _G_88
out >                                                               : Set]
out > new meta (ConcreteDef): [u, x, u₁] |-
out >   _139 : (u₂ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >          (x₁ : (λ g → u₂ (fst g)) ≡ (λ g → el Set))
out >          (u₃ : Env (_137 (u = u₂) (x = x₁)) → U) →
out >          Ctxt
out > setting twin of _139 to be _138
out > Anti-unification: Env _139
out > compareElims
out >   a     = (B : Env _139 → Set) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = Σ (Env _139)
out >   els01 = [$ λ v → El (_s_89 v)]
out >   els02 = [$ λ v → El (_s_89 v)]
out > { compare Apply
out >   a    = (B : Env _139 → Set) → Set
out >   v    = Σ (Env _139)
out >   arg1 = λ v → El (_s_89 v)
out >   arg2 = λ v → El (_s_89 v)
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized.Env (_139 @2 @1 @0) ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized.Env (_139 @2 @1 @0))
out >   arg1 = λ v -> CompileTimeInlining-minimized.El (_97 @0)
out >   arg2 = λ v -> CompileTimeInlining-minimized.El (_89 @0)
out > { working on problems [245]
out > compareTerm
out >   λ v → El (_s_89 v) = λ v → El (_s_89 v)
out >   : Env _139 → Set
out > problem 245 was solved!
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > problem 243 was not solved.
out > }
out > { compareType
out > compareType U = U
out >    sorts: Set  and  Set
out > compareTerm U = U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > }
out > }
out > problem 242 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = {_}
out >   arg2 = {_}
out > antiUnify
out > a = Set
out > u = (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U
out > v = (g : Σ (Env _G_96) (λ v → El (_s_89 v))) → U
out > antiUnify
out > a = Set
out > u = Σ (Env _G_88) (λ v → El (_s_89 v))
out > v = Σ (Env _G_96) (λ v → El (_s_89 v))
out > antiUnify
out > a = Set
out > u = Env _G_88
out > v = Env _G_96
out > antiUnify
out > a = Ctxt
out > u = _G_88
out > v = _G_96
out > blocked _140 := λ u x u₁ → _G_88
out >      by [[199, 214, 219, 229, 237, 240, 241, 242, 243] _138
out >                                                          := λ u x u₁ → _G_96
out >                                                          [blocked on problem 244],
out >          [199, 214, 219, 229, 237, 240, 241, 242, 243, 244] Env _G_96
out >                                                               = Env _G_88
out >                                                               : Set]
out > new meta (ConcreteDef): [u, x, u₁] |-
out >   _141 : (u₂ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >          (x₁ : (λ g → u₂ (fst g)) ≡ (λ g → el Set))
out >          (u₃ : Env (_137 (u = u₂) (x = x₁)) → U) →
out >          Ctxt
out > setting twin of _141 to be _140
out > Anti-unification: {_}
out > compareElims
out >   a     = (Σ (Env _141) (λ v → El (_s_89 v)) → U) →
out >           (Σ (Env _141) (λ v → El (_s_89 v)) → U) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_
out >   els01 = [$ λ g → u₁ (fst g), $ u]
out >   els02 = [$ λ g → u₁ (fst g), $ u]
out > { compare Apply
out >   a    = (Σ (Env _141) (λ v → El (_s_89 v)) → U) →
out >          (Σ (Env _141) (λ v → El (_s_89 v)) → U) → Set
out >   v    = _≡_
out >   arg1 = λ g → u₁ (fst g)
out >   arg2 = λ g → u₁ (fst g)
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Σ
out >             (CompileTimeInlining-minimized.Env (_141 @2 @1 @0))
out >             (λ v -> CompileTimeInlining-minimized.El (_89 @0)) ->
out >             CompileTimeInlining-minimized.U) ->
out >            (CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Env (_141 @2 @1 @0))
out >               (λ v -> CompileTimeInlining-minimized.El (_89 @0)) ->
out >               CompileTimeInlining-minimized.U) ->
out >              Set
out >   v    = CompileTimeInlining-minimized._≡_
out >            {CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Env (_141 @2 @1 @0))
out >               (λ v -> CompileTimeInlining-minimized.El (_89 @0)) ->
out >               CompileTimeInlining-minimized.U}
out >   arg1 = λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)
out >   arg2 = λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)
out > { working on problems [246]
out > compareTerm
out >   λ g → u₁ (fst g) = λ g → u₁ (fst g)
out >   : Σ (Env _141) (λ v → El (_s_89 v)) → U
out > problem 246 was solved!
out > }
out > compareElims
out >   a     = (Σ (Env _141) (λ v → El (_s_89 v)) → U) → Set
out >   pols0 (truncated to 10) = Invariant
out >   fors0 (truncated to 10) =
out >   v     = _≡_ (λ g → u₁ (fst g))
out >   els01 = [$ u]
out >   els02 = [$ u]
out > { compare Apply
out >   a    = (Σ (Env _141) (λ v → El (_s_89 v)) → U) → Set
out >   v    = _≡_ (λ g → u₁ (fst g))
out >   arg1 = u
out >   arg2 = u
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Σ
out >             (CompileTimeInlining-minimized.Env (_141 @2 @1 @0))
out >             (λ v -> CompileTimeInlining-minimized.El (_89 @0)) ->
out >             CompileTimeInlining-minimized.U) ->
out >            Set
out >   v    = CompileTimeInlining-minimized._≡_
out >            {CompileTimeInlining-minimized.Σ
out >               (CompileTimeInlining-minimized.Env (_141 @2 @1 @0))
out >               (λ v -> CompileTimeInlining-minimized.El (_89 @0)) ->
out >               CompileTimeInlining-minimized.U}
out >            (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >   arg1 = @2
out >   arg2 = @2
out > { working on problems [247]
out > compareTerm u = u : Σ (Env _141) (λ v → El (_s_89 v)) → U
out > problem 247 was solved!
out > }
out > }
out > }
out > }
out > }
out > }
out > problem 241 was not solved.
out > }
out > Trying antiUnify:
out >   b    = Set
out >   arg1 = (λ g → u₁ (fst g)) ≡ u
out >   arg2 = (λ g → u₁ (fst g)) ≡ u
out > antiUnify
out > a = Set
out > u = (λ g → u₁ (fst g)) ≡ u
out > v = (λ g → u₁ (fst g)) ≡ u
out > antiUnify
out > a = Set
out > u = (g : Σ (Env _G_88) (λ v → El (_s_89 v))) → U
out > v = (g : Σ (Env _G_96) (λ v → El (_s_89 v))) → U
out > antiUnify
out > a = Set
out > u = Σ (Env _G_88) (λ v → El (_s_89 v))
out > v = Σ (Env _G_96) (λ v → El (_s_89 v))
out > antiUnify
out > a = Set
out > u = Env _G_88
out > v = Env _G_96
out > antiUnify
out > a = Ctxt
out > u = _G_88
out > v = _G_96
out > blocked _142 := λ u x u₁ → _G_88
out >      by [[199, 214, 219, 229, 237, 240, 241] _140
out >                                                := λ u x u₁ → _G_88
out >                                                [blocked on problem 242],
out >          [199, 214, 219, 229, 237, 240, 241, 242, 243] _138
out >                                                          := λ u x u₁ → _G_96
out >                                                          [blocked on problem 244],
out >          [199, 214, 219, 229, 237, 240, 241, 242, 243, 244] Env _G_96
out >                                                               = Env _G_88
out >                                                               : Set]
out > new meta (ConcreteDef): [u, x, u₁] |-
out >   _143 : (u₂ : Σ (Env _113) (λ g → El (_115 (_ = g))) → U)
out >          (x₁ : (λ g → u₂ (fst g)) ≡ (λ g → el Set))
out >          (u₃ : Env (_137 (u = u₂) (x = x₁)) → U) →
out >          Ctxt
out > setting twin of _143 to be _142
out > Anti-unification: (λ g → u₁ (fst g)) ≡ u
out > compareElims
out >   a     = (B : (λ g → u₁ (fst g)) ≡ u → Set) → Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Σ ((λ g → u₁ (fst g)) ≡ u)
out >   els01 = [$ λ _ → Var _G_88 u₁]
out >   els02 = [$ λ _ → Var _G_96 u₁]
out > { compare Apply
out >   a    = (B : (λ g → u₁ (fst g)) ≡ u → Set) → Set
out >   v    = Σ ((λ g → u₁ (fst g)) ≡ u)
out >   arg1 = λ _ → Var _G_88 u₁
out >   arg2 = λ _ → Var _G_96 u₁
out >   raw:
out >   a    = (B : CompileTimeInlining-minimized._≡_
out >                 {CompileTimeInlining-minimized.Σ
out >                    (CompileTimeInlining-minimized.Env (_143 @2 @1 @0))
out >                    (λ v -> CompileTimeInlining-minimized.El (_89 @0)) ->
out >                    CompileTimeInlining-minimized.U}
out >                 (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)) @2 ->
out >                 Set) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Σ
out >            (CompileTimeInlining-minimized._≡_
out >               {CompileTimeInlining-minimized.Σ
out >                  (CompileTimeInlining-minimized.Env (_143 @2 @1 @0))
out >                  (λ v -> CompileTimeInlining-minimized.El (_89 @0)) ->
out >                  CompileTimeInlining-minimized.U}
out >               (λ g -> @1 (@0 .CompileTimeInlining-minimized.Σ.fst)) @2)
out >   arg1 = λ _ -> CompileTimeInlining-minimized.Var _88 @1
out >   arg2 = λ _ -> CompileTimeInlining-minimized.Var _96 @1
out > { working on problems [248]
out > compareTerm
out >   λ _ → Var _G_88 u₁ =< λ _ → Var _G_96 u₁
out >   : (λ g → u₁ (fst g)) ≡ u → Set
out > compareTerm (not syntactically equal)
out >   λ _ → Var _G_88 u₁ =< λ _ → Var _G_96 u₁
out >   : (λ g → u₁ (fst g)) ≡ u → Set
out > { compareTerm
out > compareTerm λ _ → Var _G_88 u₁ =< λ _ → Var _G_96 u₁ :
out > (λ g → u₁ (fst g)) ≡ u → Set
out > compareTerm Var _G_88 u₁ =< Var _G_96 u₁ : Set
out > compareTerm (not syntactically equal)
out >   Var _G_88 u₁ =< Var _G_96 u₁
out >   : Set
out > { compareTerm
out > compareTerm Var _G_88 u₁ =< Var _G_96 u₁ : Set
out > { compareAtom
out > compareAtom Var _G_88 u₁ =< Var _G_96 u₁ : Set
out > compareAtom [ Var _G_88 u₁ ]_88 =< [ Var _G_96 u₁ ]_96 : Set
out > compareTerm Var _G_88 u₁ = Var _G_96 u₁ : Set
out > compareTerm (not syntactically equal)
out >   Var _G_88 u₁ = Var _G_96 u₁
out >   : Set
out > { compareTerm
out > compareTerm Var _G_88 u₁ = Var _G_96 u₁ : Set
out > { compareAtom
out > compareAtom Var _G_88 u₁ = Var _G_96 u₁ : Set
out > compareAtom Var _G_88 u₁ = Var _G_96 u₁ : Set
out > compareElims
out >   a     = (G : Ctxt) → (Env G → U) → Set
out >   pols0 (truncated to 10) = Invariant Invariant
out >   fors0 (truncated to 10) =
out >   v     = Var
out >   els01 = [$ _G_88, $ u₁]
out >   els02 = [$ _G_96, $ u₁]
out > { compare Apply
out >   a    = (G : Ctxt) → (Env G → U) → Set
out >   v    = Var
out >   arg1 = _G_88
out >   arg2 = _G_96
out >   raw:
out >   a    = (G : CompileTimeInlining-minimized.Ctxt) ->
out >            (CompileTimeInlining-minimized.Env @0 ->
out >               CompileTimeInlining-minimized.U) ->
out >              Set
out >   v    = CompileTimeInlining-minimized.Var
out >   arg1 = _88
out >   arg2 = _96
out > { working on problems [249]
out > compareTerm _G_88 = _G_96 : Ctxt
out > compareTerm (not syntactically equal) _G_88 = _G_96 : Ctxt
out > attempting shortcut _G_96 := _G_88
out > term _G_96 :DirEq _G_88
out > attempting shortcut _G_88 := _G_96
out > term _G_88 :DirEq _G_96
out > { compareTerm
out > compareTerm _G_88 = _G_96 : Ctxt
out > { compareAtom
out > compareAtom _G_88 = _G_96 : Ctxt
out > compareAtom _G_88 = _G_96 : Ctxt
out > term _G_96 :DirEq _G_88
out > term _G_88 :DirEq _G_96
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > }
out > runPureConversion result: Left Pattern violation (you shouldn't see this)
out > }
out > }
out > }
out > problem 248 was not solved.
out > }
out > }
out > }
out > }
out > }
out > }
out > problem 240 was not solved.
out > }
out > }
out > }
out > }
out > }
out > problem 237 was not solved.
out > }
out > }
out > }
out > }
out > }
out > }
out > problem 229 was not solved.
out > }
out > }
out > }
out > }
out > }
out > }
out > problem 219 was not solved.
out > }
out > }
out > }
out > }
out > }
out > problem 214 was not solved.
out > }
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 199 was not solved.
out > }
out > Solving awake constraints. 5 remaining.
out > { working on problems [199,214,219,229,230,231,232,234]
out > { solving constraint
out > [199,214,219,229,230,231,232,234] El (_s_89 v) = El (_s_89 v) : Set
out > compareTerm El (_s_89 v) = El (_s_89 v) : Set
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 230 was not solved.
out > problem 231 was not solved.
out > problem 232 was not solved.
out > problem 234 was solved!
out > }
out > Solving awake constraints. 4 remaining.
out > { working on problems [199,214,219,220,221,222,223,225]
out > { solving constraint
out > [199,214,219,220,221,222,223,225] El (_s_89 g) = El (_s_89 g) : Set
out > compareTerm El (_s_89 g) = El (_s_89 g) : Set
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 220 was not solved.
out > problem 221 was not solved.
out > problem 222 was not solved.
out > problem 223 was not solved.
out > problem 225 was solved!
out > }
out > Solving awake constraints. 3 remaining.
out > { working on problems [199,214,215,216,218]
out > { solving constraint
out > [199,214,215,216,218] El (_s_89 g) = El (_s_89 g) : Set
out > compareTerm El (_s_89 g) = El (_s_89 g) : Set
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 215 was not solved.
out > problem 216 was not solved.
out > problem 218 was solved!
out > }
out > Solving awake constraints. 2 remaining.
out > { working on problems [199,202,203,204,209,211]
out > { solving constraint
out > [199,202,203,204,209,211] El (_s_89 g) =< El (_s_89 g) : Set
out > compareTerm El (_s_89 g) =< El (_s_89 g) : Set
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 209 was not solved.
out > problem 211 was solved!
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems [199,202,203,204,205,208]
out > { solving constraint
out > [199,202,203,204,205,208] El (_s_89 g) = El (_s_89 g) : Set
out > compareTerm El (_s_89 g) = El (_s_89 g) : Set
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 205 was not solved.
out > problem 208 was solved!
out > }
out > Solving awake constraints. 0 remaining.
out > blocked _144 := suc (snoc _G_88 (λ v → _s_89 v))
out >                 (λ z → el (El (_s_94 z))) (λ _ → el Set)
out >      by [[199, 214, 219, 229, 237, 240, 248] Var _G_88 u₁
out >                                                =< Var _G_96 u₁
out >                                                : Set,
out >          [199, 214, 219, 229, 237, 240] _142 := λ u x u₁ → _G_88
out >                                           [blocked on problem 241],
out >          [199, 214, 219, 229, 237, 240, 241] _140 := λ u x u₁ → _G_88
out >                                                [blocked on problem 242],
out >          [199, 214, 219, 229, 237, 240, 241, 242, 243] _138
out >                                                          := λ u x u₁ → _G_96
out >                                                          [blocked on problem 244],
out >          [199, 214, 219, 229, 237, 240, 241, 242, 243, 244] Env _G_96
out >                                                               = Env _G_88
out >                                                               : Set,
out >          [199, 214, 219, 229, 237] _136 := λ u x → _G_88
out >                                      [blocked on problem 238],
out >          [199, 214, 219, 229, 237, 238, 239] Env _G_96 = Env _G_88 ,
out >          [199, 214, 219, 229, 230, 235] Env _G_96 =< Env _G_88 ,
out >          [199, 214, 219, 229, 230] _134 := λ u x z → _s_89 z
out >                                      [blocked on problem 231],
out >          [199, 214, 219, 229, 230] _132 := λ u x → _G_88
out >                                      [blocked on problem 231],
out >          [199, 214, 219, 229, 230, 231, 232] _130 := λ u x → _G_96
out >                                                [blocked on problem 233],
out >          [199, 214, 219, 229, 230, 231, 232, 233] Env _G_96 = Env _G_88
out >                                                     : Set,
out >          [199, 214, 219] _128 := λ u z → _s_89 z [blocked on problem 220],
out >          [199, 214, 219] _126 := λ u → _G_88 [blocked on problem 220],
out >          [199, 214, 219, 220] _124 := λ u z → _s_89 z
out >                                 [blocked on problem 221],
out >          [199, 214, 219, 220] _122 := λ u → _G_88 [blocked on problem 221],
out >          [199, 214, 219, 220, 221, 222] _120 := λ u z → _s_89 z
out >                                           [blocked on problem 223],
out >          [199, 214, 219, 220, 221, 222] _118 := λ u → _G_96
out >                                           [blocked on problem 223],
out >          [199, 214, 219, 220, 221, 222, 223] _116 := λ u → _G_96
out >                                                [blocked on problem 224],
out >          [199, 214, 219, 220, 221, 222, 223, 224] Env _G_96 = Env _G_88
out >                                                     : Set,
out >          [199, 214] _114 := λ z → _s_89 z [blocked on problem 215],
out >          [199, 214] _112 := _G_88 [blocked on problem 215],
out >          [199, 214, 215, 216] _110 := _G_96 [blocked on problem 217],
out >          [199, 214, 215, 216, 217] Env _G_96 = Env _G_88 : Set,
out >          [199, 202, 212] el (El (_s_94 (fst g))) = _s_94 (fst g) : U,
out >          [199, 202] _108 := λ z → _s_89 z [blocked on problem 203],
out >          [199, 202] _106 := _G_88 [blocked on problem 203],
out >          [199, 202, 203, 204, 209] _104 := λ z → _G_88
out >                                      [blocked on problem 210],
out >          [199, 202, 203, 204, 209, 210] Env _G_88 = Env _G_96 : Set,
out >          [199, 202, 203, 204] _102 := λ z → _s_89 z
out >                                 [blocked on problem 205],
out >          [199, 202, 203, 204] _100 := _G_96 [blocked on problem 205],
out >          [199, 202, 203, 204, 205] _98 := _G_96 [blocked on problem 207],
out >          [199, 202, 203, 204, 205, 207] Env _G_96 = Env _G_88 : Set]
out > new meta (ConcreteDef): [] |-
out >   _145 : Var (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94) (λ _ → el Set)
out > setting twin of _145 to be _144
out > { working on problems [249]
out > coerce term      v  = el' (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94)
out >                       _145
out >        from type t1 = Type (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94)
out >                       (λ g →
out >                          el
out >                          (lookup (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94) (λ _ → el Set)
out >                           _145 g))
out >        to type   t2 = Type myctxt (λ g → el (snd (fst g)))
out >        comparison   = =<
out > { coerceSize
out > { compareType
out > compareType Type (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94)
out >             (λ g →
out >                el
out >                (lookup (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94) (λ _ → el Set)
out >                 _145 g)) =<
out >             Type myctxt (λ g → el (snd (fst g)))
out >    sorts: Set  and  Set
out > compareTerm
out >   Type (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94)
out >   (λ g →
out >      el
out >      (lookup (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94) (λ _ → el Set)
out >       _145 g)) =< Type myctxt (λ g → el (snd (fst g)))
out >   
out > compareTerm (not syntactically equal)
out >   Type (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94)
out >   (λ g →
out >      el
out >      (lookup (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94) (λ _ → el Set)
out >       _145 g)) =< Type myctxt (λ g → el (snd (fst g)))
out >   
out > { compareAtom
out > compareAtom Type (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94)
out >             (λ g →
out >                el
out >                (lookup (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94) (λ _ → el Set)
out >                 _145 g)) =<
out >             Type myctxt (λ g → el (snd (fst g))) 
out > compareAtom Type (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94)
out >             (λ g →
out >                el
out >                (lookup (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94) (λ _ → el Set)
out >                 _145 g)) =<
out >             Type myctxt (λ g → el (snd (fst g))) 
out > compareElims
out >   a     = (G : Ctxt) → (Env G → U) → Set
out >   pols0 (truncated to 10) =
out >   fors0 (truncated to 10) =
out >   v     = Type
out >   els01 = [$ snoc (snoc _G_96 (λ z → _s_89 z)) _s_94,
out >            $ λ g →
out >                el
out >                (lookup (snoc (snoc _G_96 (λ z → _s_89 z)) _s_94) (λ _ → el Set)
out >                 _145 g)]
out >   els02 = [$ myctxt, $ λ g → el (snd (fst g))]
out > { compare Apply
out >   a    = (G : Ctxt) → (Env G → U) → Set
out >   v    = Type
out >   arg1 = snoc (snoc _G_96 (λ z → _s_89 z)) _s_94
out >   arg2 = myctxt
out >   raw:
out >   a    = (G : CompileTimeInlining-minimized.Ctxt) ->
out >            (CompileTimeInlining-minimized.Env @0 ->
out >               CompileTimeInlining-minimized.U) ->
out >              Set
out >   v    = CompileTimeInlining-minimized.Type
out >   arg1 = CompileTimeInlining-minimized.Ctxt.snoc _93 _94
out >   arg2 = CompileTimeInlining-minimized.myctxt
out > { working on problems [250]
out > compareTerm snoc (snoc _G_96 (λ z → _s_89 z)) _s_94 = myctxt : Ctxt
out > compareTerm (not syntactically equal)
out >   snoc (snoc _G_96 (λ z → _s_89 z)) _s_94 = myctxt
out >   : Ctxt
out > { compareTerm
out > compareTerm snoc (snoc _G_96 (λ z → _s_89 z)) _s_94 = myctxt : Ctxt
out > { compareAtom
out > compareAtom snoc (snoc _G_96 (λ z → _s_89 z)) _s_94 = myctxt : Ctxt
out > compareAtom snoc (snoc _G_96 (λ z → _s_89 z)) _s_94 =
out >             snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)) : Ctxt
out > compareElims
out >   a     = (G : Ctxt) → (Env G → U) → Ctxt
out >   pols0 (truncated to 10) = Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant
out >   fors0 (truncated to 10) = NotForced NotForced
out >   v     = snoc
out >   els01 = [$ snoc _G_96 (λ z → _s_89 z), $ _s_94]
out >   els02 = [$ snoc whatever (λ _ → el Set), $ λ g → el (snd g)]
out > { compare Apply
out >   a    = (G : Ctxt) → (Env G → U) → Ctxt
out >   v    = snoc
out >   arg1 = snoc _G_96 (λ z → _s_89 z)
out >   arg2 = snoc whatever (λ _ → el Set)
out >   raw:
out >   a    = (G : CompileTimeInlining-minimized.Ctxt) ->
out >            (CompileTimeInlining-minimized.Env @0 ->
out >               CompileTimeInlining-minimized.U) ->
out >              CompileTimeInlining-minimized.Ctxt
out >   v    = CompileTimeInlining-minimized.Ctxt.snoc
out >   arg1 = _93
out >   arg2 = CompileTimeInlining-minimized.Ctxt.snoc
out >            (CompileTimeInlining-minimized.whatever
out >               {CompileTimeInlining-minimized.Ctxt})
out >            (λ _ -> CompileTimeInlining-minimized.U.el Set)
out > { working on problems [251]
out > compareTerm
out >   snoc _G_96 (λ z → _s_89 z) = snoc whatever (λ _ → el Set)
out >   : Ctxt
out > compareTerm (not syntactically equal)
out >   snoc _G_96 (λ z → _s_89 z) = snoc whatever (λ _ → el Set)
out >   : Ctxt
out > { compareTerm
out > compareTerm snoc _G_96 (λ z → _s_89 z) =
out > snoc whatever (λ _ → el Set) : Ctxt
out > { compareAtom
out > compareAtom snoc _G_96 (λ z → _s_89 z) =
out >             snoc whatever (λ _ → el Set) : Ctxt
out > compareAtom snoc _G_96 (λ z → _s_89 z) =
out >             snoc whatever (λ _ → el Set) : Ctxt
out > compareElims
out >   a     = (G : Ctxt) → (Env G → U) → Ctxt
out >   pols0 (truncated to 10) = Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant
out >   fors0 (truncated to 10) = NotForced NotForced
out >   v     = snoc
out >   els01 = [$ _G_96, $ λ z → _s_89 z]
out >   els02 = [$ whatever, $ λ _ → el Set]
out > { compare Apply
out >   a    = (G : Ctxt) → (Env G → U) → Ctxt
out >   v    = snoc
out >   arg1 = _G_96
out >   arg2 = whatever
out >   raw:
out >   a    = (G : CompileTimeInlining-minimized.Ctxt) ->
out >            (CompileTimeInlining-minimized.Env @0 ->
out >               CompileTimeInlining-minimized.U) ->
out >              CompileTimeInlining-minimized.Ctxt
out >   v    = CompileTimeInlining-minimized.Ctxt.snoc
out >   arg1 = _96
out >   arg2 = CompileTimeInlining-minimized.whatever
out >            {CompileTimeInlining-minimized.Ctxt}
out > { working on problems [252]
out > compareTerm _G_96 = whatever : Ctxt
out > compareTerm (not syntactically equal) _G_96 = whatever : Ctxt
out > attempting shortcut _G_96 := whatever
out > term _G_96 :DirEq whatever
out > term _G_96 :DirEq whatever
out > is _96 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _G_96
out >   _G_96  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _G_96 := whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > problem 252 was solved!
out > }
out > compareElims
out >   a     = (Env whatever → U) → Ctxt
out >   pols0 (truncated to 10) = Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant
out >   fors0 (truncated to 10) = NotForced
out >   v     = snoc whatever
out >   els01 = [$ λ z → _s_89 z]
out >   els02 = [$ λ _ → el Set]
out > { compare Apply
out >   a    = (Env whatever → U) → Ctxt
out >   v    = snoc whatever
out >   arg1 = λ z → _s_89 z
out >   arg2 = λ _ → el Set
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Env _96 ->
out >             CompileTimeInlining-minimized.U) ->
out >            CompileTimeInlining-minimized.Ctxt
out >   v    = CompileTimeInlining-minimized.Ctxt.snoc _96
out >   arg1 = _97
out >   arg2 = λ _ -> CompileTimeInlining-minimized.U.el Set
out > { working on problems [253]
out > compareTerm λ z → _s_89 z = λ _ → el Set : Env whatever → U
out > compareTerm (not syntactically equal)
out >   λ z → _s_89 z = λ _ → el Set
out >   : Env whatever → U
out > { compareTerm
out > compareTerm λ z → _s_89 z = λ _ → el Set : Env whatever → U
out > compareTerm _s_89 x = el Set : U
out > compareTerm (not syntactically equal) _s_89 x = el Set : U
out > attempting shortcut _s_89 x := el Set
out > term _s_89 x :DirEq el Set
out > term _s_89 x :DirEq el Set
out > is _89 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _s_89
out >   _s_89  :  U := el Set
out > elimView of  el Set
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  el Set
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _s_89 := λ _ → el Set
out > shortcut successful
out >   result: CompileTimeInlining-minimized.U.el Set
out > }
out > problem 253 was solved!
out > }
out > }
out > }
out > }
out > }
out > problem 251 was solved!
out > }
out > compareElims
out >   a     = (Env (snoc whatever (λ z → el Set)) → U) → Ctxt
out >   pols0 (truncated to 10) = Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant
out >   fors0 (truncated to 10) = NotForced
out >   v     = snoc (snoc whatever (λ z → el Set))
out >   els01 = [$ _s_94]
out >   els02 = [$ λ g → el (snd g)]
out > { compare Apply
out >   a    = (Env (snoc whatever (λ z → el Set)) → U) → Ctxt
out >   v    = snoc (snoc whatever (λ z → el Set))
out >   arg1 = _s_94
out >   arg2 = λ g → el (snd g)
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Env _93 ->
out >             CompileTimeInlining-minimized.U) ->
out >            CompileTimeInlining-minimized.Ctxt
out >   v    = CompileTimeInlining-minimized.Ctxt.snoc _93
out >   arg1 = _94
out >   arg2 = λ g ->
out >            CompileTimeInlining-minimized.U.el
out >              (@0 .CompileTimeInlining-minimized.Σ.snd)
out > { working on problems [254]
out > compareTerm
out >   _s_94 = λ g → el (snd g)
out >   : Env (snoc whatever (λ z → el Set)) → U
out > compareTerm (not syntactically equal)
out >   _s_94 = λ g → el (snd g)
out >   : Env (snoc whatever (λ z → el Set)) → U
out > attempting shortcut _s_94 := λ g → el (snd g)
out > term _s_94 :DirEq λ g → el (snd g)
out > term _s_94 :DirEq λ g → el (snd g)
out > is _94 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _s_94
out >   _s_94  :  Env (snoc whatever (λ z → el Set)) → U := λ g →
out >                                                         el (snd g)
out > elimView of  λ g → el (snd g)
out > v = Lam (ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}) (Abs "g" Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 [Proj ProjPrefix CompileTimeInlining-minimized.Σ.snd]})])
out > elimView (projections reduced) of  λ g → el (snd g)
out > elimView of  el (snd g)
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Var 0 [Proj ProjPrefix CompileTimeInlining-minimized.Σ.snd]})]
out > elimView (projections reduced) of  el (snd g)
out > elimView of  snd g
out > v = Var 0 [Proj ProjPrefix CompileTimeInlining-minimized.Σ.snd]
out > elimView (projections reduced) of  snd g
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _s_94 := λ g → el (snd g)
out > shortcut successful
out >   result: λ g ->
out >             CompileTimeInlining-minimized.U.el
out >               (@0 .CompileTimeInlining-minimized.Σ.snd)
out > problem 254 was solved!
out > }
out > }
out > }
out > }
out > }
out > problem 250 was solved!
out > }
out > compareElims
out >   a     = (Env
out >            (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g))) →
out >            U) →
out >           Set
out >   pols0 (truncated to 10) =
out >   fors0 (truncated to 10) =
out >   v     = Type
out >           (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >   els01 = [$ λ g →
out >                el
out >                (lookup (snoc (snoc whatever (λ z → el Set)) (λ g₁ → el (snd g₁)))
out >                 (λ _ → el Set) _145 g)]
out >   els02 = [$ λ g → el (snd (fst g))]
out > { compare Apply
out >   a    = (Env
out >           (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g))) →
out >           U) →
out >          Set
out >   v    = Type
out >          (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >   arg1 = λ g →
out >            el
out >            (lookup (snoc (snoc whatever (λ z → el Set)) (λ g₁ → el (snd g₁)))
out >             (λ _ → el Set) _145 g)
out >   arg2 = λ g → el (snd (fst g))
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Env
out >             (CompileTimeInlining-minimized.Ctxt.snoc _93 _94) ->
out >             CompileTimeInlining-minimized.U) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Type
out >            (CompileTimeInlining-minimized.Ctxt.snoc _93 _94)
out >   arg1 = λ g ->
out >            CompileTimeInlining-minimized.U.el
out >              (CompileTimeInlining-minimized.lookup
out >                 _82 (λ _ -> CompileTimeInlining-minimized.U.el Set) _145 @0)
out >   arg2 = λ g ->
out >            CompileTimeInlining-minimized.U.el
out >              (@0
out >                 .CompileTimeInlining-minimized.Σ.fst
out >                 .CompileTimeInlining-minimized.Σ.snd)
out > { working on problems [255]
out > compareTerm
out >   λ g →
out >     el
out >     (lookup (snoc (snoc whatever (λ z → el Set)) (λ g₁ → el (snd g₁)))
out >      (λ _ → el Set) _145 g) = λ g → el (snd (fst g))
out >   : Env (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g))) → U
out > compareTerm (not syntactically equal)
out >   λ g →
out >     el
out >     (lookup (snoc (snoc whatever (λ z → el Set)) (λ g₁ → el (snd g₁)))
out >      (λ _ → el Set) _145 g) = λ g → el (snd (fst g))
out >   : Env (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g))) → U
out > { compareTerm
out > compareTerm
out > λ g →
out >   el
out >   (lookup (snoc (snoc whatever (λ z → el Set)) (λ g₁ → el (snd g₁)))
out >    (λ _ → el Set) _145 g)
out > = λ g → el (snd (fst g)) :
out > Env (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g))) → U
out > compareTerm
out >   el
out >   (lookup (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >    (λ _ → el Set) _145 g₁) = el (snd (fst g₁))
out >   : U
out > compareTerm (not syntactically equal)
out >   el
out >   (lookup (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >    (λ _ → el Set) _145 g₁) = el (snd (fst g₁))
out >   : U
out > { compareTerm
out > compareTerm
out > el
out > (lookup (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >  (λ _ → el Set) _145 g₁)
out > = el (snd (fst g₁)) : U
out > { compareAtom
out > compareAtom el
out >             (lookup (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >              (λ _ → el Set) _145 g₁) =
out >             el (snd (fst g₁)) : U
out > compareAtom el
out >             (lookup (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >              (λ _ → el Set) _145 g₁) =
out >             el (snd (fst g₁)) : U
out > compareElims
out >   a     = Set → U
out >   pols0 (truncated to 10) = Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant
out >   fors0 (truncated to 10) = NotForced
out >   v     = el
out >   els01 = [$ lookup
out >              (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >              (λ _ → el Set) _145 g₁]
out >   els02 = [$ snd (fst g₁)]
out > { compare Apply
out >   a    = Set → U
out >   v    = el
out >   arg1 = lookup
out >          (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >          (λ _ → el Set) _145 g₁
out >   arg2 = snd (fst g₁)
out >   raw:
out >   a    = Set -> CompileTimeInlining-minimized.U
out >   v    = CompileTimeInlining-minimized.U.el
out >   arg1 = CompileTimeInlining-minimized.lookup
out >            _82 (λ _ -> CompileTimeInlining-minimized.U.el Set) _145 @0
out >   arg2 = @0
out >            .CompileTimeInlining-minimized.Σ.fst
out >            .CompileTimeInlining-minimized.Σ.snd
out > { working on problems [256]
out > compareTerm
out >   lookup (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >   (λ _ → el Set) _145 g₁ = snd (fst g₁)
out >   : Set
out > compareTerm (not syntactically equal)
out >   lookup (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >   (λ _ → el Set) _145 g₁ = snd (fst g₁)
out >   : Set
out > { compareTerm
out > compareTerm
out > lookup (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out > (λ _ → el Set) _145 g₁
out > = snd (fst g₁) : Set
out > { compareAtom
out > compareAtom lookup
out >             (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >             (λ _ → el Set) _145 g₁ =
out >             snd (fst g₁) : Set
out > compareAtom [ lookup
out >               (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >               (λ _ → el Set) _145 g₁ ]_145 =
out >             snd (fst g₁) : Set
out > }
out > }
out > problem 256 was not solved.
out > }
out > }
out > }
out > }
out > }
out > problem 255 was not solved.
out > }
out > }
out > }
out > }
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 249 was not solved.
out > }
out > Solving awake constraints. 11 remaining.
out > { working on problems [199,214,219,229,237,240,248]
out > { solving constraint
out > [199,214,219,229,237,240,248] Var _G_88 u₁ =< Var whatever u₁ : Set
out > compareTerm Var _G_88 u₁ =< Var whatever u₁ : Set
out > compareTerm (not syntactically equal)
out >   Var _G_88 u₁ =< Var whatever u₁
out >   : Set
out > { compareTerm
out > compareTerm Var _G_88 u₁ =< Var whatever u₁ : Set
out > { compareAtom
out > compareAtom Var _G_88 u₁ =< Var whatever u₁ : Set
out > compareAtom [ Var _G_88 u₁ ]_88 =< Var whatever u₁ : Set
out > compareElims
out >   a     = (G : Ctxt) → (Env G → U) → Set
out >   pols0 (truncated to 10) = Invariant Covariant
out >   fors0 (truncated to 10) =
out >   v     = Var
out >   els01 = [$ _G_88, $ u₁]
out >   els02 = [$ whatever, $ u₁]
out > { compare Apply
out >   a    = (G : Ctxt) → (Env G → U) → Set
out >   v    = Var
out >   arg1 = _G_88
out >   arg2 = whatever
out >   raw:
out >   a    = (G : CompileTimeInlining-minimized.Ctxt) ->
out >            (CompileTimeInlining-minimized.Env @0 ->
out >               CompileTimeInlining-minimized.U) ->
out >              Set
out >   v    = CompileTimeInlining-minimized.Var
out >   arg1 = _88
out >   arg2 = CompileTimeInlining-minimized.whatever
out >            {CompileTimeInlining-minimized.Ctxt}
out > { working on problems [257]
out > compareTerm _G_88 = whatever : Ctxt
out > compareTerm (not syntactically equal) _G_88 = whatever : Ctxt
out > attempting shortcut _G_88 := whatever
out > term _G_88 :DirEq whatever
out > term _G_88 :DirEq whatever
out > is _88 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _G_88
out >   _G_88  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _G_88 := whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > problem 257 was solved!
out > }
out > compareElims
out >   a     = (Env whatever → U) → Set
out >   pols0 (truncated to 10) = Covariant
out >   fors0 (truncated to 10) =
out >   v     = Var whatever
out >   els01 = [$ u₁]
out >   els02 = [$ u₁]
out > { compare Apply
out >   a    = (Env whatever → U) → Set
out >   v    = Var whatever
out >   arg1 = u₁
out >   arg2 = u₁
out >   raw:
out >   a    = (CompileTimeInlining-minimized.Env _88 ->
out >             CompileTimeInlining-minimized.U) ->
out >            Set
out >   v    = CompileTimeInlining-minimized.Var _88
out >   arg1 = @1
out >   arg2 = @1
out > { working on problems [258]
out > compareTerm u₁ =< u₁ : Env whatever → U
out > problem 258 was solved!
out > }
out > }
out > }
out > }
out > }
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 237 was not solved.
out > problem 240 was not solved.
out > problem 248 was solved!
out > }
out > Solving awake constraints. 10 remaining.
out > { working on problems [199,214,219,229,237,240,241,242,243,244]
out > { solving constraint
out > [199,214,219,229,237,240,241,242,243,244] Env whatever
out >                                             = Env whatever
out >                                             : Set
out > compareTerm Env whatever = Env whatever : Set
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 237 was not solved.
out > problem 240 was not solved.
out > problem 241 was not solved.
out > problem 242 was not solved.
out > problem 243 was not solved.
out > problem 244 was solved!
out > }
out > Solving awake constraints. 10 remaining.
out > { working on problems [199,214,219,229,237,238,239]
out > { solving constraint
out > [199,214,219,229,237,238,239] Env whatever = Env whatever 
out > compareTerm Env whatever = Env whatever 
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 237 was not solved.
out > problem 238 was solved!
out > problem 239 was solved!
out > }
out > Solving awake constraints. 10 remaining.
out > { working on problems [199,214,219,229,230,235]
out > { solving constraint
out > [199,214,219,229,230,235] Env whatever =< Env whatever 
out > compareTerm Env whatever =< Env whatever 
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 230 was not solved.
out > problem 235 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems [199,214,219,229,230,231,232,233]
out > { solving constraint
out > [199,214,219,229,230,231,232,233] Env whatever = Env whatever : Set
out > compareTerm Env whatever = Env whatever : Set
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 230 was not solved.
out > problem 231 was not solved.
out > problem 232 was not solved.
out > problem 233 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems [199,214,219,220,221,222,223,224]
out > { solving constraint
out > [199,214,219,220,221,222,223,224] Env whatever = Env whatever : Set
out > compareTerm Env whatever = Env whatever : Set
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 220 was not solved.
out > problem 221 was not solved.
out > problem 222 was not solved.
out > problem 223 was not solved.
out > problem 224 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems [199,214,215,216,217]
out > { solving constraint
out > [199,214,215,216,217] Env whatever = Env whatever : Set
out > compareTerm Env whatever = Env whatever : Set
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 215 was not solved.
out > problem 216 was not solved.
out > problem 217 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems [199,202,203,204,209,210]
out > { solving constraint
out > [199,202,203,204,209,210] Env whatever = Env whatever : Set
out > compareTerm Env whatever = Env whatever : Set
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 209 was not solved.
out > problem 210 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems [199,202,203,204,205,207]
out > { solving constraint
out > [199,202,203,204,205,207] Env whatever = Env whatever : Set
out > compareTerm Env whatever = Env whatever : Set
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 205 was not solved.
out > problem 207 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems [198]
out > { solving constraint
out > [198] El (el Set) =< Set 
out > compareTerm El (el Set) =< Set 
out > compareTerm (not syntactically equal) El (el Set) =< Set 
out > { compareAtom
out > compareAtom El (el Set) =< Set 
out > compareAtom Set =< Set 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > problem 198 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems [199,202,212]
out > { solving constraint
out > [199,202,212] el (El (el (snd (fst g)))) = el (snd (fst g)) : U
out > compareTerm el (El (el (snd (fst g)))) = el (snd (fst g)) : U
out > compareTerm (not syntactically equal)
out >   el (El (el (snd (fst g)))) = el (snd (fst g))
out >   : U
out > { compareTerm
out > compareTerm el (El (el (snd (fst g)))) = el (snd (fst g)) : U
out > { compareAtom
out > compareAtom el (El (el (snd (fst g)))) = el (snd (fst g)) : U
out > compareAtom el (El (el (snd (fst g)))) = el (snd (fst g)) : U
out > compareElims
out >   a     = Set → U
out >   pols0 (truncated to 10) = Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant Invariant
out >   fors0 (truncated to 10) = NotForced
out >   v     = el
out >   els01 = [$ El (el (snd (fst g)))]
out >   els02 = [$ snd (fst g)]
out > { compare Apply
out >   a    = Set → U
out >   v    = el
out >   arg1 = El (el (snd (fst g)))
out >   arg2 = snd (fst g)
out >   raw:
out >   a    = Set -> CompileTimeInlining-minimized.U
out >   v    = CompileTimeInlining-minimized.U.el
out >   arg1 = CompileTimeInlining-minimized.El
out >            (_94 (@0 .CompileTimeInlining-minimized.Σ.fst))
out >   arg2 = @0
out >            .CompileTimeInlining-minimized.Σ.fst
out >            .CompileTimeInlining-minimized.Σ.snd
out > { working on problems [259]
out > compareTerm El (el (snd (fst g))) = snd (fst g) : Set
out > compareTerm (not syntactically equal)
out >   El (el (snd (fst g))) = snd (fst g)
out >   : Set
out > { compareTerm
out > compareTerm El (el (snd (fst g))) = snd (fst g) : Set
out > { compareAtom
out > compareAtom El (el (snd (fst g))) = snd (fst g) : Set
out > compareAtom snd (fst g) = snd (fst g) : Set
out > compareElims
out >   a     = Σ (Σ (Env _107) (λ g₁ → El (_109 (_ = g₁))))
out >           (λ v → El (el (snd v)))
out >   pols0 (truncated to 10) =
out >   fors0 (truncated to 10) =
out >   v     = g
out >   els01 = [.fst, .snd]
out >   els02 = [.fst, .snd]
out > compareElims
out >   a     = Σ (Env _107) (λ g₁ → El (_109 (_ = g₁)))
out >   pols0 (truncated to 10) =
out >   fors0 (truncated to 10) =
out >   v     = fst g
out >   els01 = [.snd]
out >   els02 = [.snd]
out > }
out > }
out > problem 259 was solved!
out > }
out > }
out > }
out > }
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 212 was solved!
out > }
out > Solving awake constraints. 8 remaining.
out > { working on problems [199,214,219,229,237,240,241,242,243]
out > { solving constraint
out > [199,214,219,229,237,240,241,242,243] _138 := λ u x u₁ → whatever
out >                                         [blocked on problem 244]
out > Guarding problem 244 is solved, moving on...
out > blocked const _138 := λ u x u₁ → whatever
out > waking boxed constraint _139 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 237 was not solved.
out > problem 240 was not solved.
out > problem 241 was not solved.
out > problem 242 was solved!
out > problem 243 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems []
out > { solving constraint
out > [] _139 = whatever : Ctxt
out > compareTerm _139 = whatever : Ctxt
out > compareTerm (not syntactically equal) _139 = whatever : Ctxt
out > attempting shortcut _139 := whatever
out > term _139 :DirEq whatever
out > term _139 :DirEq whatever
out > is _139 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _139
out >   _139  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _139 := λ u x u₁ → whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 8 remaining.
out > { working on problems [199,214,219,229,237]
out > { solving constraint
out > [199,214,219,229,237] _136 := λ u x → whatever
out >                         [blocked on problem 238]
out > Guarding problem 238 is solved, moving on...
out > blocked const _136 := λ u x → whatever
out > waking boxed constraint _137 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 237 was not solved.
out > }
out > Solving awake constraints. 8 remaining.
out > { working on problems []
out > { solving constraint
out > [] _137 = whatever : Ctxt
out > compareTerm _137 = whatever : Ctxt
out > compareTerm (not syntactically equal) _137 = whatever : Ctxt
out > attempting shortcut _137 := whatever
out > term _137 :DirEq whatever
out > term _137 :DirEq whatever
out > is _137 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _137
out >   _137  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _137 := λ u x → whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 7 remaining.
out > { working on problems [199,214,219,229,230,231,232]
out > { solving constraint
out > [199,214,219,229,230,231,232] _130 := λ u x → whatever
out >                                 [blocked on problem 233]
out > Guarding problem 233 is solved, moving on...
out > blocked const _130 := λ u x → whatever
out > waking boxed constraint _131 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 230 was not solved.
out > problem 231 was solved!
out > problem 232 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems []
out > { solving constraint
out > [] _131 = whatever : Ctxt
out > compareTerm _131 = whatever : Ctxt
out > compareTerm (not syntactically equal) _131 = whatever : Ctxt
out > attempting shortcut _131 := whatever
out > term _131 :DirEq whatever
out > term _131 :DirEq whatever
out > is _131 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _131
out >   _131  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _131 := λ u x → whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 8 remaining.
out > { working on problems [199,214,219,220,221,222,223]
out > { solving constraint
out > [199,214,219,220,221,222,223] _116 := λ u → whatever
out >                                 [blocked on problem 224]
out > Guarding problem 224 is solved, moving on...
out > blocked const _116 := λ u → whatever
out > waking boxed constraint _117 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 220 was not solved.
out > problem 221 was not solved.
out > problem 222 was not solved.
out > problem 223 was solved!
out > }
out > Solving awake constraints. 10 remaining.
out > { working on problems []
out > { solving constraint
out > [] _117 = whatever : Ctxt
out > compareTerm _117 = whatever : Ctxt
out > compareTerm (not syntactically equal) _117 = whatever : Ctxt
out > attempting shortcut _117 := whatever
out > term _117 :DirEq whatever
out > term _117 :DirEq whatever
out > is _117 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _117
out >   _117  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _117 := λ u → whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems [199,214,215,216]
out > { solving constraint
out > [199,214,215,216] _110 := whatever [blocked on problem 217]
out > Guarding problem 217 is solved, moving on...
out > blocked const _110 := whatever
out > waking boxed constraint _111 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 215 was solved!
out > problem 216 was solved!
out > }
out > Solving awake constraints. 11 remaining.
out > { working on problems []
out > { solving constraint
out > [] _111 = whatever : Ctxt
out > compareTerm _111 = whatever : Ctxt
out > compareTerm (not syntactically equal) _111 = whatever : Ctxt
out > attempting shortcut _111 := whatever
out > term _111 :DirEq whatever
out > term _111 :DirEq whatever
out > is _111 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _111
out >   _111  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _111 := whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 10 remaining.
out > { working on problems [199,202,203,204,209]
out > { solving constraint
out > [199,202,203,204,209] _104 := λ z → whatever
out >                         [blocked on problem 210]
out > Guarding problem 210 is solved, moving on...
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 209 was not solved.
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems [199,202,203,204,205]
out > { solving constraint
out > [199,202,203,204,205] _98 := whatever [blocked on problem 207]
out > Guarding problem 207 is solved, moving on...
out > blocked const _98 := whatever
out > waking boxed constraint _99 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 205 was solved!
out > }
out > Solving awake constraints. 12 remaining.
out > { working on problems []
out > { solving constraint
out > [] _99 = whatever : Ctxt
out > compareTerm _99 = whatever : Ctxt
out > compareTerm (not syntactically equal) _99 = whatever : Ctxt
out > attempting shortcut _99 := whatever
out > term _99 :DirEq whatever
out > term _99 :DirEq whatever
out > is _99 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _99
out >   _99  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _99 := whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 11 remaining.
out > { working on problems []
out > { solving constraint
out > [] _90 := snd [blocked on problem 198]
out > Guarding problem 198 is solved, moving on...
out > blocked const _90 := snd
out > waking boxed constraint El (el (snd z)) = snd z : Set
out > }
out > }
out > Solving awake constraints. 11 remaining.
out > { working on problems []
out > { solving constraint
out > [] El (el (snd z)) = snd z : Set
out > compareTerm El (el (snd z)) = snd z : Set
out > compareTerm (not syntactically equal) El (el (snd z)) = snd z : Set
out > { compareTerm
out > compareTerm El (el (snd z)) = snd z : Set
out > { compareAtom
out > compareAtom El (el (snd z)) = snd z : Set
out > compareAtom snd z = snd z : Set
out > compareElims
out >   a     = Env (snoc whatever (λ v → el Set))
out >   pols0 (truncated to 10) =
out >   fors0 (truncated to 10) =
out >   v     = z
out >   els01 = [.snd]
out >   els02 = [.snd]
out > }
out > }
out > }
out > }
out > Solving awake constraints. 10 remaining.
out > { working on problems [199,214,219,229,237,240,241]
out > { solving constraint
out > [199,214,219,229,237,240,241] _140 := λ u x u₁ → whatever
out >                                 [blocked on problem 242]
out > Guarding problem 242 is solved, moving on...
out > blocked const _140 := λ u x u₁ → whatever
out > waking boxed constraint _141 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 237 was not solved.
out > problem 240 was not solved.
out > problem 241 was solved!
out > }
out > Solving awake constraints. 11 remaining.
out > { working on problems []
out > { solving constraint
out > [] _141 = whatever : Ctxt
out > compareTerm _141 = whatever : Ctxt
out > compareTerm (not syntactically equal) _141 = whatever : Ctxt
out > attempting shortcut _141 := whatever
out > term _141 :DirEq whatever
out > term _141 :DirEq whatever
out > is _141 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _141
out >   _141  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _141 := λ u x u₁ → whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 10 remaining.
out > { working on problems [199,214,219,229,230]
out > { solving constraint
out > [199,214,219,229,230] _134 := λ u x z → el Set
out >                         [blocked on problem 231]
out > Guarding problem 231 is solved, moving on...
out > blocked const _134 := λ u x z → el Set
out > waking boxed constraint _135 = el Set : U
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 230 was not solved.
out > }
out > Solving awake constraints. 10 remaining.
out > { working on problems []
out > { solving constraint
out > [] _135 = el Set : U
out > compareTerm _135 = el Set : U
out > compareTerm (not syntactically equal) _135 = el Set : U
out > attempting shortcut _135 := el Set
out > term _135 :DirEq el Set
out > term _135 :DirEq el Set
out > is _135 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _135
out >   _135  :  U := el Set
out > elimView of  el Set
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  el Set
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _135 := λ u x _ → el Set
out > shortcut successful
out >   result: CompileTimeInlining-minimized.U.el Set
out > }
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems [199,214,219,229,230]
out > { solving constraint
out > [199,214,219,229,230] _132 := λ u x → whatever
out >                         [blocked on problem 231]
out > Guarding problem 231 is solved, moving on...
out > blocked const _132 := λ u x → whatever
out > waking boxed constraint _133 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was not solved.
out > problem 230 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems []
out > { solving constraint
out > [] _133 = whatever : Ctxt
out > compareTerm _133 = whatever : Ctxt
out > compareTerm (not syntactically equal) _133 = whatever : Ctxt
out > attempting shortcut _133 := whatever
out > term _133 :DirEq whatever
out > term _133 :DirEq whatever
out > is _133 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _133
out >   _133  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _133 := λ u x → whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 8 remaining.
out > { working on problems [199,214,219,220,221,222]
out > { solving constraint
out > [199,214,219,220,221,222] _120 := λ u z → el Set
out >                             [blocked on problem 223]
out > Guarding problem 223 is solved, moving on...
out > blocked const _120 := λ u z → el Set
out > waking boxed constraint _121 = el Set : U
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 220 was not solved.
out > problem 221 was not solved.
out > problem 222 was not solved.
out > }
out > Solving awake constraints. 8 remaining.
out > { working on problems []
out > { solving constraint
out > [] _121 = el Set : U
out > compareTerm _121 = el Set : U
out > compareTerm (not syntactically equal) _121 = el Set : U
out > attempting shortcut _121 := el Set
out > term _121 :DirEq el Set
out > term _121 :DirEq el Set
out > is _121 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _121
out >   _121  :  U := el Set
out > elimView of  el Set
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  el Set
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _121 := λ u _ → el Set
out > shortcut successful
out >   result: CompileTimeInlining-minimized.U.el Set
out > }
out > }
out > Solving awake constraints. 7 remaining.
out > { working on problems [199,214,219,220,221,222]
out > { solving constraint
out > [199,214,219,220,221,222] _118 := λ u → whatever
out >                             [blocked on problem 223]
out > Guarding problem 223 is solved, moving on...
out > blocked const _118 := λ u → whatever
out > waking boxed constraint _119 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 220 was not solved.
out > problem 221 was solved!
out > problem 222 was solved!
out > }
out > Solving awake constraints. 9 remaining.
out > { working on problems []
out > { solving constraint
out > [] _119 = whatever : Ctxt
out > compareTerm _119 = whatever : Ctxt
out > compareTerm (not syntactically equal) _119 = whatever : Ctxt
out > attempting shortcut _119 := whatever
out > term _119 :DirEq whatever
out > term _119 :DirEq whatever
out > is _119 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _119
out >   _119  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _119 := λ u → whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 8 remaining.
out > { working on problems [199,214]
out > { solving constraint
out > [199,214] _114 := λ z → el Set [blocked on problem 215]
out > Guarding problem 215 is solved, moving on...
out > blocked const _114 := λ z → el Set
out > waking boxed constraint _115 = el Set : U
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > }
out > Solving awake constraints. 8 remaining.
out > { working on problems []
out > { solving constraint
out > [] _115 = el Set : U
out > compareTerm _115 = el Set : U
out > compareTerm (not syntactically equal) _115 = el Set : U
out > attempting shortcut _115 := el Set
out > term _115 :DirEq el Set
out > term _115 :DirEq el Set
out > is _115 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _115
out >   _115  :  U := el Set
out > elimView of  el Set
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  el Set
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _115 := λ _ → el Set
out > shortcut successful
out >   result: CompileTimeInlining-minimized.U.el Set
out > }
out > }
out > Solving awake constraints. 7 remaining.
out > { working on problems [199,214]
out > { solving constraint
out > [199,214] _112 := whatever [blocked on problem 215]
out > Guarding problem 215 is solved, moving on...
out > blocked const _112 := whatever
out > waking boxed constraint _113 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > }
out > Solving awake constraints. 7 remaining.
out > { working on problems []
out > { solving constraint
out > [] _113 = whatever : Ctxt
out > compareTerm _113 = whatever : Ctxt
out > compareTerm (not syntactically equal) _113 = whatever : Ctxt
out > attempting shortcut _113 := whatever
out > term _113 :DirEq whatever
out > term _113 :DirEq whatever
out > is _113 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _113
out >   _113  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _113 := whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 6 remaining.
out > { working on problems [199,202,203,204,209]
out > { solving constraint
out > [199,202,203,204,209] _104 := λ z → whatever
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 209 was not solved.
out > }
out > Solving awake constraints. 5 remaining.
out > { working on problems [199,202,203,204]
out > { solving constraint
out > [199,202,203,204] _102 := λ z → el Set [blocked on problem 205]
out > Guarding problem 205 is solved, moving on...
out > blocked const _102 := λ z → el Set
out > waking boxed constraint _103 = el Set : U
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > }
out > Solving awake constraints. 6 remaining.
out > { working on problems []
out > { solving constraint
out > [] _103 = el Set : U
out > compareTerm _103 = el Set : U
out > compareTerm (not syntactically equal) _103 = el Set : U
out > attempting shortcut _103 := el Set
out > term _103 :DirEq el Set
out > term _103 :DirEq el Set
out > is _103 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _103
out >   _103  :  U := el Set
out > elimView of  el Set
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  el Set
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _103 := λ _ → el Set
out > shortcut successful
out >   result: CompileTimeInlining-minimized.U.el Set
out > }
out > }
out > Solving awake constraints. 5 remaining.
out > { working on problems [199,202,203,204]
out > { solving constraint
out > [199,202,203,204] _100 := whatever [blocked on problem 205]
out > Guarding problem 205 is solved, moving on...
out > blocked const _100 := whatever
out > waking boxed constraint _101 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > }
out > Solving awake constraints. 5 remaining.
out > { working on problems []
out > { solving constraint
out > [] _101 = whatever : Ctxt
out > compareTerm _101 = whatever : Ctxt
out > compareTerm (not syntactically equal) _101 = whatever : Ctxt
out > attempting shortcut _101 := whatever
out > term _101 :DirEq whatever
out > term _101 :DirEq whatever
out > is _101 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _101
out >   _101  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _101 := whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 4 remaining.
out > { working on problems [199,214,219,229,237,240]
out > { solving constraint
out > [199,214,219,229,237,240] _142 := λ u x u₁ → whatever
out >                             [blocked on problem 241]
out > Guarding problem 241 is solved, moving on...
out > blocked const _142 := λ u x u₁ → whatever
out > waking boxed constraint _143 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 229 was solved!
out > problem 237 was solved!
out > problem 240 was solved!
out > }
out > Solving awake constraints. 4 remaining.
out > { working on problems []
out > { solving constraint
out > [] _143 = whatever : Ctxt
out > compareTerm _143 = whatever : Ctxt
out > compareTerm (not syntactically equal) _143 = whatever : Ctxt
out > attempting shortcut _143 := whatever
out > term _143 :DirEq whatever
out > term _143 :DirEq whatever
out > is _143 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _143
out >   _143  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _143 := λ u x u₁ → whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 3 remaining.
out > { working on problems [199,214,219,220]
out > { solving constraint
out > [199,214,219,220] _124 := λ u z → el Set [blocked on problem 221]
out > Guarding problem 221 is solved, moving on...
out > blocked const _124 := λ u z → el Set
out > waking boxed constraint _125 = el Set : U
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 220 was not solved.
out > }
out > Solving awake constraints. 3 remaining.
out > { working on problems []
out > { solving constraint
out > [] _125 = el Set : U
out > compareTerm _125 = el Set : U
out > compareTerm (not syntactically equal) _125 = el Set : U
out > attempting shortcut _125 := el Set
out > term _125 :DirEq el Set
out > term _125 :DirEq el Set
out > is _125 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _125
out >   _125  :  U := el Set
out > elimView of  el Set
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  el Set
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _125 := λ u _ → el Set
out > shortcut successful
out >   result: CompileTimeInlining-minimized.U.el Set
out > }
out > }
out > Solving awake constraints. 2 remaining.
out > { working on problems [199,214,219,220]
out > { solving constraint
out > [199,214,219,220] _122 := λ u → whatever [blocked on problem 221]
out > Guarding problem 221 is solved, moving on...
out > blocked const _122 := λ u → whatever
out > waking boxed constraint _123 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > problem 220 was solved!
out > }
out > Solving awake constraints. 4 remaining.
out > { working on problems []
out > { solving constraint
out > [] _123 = whatever : Ctxt
out > compareTerm _123 = whatever : Ctxt
out > compareTerm (not syntactically equal) _123 = whatever : Ctxt
out > attempting shortcut _123 := whatever
out > term _123 :DirEq whatever
out > term _123 :DirEq whatever
out > is _123 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _123
out >   _123  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _123 := λ u → whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 3 remaining.
out > { working on problems [199,202,203,204,209]
out > { solving constraint
out > [199,202,203,204,209] _104 := λ z → whatever
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 209 was not solved.
out > }
out > Solving awake constraints. 2 remaining.
out > { working on problems [199,214,219]
out > { solving constraint
out > [199,214,219] _128 := λ u z → el Set [blocked on problem 220]
out > Guarding problem 220 is solved, moving on...
out > blocked const _128 := λ u z → el Set
out > waking boxed constraint _129 = el Set : U
out > }
out > problem 199 was not solved.
out > problem 214 was not solved.
out > problem 219 was not solved.
out > }
out > Solving awake constraints. 3 remaining.
out > { working on problems []
out > { solving constraint
out > [] _129 = el Set : U
out > compareTerm _129 = el Set : U
out > compareTerm (not syntactically equal) _129 = el Set : U
out > attempting shortcut _129 := el Set
out > term _129 :DirEq el Set
out > term _129 :DirEq el Set
out > is _129 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _129
out >   _129  :  U := el Set
out > elimView of  el Set
out > v = Con (ConHead {conName = CompileTimeInlining-minimized.U.el, conInductive = Inductive, conFields = []}) ConOCon [Apply (Arg {argInfo = ArgInfo {argInfoHiding = NotHidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Sort (Type (Max []))})]
out > elimView (projections reduced) of  el Set
out > elimView of  Set
out > v = Sort (Type (Max []))
out > elimView (projections reduced) of  Set
out > equalSort
out >   Set₁ == Set
out >   Set1 == Set
out > equalLevel (lsuc lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lsuc Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lsuc lzero == lzero
out > { coerceSize
out > { compareType
out > compareType U =< U
out >    sorts: Set  and  Set
out > compareTerm U =< U 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _129 := λ u _ → el Set
out > shortcut successful
out >   result: CompileTimeInlining-minimized.U.el Set
out > }
out > }
out > Solving awake constraints. 2 remaining.
out > { working on problems [199,214,219]
out > { solving constraint
out > [199,214,219] _126 := λ u → whatever [blocked on problem 220]
out > Guarding problem 220 is solved, moving on...
out > blocked const _126 := λ u → whatever
out > waking boxed constraint _127 = whatever : Ctxt
out > }
out > problem 199 was not solved.
out > problem 214 was solved!
out > problem 219 was solved!
out > }
out > Solving awake constraints. 2 remaining.
out > { working on problems []
out > { solving constraint
out > [] _127 = whatever : Ctxt
out > compareTerm _127 = whatever : Ctxt
out > compareTerm (not syntactically equal) _127 = whatever : Ctxt
out > attempting shortcut _127 := whatever
out > term _127 :DirEq whatever
out > term _127 :DirEq whatever
out > is _127 a blocked term? 
out >   no
out > double checking solution
out > checking solution for meta _127
out >   _127  :  Ctxt := whatever
out > elimView of  whatever
out > v = Def CompileTimeInlining-minimized.whatever [Apply (Arg {argInfo = ArgInfo {argInfoHiding = Hidden, argInfoModality = Modality {modRelevance = Relevant, modQuantity = Quantityω QωInferred, modCohesion = Continuous}, argInfoOrigin = UserWritten, argInfoFreeVariables = UnknownFVs}, unArg = Def CompileTimeInlining-minimized.Ctxt []})]
out > elimView (projections reduced) of  whatever
out > elimView of  Ctxt
out > v = Def CompileTimeInlining-minimized.Ctxt []
out > elimView (projections reduced) of  Ctxt
out > { coerceSize
out > leqSort Set =< Set
out > compareLevel Agda.Primitive.lzero =< Agda.Primitive.lzero
out > compareLevelView lzero =< lzero
out > }
out > { coerceSize
out > { compareType
out > compareType Ctxt =< Ctxt
out >    sorts: Set  and  Set
out > compareTerm Ctxt =< Ctxt 
out > equalSort
out >   Set == Set
out >   Set == Set
out > equalLevel (lzero) (lzero)
out > equalLevel
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > reduced
out >   Agda.Primitive.lzero == Agda.Primitive.lzero
out > equalLevel lzero == lzero
out > }
out > }
out > solving _127 := λ u → whatever
out > shortcut successful
out >   result: CompileTimeInlining-minimized.whatever
out >             {CompileTimeInlining-minimized.Ctxt}
out > }
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems [199,202,203,204,209]
out > { solving constraint
out > [199,202,203,204,209] _104 := λ z → whatever
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 209 was not solved.
out > }
out > Solving awake constraints. 0 remaining.
out > blocked _146 := el'
out >                 (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g))) _145
out >      by [[249, 255, 256] lookup
out >                          (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >                          (λ _ → el Set) _145 g₁
out >                            = snd (fst g₁)
out >                            : Set]
out > new meta (ConcreteDef): [] |-
out >   _147 : Type myctxt (λ g → el (snd (fst g)))
out > setting twin of _147 to be _146
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 6 remaining.
out > { working on problems []
out > { solving constraint
out > [] _146
out >      := el' (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >         _145
out >      [blocked on problem 249]
out > Guarding problem 249 is still unsolved.
out > }
out > }
out > Solving awake constraints. 5 remaining.
out > { working on problems [199,202,203,204,209]
out > { solving constraint
out > [199,202,203,204,209] _104 := λ z → whatever
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 209 was not solved.
out > }
out > Solving awake constraints. 4 remaining.
out > { working on problems [249,255,256]
out > { solving constraint
out > [249,255,256] lookup
out >               (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >               (λ _ → el Set) _145 g₁
out >                 = snd (fst g₁)
out >                 : Set
out > compareTerm
out >   lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >   (λ _ → el Set) _145 g₁ = snd (fst g₁)
out >   : Set
out > compareTerm (not syntactically equal)
out >   lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >   (λ _ → el Set) _145 g₁ = snd (fst g₁)
out >   : Set
out > { compareTerm
out > compareTerm
out > lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out > (λ _ → el Set) _145 g₁
out > = snd (fst g₁) : Set
out > { compareAtom
out > compareAtom lookup
out >             (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >             (λ _ → el Set) _145 g₁ =
out >             snd (fst g₁) : Set
out > compareAtom [ lookup
out >               (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >               (λ _ → el Set) _145 g₁ ]_145 =
out >             snd (fst g₁) : Set
out > }
out > }
out > }
out > problem 249 was not solved.
out > problem 255 was not solved.
out > problem 256 was not solved.
out > }
out > Solving awake constraints. 3 remaining.
out > { working on problems []
out > { solving constraint
out > [] _144
out >      := suc (snoc whatever (λ v → el Set)) (λ z → el (El (el (snd z))))
out >         (λ _ → el Set)
out >      [blocked on problem 199]
out > Guarding problem 199 is still unsolved.
out > }
out > }
out > Solving awake constraints. 2 remaining.
out > { working on problems [199,202]
out > { solving constraint
out > [199,202] _108 := λ z → el Set [blocked on problem 203]
out > Guarding problem 203 is still unsolved.
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems [199,202]
out > { solving constraint
out > [199,202] _106 := whatever [blocked on problem 203]
out > Guarding problem 203 is still unsolved.
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 6 remaining.
out > { working on problems [199,202]
out > { solving constraint
out > [199,202] _106 := whatever [blocked on problem 203]
out > Guarding problem 203 is still unsolved.
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > }
out > Solving awake constraints. 5 remaining.
out > { working on problems [199,202]
out > { solving constraint
out > [199,202] _108 := λ z → el Set [blocked on problem 203]
out > Guarding problem 203 is still unsolved.
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > }
out > Solving awake constraints. 4 remaining.
out > { working on problems []
out > { solving constraint
out > [] _144
out >      := suc (snoc whatever (λ v → el Set)) (λ z → el (El (el (snd z))))
out >         (λ _ → el Set)
out >      [blocked on problem 199]
out > Guarding problem 199 is still unsolved.
out > }
out > }
out > Solving awake constraints. 3 remaining.
out > { working on problems [249,255,256]
out > { solving constraint
out > [249,255,256] lookup
out >               (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >               (λ _ → el Set) _145 g₁
out >                 = snd (fst g₁)
out >                 : Set
out > compareTerm
out >   lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >   (λ _ → el Set) _145 g₁ = snd (fst g₁)
out >   : Set
out > compareTerm (not syntactically equal)
out >   lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >   (λ _ → el Set) _145 g₁ = snd (fst g₁)
out >   : Set
out > { compareTerm
out > compareTerm
out > lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out > (λ _ → el Set) _145 g₁
out > = snd (fst g₁) : Set
out > { compareAtom
out > compareAtom lookup
out >             (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >             (λ _ → el Set) _145 g₁ =
out >             snd (fst g₁) : Set
out > compareAtom [ lookup
out >               (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >               (λ _ → el Set) _145 g₁ ]_145 =
out >             snd (fst g₁) : Set
out > }
out > }
out > }
out > problem 249 was not solved.
out > problem 255 was not solved.
out > problem 256 was not solved.
out > }
out > Solving awake constraints. 2 remaining.
out > { working on problems [199,202,203,204,209]
out > { solving constraint
out > [199,202,203,204,209] _104 := λ z → whatever
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 209 was not solved.
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] _146
out >      := el' (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >         _145
out >      [blocked on problem 249]
out > Guarding problem 249 is still unsolved.
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 6 remaining.
out > { working on problems []
out > { solving constraint
out > [] _146
out >      := el' (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >         _145
out >      [blocked on problem 249]
out > Guarding problem 249 is still unsolved.
out > }
out > }
out > Solving awake constraints. 5 remaining.
out > { working on problems [199,202,203,204,209]
out > { solving constraint
out > [199,202,203,204,209] _104 := λ z → whatever
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 209 was not solved.
out > }
out > Solving awake constraints. 4 remaining.
out > { working on problems [249,255,256]
out > { solving constraint
out > [249,255,256] lookup
out >               (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >               (λ _ → el Set) _145 g₁
out >                 = snd (fst g₁)
out >                 : Set
out > compareTerm
out >   lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >   (λ _ → el Set) _145 g₁ = snd (fst g₁)
out >   : Set
out > compareTerm (not syntactically equal)
out >   lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >   (λ _ → el Set) _145 g₁ = snd (fst g₁)
out >   : Set
out > { compareTerm
out > compareTerm
out > lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out > (λ _ → el Set) _145 g₁
out > = snd (fst g₁) : Set
out > { compareAtom
out > compareAtom lookup
out >             (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >             (λ _ → el Set) _145 g₁ =
out >             snd (fst g₁) : Set
out > compareAtom [ lookup
out >               (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >               (λ _ → el Set) _145 g₁ ]_145 =
out >             snd (fst g₁) : Set
out > }
out > }
out > }
out > problem 249 was not solved.
out > problem 255 was not solved.
out > problem 256 was not solved.
out > }
out > Solving awake constraints. 3 remaining.
out > { working on problems []
out > { solving constraint
out > [] _144
out >      := suc (snoc whatever (λ v → el Set)) (λ z → el (El (el (snd z))))
out >         (λ _ → el Set)
out >      [blocked on problem 199]
out > Guarding problem 199 is still unsolved.
out > }
out > }
out > Solving awake constraints. 2 remaining.
out > { working on problems [199,202]
out > { solving constraint
out > [199,202] _108 := λ z → el Set [blocked on problem 203]
out > Guarding problem 203 is still unsolved.
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems [199,202]
out > { solving constraint
out > [199,202] _106 := whatever [blocked on problem 203]
out > Guarding problem 203 is still unsolved.
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > }
out > Solving awake constraints. 0 remaining.
out > Solving awake constraints. 6 remaining.
out > { working on problems [199,202]
out > { solving constraint
out > [199,202] _106 := whatever [blocked on problem 203]
out > Guarding problem 203 is still unsolved.
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > }
out > Solving awake constraints. 5 remaining.
out > { working on problems [199,202]
out > { solving constraint
out > [199,202] _108 := λ z → el Set [blocked on problem 203]
out > Guarding problem 203 is still unsolved.
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > }
out > Solving awake constraints. 4 remaining.
out > { working on problems []
out > { solving constraint
out > [] _144
out >      := suc (snoc whatever (λ v → el Set)) (λ z → el (El (el (snd z))))
out >         (λ _ → el Set)
out >      [blocked on problem 199]
out > Guarding problem 199 is still unsolved.
out > }
out > }
out > Solving awake constraints. 3 remaining.
out > { working on problems [249,255,256]
out > { solving constraint
out > [249,255,256] lookup
out >               (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >               (λ _ → el Set) _145 g₁
out >                 = snd (fst g₁)
out >                 : Set
out > compareTerm
out >   lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >   (λ _ → el Set) _145 g₁ = snd (fst g₁)
out >   : Set
out > compareTerm (not syntactically equal)
out >   lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >   (λ _ → el Set) _145 g₁ = snd (fst g₁)
out >   : Set
out > { compareTerm
out > compareTerm
out > lookup (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out > (λ _ → el Set) _145 g₁
out > = snd (fst g₁) : Set
out > { compareAtom
out > compareAtom lookup
out >             (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >             (λ _ → el Set) _145 g₁ =
out >             snd (fst g₁) : Set
out > compareAtom [ lookup
out >               (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >               (λ _ → el Set) _145 g₁ ]_145 =
out >             snd (fst g₁) : Set
out > }
out > }
out > }
out > problem 249 was not solved.
out > problem 255 was not solved.
out > problem 256 was not solved.
out > }
out > Solving awake constraints. 2 remaining.
out > { working on problems [199,202,203,204,209]
out > { solving constraint
out > [199,202,203,204,209] _104 := λ z → whatever
out > }
out > problem 199 was not solved.
out > problem 202 was not solved.
out > problem 203 was not solved.
out > problem 204 was not solved.
out > problem 209 was not solved.
out > }
out > Solving awake constraints. 1 remaining.
out > { working on problems []
out > { solving constraint
out > [] _146
out >      := el' (snoc (snoc whatever (λ z → el Set)) (λ g → el (snd g)))
out >         _145
out >      [blocked on problem 249]
out > Guarding problem 249 is still unsolved.
out > }
out > }
out > Solving awake constraints. 0 remaining.
out > Failed to solve the following constraints:
out >   [249, 255, 256] lookup
out >                   (snoc (snoc whatever (λ _ → el Set)) (λ g → el (snd g)))
out >                   (λ _ → el Set)
out >                   (suc (snoc whatever (λ v → el Set)) (λ z → el (El (el (snd z))))
out >                    (λ _ → el Set))
out >                   g₁
out >                     = snd (fst g₁)
out >                     : Set
out > Unsolved metas at the following locations:
out >   CompileTimeInlining-minimized.agda:47,34-39
out >   CompileTimeInlining-minimized.agda:47,17-43
out >   CompileTimeInlining-minimized.agda:47,8-46
out >
